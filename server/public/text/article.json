[
    {
        "index": 0,
        "title": "CSS学习",
        "essay": "\r\n# CSS学习笔记\r\n\r\nCSS 层叠样式表 : 是一种标记语言\r\n\r\n\r\n## 选择器\r\n\r\n选择器分为==基础选择器==和==标签选择器==两大类。\r\n\r\n### 基础选择器\r\n\r\n基础选择器是由单个选择器组成的。\r\n\r\n#### 标签选择器\r\n\r\n标签选择器是指将HTML中的标签作为选择器的名称进行选择。\r\n\r\n优点：能够快速为页面中**同类型**的标签统一设置样式。\r\n\r\n缺点：不能设计差异化样式，只能选择全部的当前标签。\r\n\r\n#### 类选择器\r\n\r\n如果想要差异化选择不同的标签，单独选一个或者几个标签，可以使用类选择器。\r\n\r\n结构需要使用class属性来调用class类。\r\n\r\n```css\r\n    <style>\r\n        .red {\r\n            color: blue;\r\n            font-size: 26px;\r\n        }\r\n    </style>\r\n\t<body>\r\n\t\t<li class=\"red\">冰雨</li>\r\n\t</body>\r\n```\r\n\r\n##### 多类名\r\n\r\n1. 我们可以给一个标签指定多个类名，从而达到更多的选择目的。这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。\r\n\r\n```html\r\n    <style>\r\n        .red {\r\n            color: red;\r\n        }\r\n        .font35 {\r\n            font-size: 35px;\r\n        }\r\n    </style>\r\n<div class=\"red font35\">刘德华</div>\r\n```\r\n\r\n2. 多类名开发中使用场景\r\n    1. 可以把一些标签元素相同的样式放到一个类里。\r\n    2. 这些标签都可以调用这个公共的类，然后再调用自己独有的类。\r\n\r\n#### id选择器\r\n\r\nid选择器可以为标有特定id的HTML元素指定特定的样式。\r\n\r\nHTML元素以id属性来设置id选择器，css中id选择器以\"#\"来定义。\r\n\r\n```html\r\n    <style>\r\n        #pink {\r\n            color: pink;\r\n        }\r\n    </style>\r\n<div id=\"pink\">迈克尔杰克逊</div>\r\n```\r\n\r\n注意：样式#定义，结构id调用，只能==调用一次==，别人切勿调用。\r\n\r\n##### id选择器和类选择器的区别\r\n\r\nid选择器和类选择器最大的不同是在**使用次数**上。\r\n\r\n#### 通配符选择器\r\n\r\n在css中，通配符选择器使用 \"*\"定义，它表示选取页面中所有元素（标签）。\r\n\r\n```html\r\n* {\r\n\tmargin:0;\r\n\tpadding:0;\r\n  }\r\n```\r\n\r\n![image-20220509163633224](css_learn.assets/image-20220509163633224.png)\r\n\r\n### 复合选择器\r\n\r\n复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。\r\n\r\n常用的复合选择器包括：==后代选择器==、==子选择器==、==并集选择器==、==伪类选择器==等\r\n\r\n#### 后代选择器\r\n\r\n又称 包含选择器\r\n\r\n元素1  元素2  {样式声明} \r\n\r\n```html\r\nol li {\r\n\tcolor: pink;\r\n}\r\n```\r\n\r\n元素2可以是儿子也可以是孙子，只要是元素1的后代即可。\r\n\r\n#### 子选择器\r\n\r\n子元素选择器只能选择作为某元素的最近一级子元素。简单理解就是选择亲儿子。\r\n\r\n语法： 元素1  > 元素2 {样式声明}\r\n\r\n### 并集选择器\r\n\r\n==并集选择器可以选择多组标签，同时为他们定义相同的样式==。通常用于集体声明。\r\n\r\n使用逗号分割。\r\n\r\n​    div,p {\r\n\r\n​      color: red;\r\n\r\n​    }\r\n\r\n### 伪类选择器\r\n\r\n伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。\r\n\r\n使用==冒号 ( : )== 表示 :hover、:first-child 。\r\n\r\n分为==链接伪类==、==结构伪类==等。\r\n\r\n#### 链接伪类选择器\r\n\r\n```html\r\na:link  /* 选择器所有未访问的链接 */\r\na:visited  /* 选择器所有已被访问的链接 */\r\na:hover  /* 选择鼠标指针位于其上的链接 */\r\na:active  /* 选择活动链接(鼠标按下未弹起的链接) */\r\n```\r\n\r\n==注意点==：\r\n\r\n1. 为了确保生效，按照LVHA的顺序。\r\n2. a链接有默认样式，链接样式需要单独指定。\r\n\r\n#### :focus 伪类选择器\r\n\r\n用于选取获得焦点的表单元素。 中间不能加空格。\r\n\r\n```html\r\ninput:focus {\r\n\tbackground-color: pink;\r\n\t\t\t}\r\n```\r\n\r\n![image-20220510132704941](css_learn.assets/image-20220510132704941.png)\r\n\r\n## 字体属性\r\n\r\nCSS Fonts（字体）属性用于定义字体系列、大小、粗细和文字样式（如斜体）。\r\n\r\n### 字体\r\n\r\nfont-family\r\n\r\n```html\r\nbody {\r\n\tfont-family: 'Microsoft YaHei',tahoma,arial;\r\n}\r\n```\r\n\r\n各种字体之间必须使用英文状态下的逗号隔开。\r\n\r\n### 字体大小\r\n\r\nfont-size 属性定义字体大小。\r\n\r\n```html\r\np {\r\n\tfont-size: 14px;\r\n}\r\n```\r\n\r\n标题标签比较特殊，需要特别指定大小。\r\n\r\n### 字体粗细\r\n\r\nfont-weight           700为加粗，和 bold一个效果。 400为正常。\r\n\r\n```html\r\n.bold {\r\n\tfont-weight: bold;\r\n}\r\n```\r\n\r\n### 文字样式\r\n\r\nfont-style  设置文本的风格，斜体。\r\n\r\n```html\r\np {\r\n\tfont-style: normal; //正常\r\n\tfont-style: italic; //斜体\r\n}\r\n```\r\n\r\nhtml中的 (em, i)标签也可以表示倾斜。\r\n\r\n### 字体复合属性\r\n\r\n```body\r\nbody {\r\n\tfont: font-style font-weight font-size/line-height font-family\r\n}\r\n```\r\n\r\n前面两个属性可以省略，但必须保留font-size和font-family属性，否则font属性将不起作用。\r\n\r\n![image-20220509185304262](css_learn.assets/image-20220509185304262.png)\r\n\r\n## CSS文本属性\r\n\r\n\r\n\r\n#### CSS Text（文本）\r\n\r\n属性可以定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。\r\n\r\n#### 颜色 color\r\n\r\n#### text-align 对齐文本     \r\n\r\n本质是让盒子里面的文字水平居中对齐。\r\n\r\n#### text-decoration 装饰文本\r\n\r\n一般用  text-decoration: none;   将超链接里的下划线取消。\r\n\r\n或者 ==underline== 可以添加下划线。\r\n\r\n```html\r\na {\r\n\ttext-decoration: none;\r\n}\r\n```\r\n\r\n#### text-indent 首行文本缩进   \r\n\r\n10px  2em  \r\n\r\n==em==:  是一个相对单位，就是当前元素(font-size) 1个文字的大小。\r\n\r\n#### line-height 设置行高\r\n\r\n可以控制文字行与行之间的距离。\r\n\r\n```html\r\np {\r\n\tline-height: 26px;\r\n}\r\n```\r\n\r\n![image-20220509194022959](css_learn.assets/image-20220509194022959.png)\r\n\r\n测量行高：从上一行的最下沿到下一行的最下沿。\r\n\r\n![image-20220509194526220](css_learn.assets/image-20220509194526220.png)\r\n\r\n## CSS的引入方式\r\n\r\n### 1. 行内样式表\r\n\r\n### 2. 内部样式表\r\n\r\n### 3. 外部样式表\r\n\r\n在html页面中，使用<link>标签引入css文件\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"css文件路径\">\r\n```\r\n\r\n## CSS的元素显示模式\r\n\r\n### 块元素\r\n\r\np, div\r\n\r\n### 行内元素\r\n\r\nspan  a   高和宽直接设置是无效的。    只能容纳文本或其他行内元素。\r\n\r\n特殊情况：  `<a>` 里面可以放块级元素，但是转换一下块级模式，最安全。\r\n\r\n### 行内块元素\r\n\r\n<img/> <input/>  `<td>` 同时具有块元素和行内元素的特点。\r\n\r\n特点\r\n\r\n1. 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙，一行可以显示多个。\r\n2. 默认宽度就是它本身内容的宽度\r\n3. 高度，行高、外边距一级内边距都可以控制。\r\n\r\n ![image-20220510133846811](css_learn.assets/image-20220510133846811.png)\r\n\r\n### 元素显示模式转换\r\n\r\n特殊情况下，我们需要元素模式的转换，一个模式的元素需要另外一种模式的特性。\r\n\r\n比如：想要增加链接 `<a>`的触发范围。\r\n\r\n```html\r\n// 转换为块级元素\r\ndisplay: block;\r\n// 转换为行内元素\r\ndisplay:inline;\r\n// 转换为行内块元素\r\ndisplay: inline-block;\r\n```\r\n\r\n### 单行文字垂直居中\r\n\r\n解决方案：让文字的行高等于盒子的高度。  line-height === height \r\n\r\n==原理==： ![image-20220510135656417](css_learn.assets/image-20220510135656417.png)\r\n\r\n## CSS的背景\r\n\r\n### 设置背景颜色\r\n\r\n背景颜色透明： background-color: transparent;\r\n\r\n\r\n\r\n### 背景图片 background-image\r\n\r\n优点：便于控制位置。\r\n\r\n```html\r\nbackground-image: url();\r\n```\r\n\r\n#### 背景平铺\r\n\r\n如果需要在HTML页面上对背景图像进行平铺，可以使用background-repeat属性\r\n\r\n```html\r\nbackground-repeat:repeat|no-repeat|repeat-x|repeat-y\r\n```\r\n\r\n#### 背景图片位置\r\n\r\nbackground-position\r\n\r\n1.参数是方位名词\r\n\r\n* 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top 和 top left 效果一致。\r\n* 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐。\r\n\r\n#### 背景图像固定\r\n\r\nbackground-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动 。\r\n\r\nscroll 背景图像随对象内容滚动。 fixed 背景图像固定。\r\n\r\n```html\r\nbackground-attachment: scroll | fixed\r\n```\r\n\r\n#### 背景色半透明\r\n\r\n```html\r\nbackground: rgba(0,0,0,0.3);\r\n//最后一个参数是alpha透明度，取值范围在0~1之间。\r\n```\r\n\r\n![image-20220510180645477](css_learn.assets/image-20220510180645477.png)\r\n\r\n## CSS的三大属性\r\n\r\nCSS有三个非常重要的特性： 层叠性、继承性、优先级。\r\n\r\n#### 1.层叠性\r\n\r\n相同选择器给设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。层叠性主要解决样式冲突的问题。\r\n\r\n\r\n\r\n#### 2. 继承性\r\n\r\n字标签会继承父标签的某些样式，比如文本样色和字号。\r\n\r\n##### 行高的继承\r\n\r\n```html\r\nbody {\r\n\tfont: 12px/1.5  'microsoft yahei'\r\n}\r\n```\r\n\r\nbody 行高 1.5  写法优势是子元素可以根据自己的字体大小自动调整行高。\r\n\r\n#### 3.优先级\r\n\r\n当同一个元素指定多个选择器，就有优先级的产生。\r\n\r\n* 选择器相同，则执行层叠性。\r\n* 选择器不同，则根据选择器权重执行。\r\n\r\n![image-20220510231153454](css_learn.assets/image-20220510231153454.png)\r\n\r\n## 盒子模型\r\n\r\nCSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括边框、外边距、内边距和实际内容。\r\n\r\n![image-20220510231345358](css_learn.assets/image-20220510231345358.png)\r\n\r\n#### 内边距 padding\r\n\r\n![image-20220510231918765](css_learn.assets/image-20220510231918765.png)\r\n\r\n padding内边距可以撑开盒子，比如说，导航栏中的字数不一样多，我们可以不用给每个盒子宽度，直接给padding最合适。\r\n\r\n![image-20220510232204886](css_learn.assets/image-20220510232204886.png)\r\n\r\n#### 外边距 margin\r\n\r\nmargin属性用于设置外边距，即控制盒子和盒子之间的距离。\r\n\r\nmargin: auto; //可以设置盒子水平居中\r\n\r\n## 浮动 （float）\r\n\r\n### 传统网页布局的三种方式\r\n\r\n* 普通流/标准流\r\n* 浮动\r\n* 定位\r\n\r\n网页布局，多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。\r\n\r\n==float== 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。\r\n\r\n### 浮动特性\r\n\r\n#### ==脱标==\r\n\r\n1. 脱离标准流的控制移动到指定位置。\r\n2. 浮动的盒子不再保留原先的位置。\r\n\r\n#### 浮动元素会一行内显示并且顶部对齐\r\n\r\n#### 浮动元素会具有行内块元素的特性\r\n\r\n浮动元素经常和标准流父级搭配使用。\r\n\r\n![image-20220511203802674](css_learn.assets/image-20220511203802674.png)\r\n\r\n### 清除浮动\r\n\r\n为什么要清除浮动？\r\n\r\n1. 父盒子必须有高度吗？\r\n\r\n2. 父盒子高度不能写死。 \r\n3. 子盒子浮动不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。\r\n\r\n前提：\r\n\r\n\t1. 父级没高度\r\n\t2. 子盒子浮动\r\n\t3. 影响下面布局。\r\n\r\nclear: both;\r\n\r\n#### 1. 额外标签法\r\n\r\n在最后一个盒子后面添加一个块级盒子，设置属性： clear: both;\r\n\r\n#### 2. 父级添加overflow属性\r\n\r\n```html\r\noverflow: hidden;\r\n```\r\n\r\n缺点：无法显示溢出的部分。\r\n\r\n#### 3. 父级添加 :after伪元素\r\n\r\n```html\r\n.clearfix:after {\r\n\tcontent: \"\";\r\n\tdisplay: block;\r\n\theight: 0;\r\n\tclear: both;\r\n\tvisibility: hidden;\r\n}\r\n.clearfix {   /*IE6、7专有*/\r\n\t*zoom: 1;\r\n}\r\n```\r\n\r\n#### 4. 父级添加双伪元素\r\n\r\n```html\r\n.clearfix:before, .clearfix:after {\r\n\tcontent: \"\";\r\n\tdisplay: table;\r\n}\r\n.clearfix:after {\r\n\tclear: both;\r\n}\r\n.clearfix {   /*IE6、7专有*/\r\n\t*zoom: 1;\r\n}\r\n```\r\n\r\n## 定位\r\n\r\n### 为什么需要定位？\r\n\r\n1. 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。\r\n2. 当我们滚动窗口的时候，盒子是==固定屏幕某个位置==的。\r\n\r\n定位 = 定位模式 + 边偏移\r\n\r\n#### 定位模式\r\n\r\n通过 CSS 的 position属性设置。\r\n\r\n* static : 静态定位\r\n* relative: 相对定位\r\n* absolute: 绝对定位\r\n* fixed: 固定定位\r\n\r\n#### 边偏移\r\n\r\n边偏移就是定位的盒子移动到最终位置。有top、bottom、left和right 4个属性。\r\n\r\n`top:80px` 例子\r\n\r\n#### 相对定位 （重要）relative\r\n\r\n特点：\r\n\r\n1. 相对于原来的位置来移动的（==移动位置的时候参照点是自己原来的位置==）\r\n2. 原来在标准流的==位置继续占有==，后面的盒子仍然以标准流的方式对待。（==不脱标==）\r\n\r\n#### 绝对定位 （重要） absolute\r\n\r\n绝对定位是元素在移动位置的时候，相对于祖先元素来说的。\r\n\r\n特点：\r\n\r\n1. 如果没有父元素或者父元素没有定位，以浏览器为准进行对齐。\r\n2. 如果父元素有定位，则以最近一级的有定位祖先元素为参考点移动位置。\r\n3. 绝对定位不再占有原先的位置。\r\n\r\n#### 子绝父相\r\n\r\n子级是绝对定位的话，父级要使用相对定位。\r\n\r\n1. 子级绝对定位，不会占有位置，可以放到父盒子的任何地方，不影响兄弟盒子。\r\n2. 父盒子需要加定位限制子盒子在父盒子内显示。\r\n3. 父盒子占位时需要占有位置，因此父盒子只能是相对定位。\r\n\r\n#### 固定定位 fixed (重要)\r\n\r\n固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。\r\n\r\n特点：\r\n\r\n1. 以浏览器的可视窗口作为参照。\r\n2. 跟父盒子没有关系。\r\n3. 不随滚动条滚动。\r\n4. 不占有位置。\r\n\r\n固定定位小技巧： 固定在版心右侧位置。\r\n\r\n1. 让固定定位的盒子`left: 50%` . 走到可视区的一半。\r\n2. 让盒子 `margin-left: 版心宽度的一般距离 `\r\n\r\n#### 粘性定位\r\n\r\n\r\n\r\n![image-20220511231343417](css_learn.assets/image-20220511231343417.png)\r\n\r\n#### 定位叠放次序\r\n\r\n在使用定位布局的时候，可能会出现盒子重叠的情况。此时可以使用`z-index`来控制盒子的前后次序。\r\n\r\n```html\r\nz-index: 1;\r\n// 数值越大，盒子越靠上。\r\n```\r\n\r\n数字后面不能加单位。\r\n\r\n只有定位的盒子才有`z-index`属性。\r\n\r\n#### 绝对定位的盒子居中\r\n\r\n加了绝对定位的盒子不能通过`margin: 0 auto`水平居中，但是可以通过以下计算方法实现水平和垂直居中。\r\n\r\n1. `left: 50%;`, 让盒子的左侧移动到父级元素的水平中心位置。\r\n2. `margin-left: -100px;`, 让盒子向左移动自身宽度的一半。\r\n\r\n#### 定位的特殊属性\r\n\r\n1. 行内元素添加绝对或者固定定位，可以直接设置宽度和高度。\r\n2. 块级元素添加绝对或者固定定位，若果不给宽高，默认是内容的宽度和高度。\r\n3. 浮动元素、绝对定位（固定定位）的元素都不会触发外边距合并的问题。\r\n\r\n#### 定位的拓展\r\n\r\n1. 浮动的元素不会压住下面标准流的文字。\r\n2. 绝对（固定）定位的盒子会压住下面标准流的所有内容。\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 1,
        "title": "JavaScirpt笔记",
        "essay": "# 1.初识JavaScirpt\r\n\r\n- JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）\r\n- 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行\r\n- 现在也可以基于 Node.js 技术进行服务器端编程\r\n\r\n![image-20220810122530062](C:\\Users\\86158\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220810122530062.png)\r\n\r\n# 2.浏览器执行JS简介\r\n\r\n浏览器分成两部分：渲染引擎和 JS 引擎\r\n\r\n渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit\r\nJS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8\r\n浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。\r\n\r\n![image-20220810122515055](C:\\Users\\86158\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220810122515055.png)\r\n\r\n# 3.JS的组成\r\n\r\nJavaScript 包括 ECMAScript、DOM、BOM\r\n\r\n![image-20220810122626670](C:\\Users\\86158\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220810122626670.png)\r\n\r\n# 4.ECMAScript\r\n\r\n**ECMAScript** 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。\r\n\r\n![image-20220810122708821](C:\\Users\\86158\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220810122708821.png)\r\n\r\nECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。\r\n\r\n# 5.DOM文档对象模型\r\n\r\n**文档对象模型**（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。\r\n\r\n# 6.BOM浏览器对象模型\r\n\r\n**BOM** (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。",
        "timemini": ""
    },
    {
        "index": 2,
        "title": "Node",
        "essay": "# Node.js（一） | 青训营笔记\r\n\r\n这是我参与「第四届青训营 」笔记创作活动的的第5天。\r\n\r\n以下是深入学习Node.js以及结合上课内容写的笔记，整理了一些Node.js中可能会被忽略的知识和问题。\r\n\r\n## 创建一个服务器\r\n\r\n```javascript\r\n//创建服务器\r\nvar http = require('http');\r\n\r\nhttp.createServer(function (request, response) {\r\n\r\n    //发送 HTTP 头部\r\n    //HTTP 状态码：200，OK\r\n    //内容类型：text/plain\r\n    response.writeHead(200, { 'Content-Type': 'text/palin' });\r\n\r\n    //发送响应数据 \"Hello World\"\r\n    response.end('Hello World\\n');\r\n}).listen(8888);\r\n\r\n//终端打印如下信息\r\nconsole.log('Server running at http://127.0.0.1:8888/');\r\n```\r\n\r\n## 回调函数\r\n\r\n```javascript\r\nvar fs = require(\"fs\");\r\n\r\n//同步读取（阻塞读取）\r\nvar data = fs.readFileSync(\"README.txt\");\r\n//读出来为Buffer类型十六进制模式\r\nconsole.log(data);\r\nconsole.log(data.toString());\r\nconsole.log(\"程序执行结束！\");\r\n\r\n// //异步读取（非阻塞读取）\r\n// var p = new Promise();\r\n//使用Promise封装readFile操作\r\nfunction readMyFile(FILE) {\r\n    return new Promise((resolve, reject) => {\r\n        require(\"fs\").readFile(FILE, (err, data) => {\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                resolve(data);\r\n            }\r\n        })\r\n    })\r\n}\r\nreadMyFile(\"README.txt\").then(value => {\r\n    console.log(data.toString());\r\n    console.log(\"文件读取成功！\");\r\n}, reason => {\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n\r\n\r\n## 事件循环\r\n\r\n事件驱动程序：\r\n\t简单来说，因为有异步函数执行的存在，**当Web Server(Web服务器)接收到请求时，就会把它关闭并且执行，然后服务下一个web请求，当请求完成时，它会被放到队列的开头，结果被返回给用户。**\r\n\r\n\t就像web服务器只管接待顾客，而具体工作有其他员工进行，事情处理完成后结果返回给顾客，虽然JavaScript是单线程，但是这种异步函数的处理方式极大的优化了性能，防止因为一条线程造成阻塞的现象\r\n\r\n![image-20220801212626699](https://xiaomogui666.oss-cn-beijing.aliyuncs.com/img/202208052156867.png)\r\n\r\n## EventEmitter\r\n\r\n大多数情况下我们不会直接使用EventListener，而是在对象中继承它。\r\n\r\n只要是支持事件响应的核心模块都是EventListener的子类\r\n\r\n为什么要这样做呢？原因有两点：\r\n首先，具有某个实体功能的对象实现事件符合语义，事件的监听和发生应该是一个对象的方法。其次，JavaScript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系",
        "timemini": ""
    },
    {
        "index": 3,
        "title": "Node",
        "essay": "# Node.js（二） | 青训营笔记\r\n\r\n这是我参与「第四届青训营 」笔记创作活动的的第6天。\r\n\r\n以下是深入学习Node.js以及结合上课内容写的笔记，整理了一些Node.js中可能会被忽略的知识和问题。\r\n\r\n### Stream\r\n\r\n```javascript\r\n/**\r\n * Stream有四种流类型：\r\n *  Readable-可读操作\r\n    Writeable-可写操作\r\n    Duplex-可读可写操作\r\n    Transform-操作被写入数据，然后读出结果\r\n *  */\r\n/**\r\n * 所有的Stream对象都是EventEmitter的实例。常用的事件有:\r\n *  data-当有数据可读时触发\r\n *  end-没有更多的数据可读时触发\r\n *  error-在接收和写入过程中发生错误是触发\r\n *  finish-所有数据已经被写入到地城系统时触发\r\n */\r\n\r\nvar fs = require('fs');\r\n\r\n\r\nvar data1 = \"写入世界\";\r\n\r\n//创建一个可写入的流，写入到文件 output.txt 中\r\nvar writeStream = fs.createWriteStream('output.txt');\r\n\r\n//使用 utf-8 编码写入数据\r\nwriteStream.write(data1, 'UTF8');\r\n\r\n//标记文件的末尾\r\nwriteStream.end();\r\n\r\n// 处理流事件 ———> finish、error\r\nwriteStream.on('finish', function () {\r\n   console.log(\"写入完成。\");\r\n})\r\n\r\n//监视error\r\nwriteStream.on('error', function (err) {\r\n   console.log(err.stack);\r\n})\r\n\r\nconsole.log(\"程序执行完毕\");\r\n\r\nvar data = '';\r\n\r\n//创建可读流\r\nvar readerStream = fs.createReadStream('input.txt');\r\n\r\n//设置编码为utf-8\r\nreaderStream.setEncoding('UTF8');\r\n\r\n//处理流事件 ———> data,end,and error\r\nreaderStream.on('data', function (chunk) {\r\n   data += chunk;\r\n})\r\n\r\n//写入成功\r\nreaderStream.on('end', function () {\r\n   console.log(data);\r\n})\r\n\r\n//出现错误\r\nreaderStream.on('error', (err) => {\r\n   console.log(err.stack);\r\n})\r\n\r\nconsole.log(\"程序执行完毕！\");\r\n```\r\n\r\n运行后得出结论\r\n\r\n读写流执行顺序（无论如何变换代码执行顺序）：正常代码执行完毕（包括常规的输出，console等一系列操作）——>先执行写入——>在执行读出\r\n\r\n![image-20220803204527174](https://xiaomogui666.oss-cn-beijing.aliyuncs.com/img/202208072132673.png)\r\n\r\n### REPL(交互式解释器)\r\n\r\n执行以下任务：\r\n\r\n##### 读取-读取用户输入，解析输入的JavaScript数据结构并存储在内存中\r\n\r\n##### 执行-执行输入的数据结构\r\n\r\n##### 打印-输出结果\r\n\r\n##### 循环-循环操作以上步骤知道用户两次按下ctrl-c按钮退出\r\n\r\n单行操作：\r\n\r\n![image-20220801170601386](https://xiaomogui666.oss-cn-beijing.aliyuncs.com/img/202208072131199.png)\r\n\r\n多行操作：\r\n\r\n![image-20220801170918010](https://xiaomogui666.oss-cn-beijing.aliyuncs.com/img/202208072131277.png)\r\n\r\n### Moudles引用顺序\r\n\r\n\r\n\r\n![image-20220803220507270](https://xiaomogui666.oss-cn-beijing.aliyuncs.com/img/202208072131025.png)\r\n\r\n\r\n\r\n文件模块缓存区是指已经加载过的文件模块\r\n\r\n优先级：文件模块缓存 > 原生模块 > 文件模块\r\n\r\n### 处理GET请求和POST请求\r\n\r\nGET请求\r\n\r\n```javascript\r\n//获取GET请求内容\r\nlet http = require('http');\r\nlet url = require('url');\r\nlet util = require('util');\r\n\r\nhttp.createServer(function (req, res) {\r\n    res.writeHead(200, {\r\n        'Content-type': 'text-plain; charset=utf-8'\r\n    });\r\n\r\n    let params = url.parse(req.url, true).query;\r\n    res.write(\"name:\" + params.name + \"\\n\");\r\n    res.end(util.inspect(url.parse(req.url, true)));\r\n}).listen(3000);\r\n```\r\n\r\nPOST请求\r\n\r\n```javascript\r\n//处理 POST 请求\r\nlet http = require('http');\r\nlet querystring = require('querystring');\r\nlet util = require('util');\r\n\r\nlet postHTML =\r\n    '<html><head><meta charset=\"utf-8\"><title>菜鸟教程 Node.js 实例</title></head>' +\r\n    '<body>' +\r\n    '<form method=\"post\">' +\r\n    '网站名： <input name=\"name\"><br>' +\r\n    '网站 URL： <input name=\"url\"><br>' +\r\n    '<input type=\"submit\">' +\r\n    '</form>' +\r\n    '</body></html>';\r\n\r\nhttp.createServer(function (req, res) {\r\n    // 定义了一个post变量，用于暂时存储请求体的信息\r\n    let post = '';\r\n\r\n    //通过req的data事件监听函数，每当接受请求体的数据，就累加到post变量中\r\n    req.on('data', function (chunk) {\r\n        post += chunk;\r\n    });\r\n\r\n    //在end事件触发后，通过querystring.parse将post解析为POST请求格式，然后向客户端返回\r\n    req.on('end', function () {\r\n        post = querystring.parse(post);\r\n        res.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' })\r\n        if (post.name && post.url) { //输出提交的数据\r\n            res.write(\"网站名：\" + post.name);\r\n            res.write(\"<br>\");\r\n            res.write(\"网站URL：\" + post.url);\r\n        } else {  //输出表单\r\n            res.write(postHTML);\r\n        }\r\n        res.end();\r\n    });\r\n}).listen(3000);\r\n```\r\n",
        "timemini": ""
    },
    {
        "index": 4,
        "title": "Typescript学习笔记",
        "essay": "\r\n# typescript学习笔记\r\n\r\n笔记参考 [TypeScript入门教程](https://ts.xcatliu.com/introduction/get-typescript.html)\r\n\r\n\r\n\r\n## 简介\r\n\r\n### 关于TypeScript\r\n\r\nTypeScript是JavaScript的一个超集，主要提供类型系统和对ES6的支持。它的第一个版本发布于 2012 年 10 月，不仅在 Microsoft 内部得到广泛运用，而且 Google 开发的 [Angular](https://angular.io/) 从 2.0 开始就使用了 TypeScript 作为开发语言，[Vue](https://vuejs.org/) 3.0 也使用 TypeScript 进行了重构。\r\n\r\n\r\n\r\n### 什么是TypeScript\r\n\r\n#### ==1. TypeScript是静态类型==\r\n\r\n* TypeScript在运行前需要先编译为JavaScript,而在编译阶段就会进行类型检查。\r\n* JavaScript是解释性语言，没有编译阶段，所以是动态类型。\r\n\r\n一段完整的TypeScript代码如下：\r\n\r\n```typescript\r\nlet foo: number = 1;\r\nfoo.split(' ');  //Property 'split' does not exist on type 'number'.\r\n//编译时会报错\r\n```\r\n\r\n#### ==2. TypeScript是弱类型==\r\n\r\n类型系统按照是否允许隐式类型转换来分类，可以分为强类型和弱类型。\r\n\r\n以下这段代码不管是在 JavaScript 中还是在 TypeScript 中都是可以正常运行的，运行时数字 `1` 会被隐式类型转换为字符串 `'1'`，加号 `+` 被识别为字符串拼接，所以打印出结果是字符串 `'11'`。\r\n\r\n### 安装TypeScript\r\n\r\n全局安装\r\n\r\n```typescript\r\nnpm install -g typescript\r\n```\r\n\r\n编译一个TypeScript文件\r\n\r\n```typescript\r\ntsc hello.ts\r\n```\r\n\r\n## 基础\r\n\r\n### 1. 原始数据类型\r\n\r\nJavaScript 的类型分为两种：原始数据类型（[Primitive data types](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)）和对象类型（Object types）。\r\n\r\n原始数据类型包括：布尔值、数值、字符串、`null`、`undefined` 以及 ES6 中的新类型 [`Symbol`](http://es6.ruanyifeng.com/#docs/symbol) 和 ES10 中的新类型 [`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)。\r\n\r\n### 2. 任意值\r\n\r\n任意值（Any）用来表示允许赋值为任意类型。\r\n\r\n### 3. 类型推断\r\n\r\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\r\n\r\n以下代码虽然没有指定类型，但是会在编译的时候报错：\r\n\r\n```typescript\r\nlet myFavoriteNumber = 'seven';\r\nmyFavoriteNumber = 7;\r\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\r\n```\r\n\r\n等价于：\r\n\r\n```typescript\r\nlet myFavoriteNumber: string = 'seven';\r\nmyFavoriteNumber = 7;\r\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\r\n```\r\n\r\n### 4. 联合类型\r\n\r\n联合类型（Union Types）表示取值可以为多种类型中的一种。\r\n\r\n联合类型使用 `|` 分隔每个类型。\r\n\r\n```typescript\r\nlet myFavoriteNumber: string | number;\r\nmyFavoriteNumber = 'seven';\r\nmyFavoriteNumber = 7;\r\n```\r\n\r\n这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。\r\n\r\n当TypeScript不确定一个联合类型的变量到底哪个类型的时候，我们只能访问此联合类型的所有类型的所有类型里**共有的属性或方法**。\r\n\r\n### 5. 对象的类型——接口\r\n\r\n在TypeScript中，我们使用接口(Interfaces)来定义对象的类型。\r\n\r\nTypeScript中的接口是一个非常灵活的概念，除了可用于==对类的一部分行为进行抽象==以外，也常用语对【对象的形状(Shape)】进行描述。\r\n\r\n```typescript\r\ninterface Person {\r\n    name: string;\r\n    age: number;\r\n}\r\nlet tom: Person = {\r\n    name: 'Tom',\r\n    age: 25\r\n};\r\n```\r\n\r\n#### 可选属性\r\n\r\n有时我们希望不要完全匹配一个形状，那么可以用可选属性 ? ,可选属性的含义是该属性可以不存在。\r\n\r\n这时**仍然不允许添加未定义的属性**：\r\n\r\n```typescript\r\ninterface Person {\r\n    name: string;\r\n    age?: number;\r\n}\r\nlet tom: Person = {\r\n    name: 'Tom'\r\n};\r\n```\r\n\r\n#### 任意属性\r\n\r\n如果希望一个接口允许有任意的属性，可以使用如下方式：\r\n\r\n```typescript\r\ninterface Person {\r\n    name:string;\r\n    age?:number;\r\n    [propName: string]: any;\r\n}\r\nlet tom: Person = {\r\n    name: 'Tom',\r\n    gender: 'male'\r\n}\r\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\r\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\r\n//   Index signatures are incompatible.\r\n//     Type 'string | number' is not assignable to type 'string'.\r\n//       Type 'number' is not assignable to type 'string'.\r\n```\r\n\r\n需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集**：\r\n\r\n上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。\r\n\r\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\r\n\r\n```typescript\r\ninterface Person {\r\n    name: string;\r\n    age?: number;\r\n    [propName: string]: string | number;\r\n}\r\nlet tom: Person = {\r\n    name: 'Tom',\r\n    age: 25,\r\n    gender: 'male'\r\n};\r\n```\r\n\r\n#### 只读属性\r\n\r\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\r\n\r\n```typescript\r\ninterface Person {\r\n    readonly id: number;\r\n    name: string;\r\n    age?: number;\r\n    [propName: string]: any;\r\n}\r\nlet tom: Person = {\r\n    id: 89757,\r\n    name: 'Tom',\r\n    gender: 'male'\r\n};\r\ntom.id = 9527;\r\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\r\n```\r\n\r\n**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候**：\r\n\r\n### 6. 数组的类型\r\n\r\n在TypeScript中，数组类型有多种定义方式，比较灵活。\r\n\r\n#### 类型 + 方括号 表示法\r\n\r\n```typescript\r\nlet fibonacci: number[] = [1,2,3,4,5];\r\n```\r\n\r\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\r\n\r\n```typescript\r\nlet fibonacci: number[] = [1,2,3,4,5];\r\nfibonacci.push('8');\r\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\r\n```\r\n\r\n#### 数组泛型\r\n\r\n我们也可以使用数组泛型(Array Generic) 来表示数组：\r\n\r\n```typescript\r\nlet fibonacci: Array<number> = [1,2,3,4,5];\r\n```\r\n\r\n#### 用接口表示数组\r\n\r\n```typescript\r\ninterface NumberArray {\r\n    [index: number] : number;\r\n}\r\nlet fibonacci: NumberArray = [1,2,3,4,5];\r\n```\r\n\r\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\r\n\r\n不过有一种情况例外，那就是它常用来表示**类数组**。\r\n\r\n#### 类数组\r\n\r\n类数组（Array-like Object）不是数组类型，比如 `arguments`:\r\n\r\n```typescript\r\nfunction sum() {\r\n    let args: number[] = arguments;\r\n}\r\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\r\n```\r\n\r\n上例中，`arguments` 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\r\n\r\n```typescript\r\nfunction sum() {\r\n    let args: {\r\n        [index: number]: number;\r\n        length: number;\r\n        callee: Function;\r\n    } = arguments;\r\n}\r\n```\r\n\r\n事实上常用的类数组都有自己的接口定义，如 `IArguments`, `NodeList`, `HTMLCollection` 等：\r\n\r\n```typescript\r\nfunction sum() {\r\n    let args: IArguments = arguments;\r\n}\r\n```\r\n\r\n其中 `IArguments` 是 TypeScript 中定义好了的类型，它实际上就是：\r\n\r\n```typescript\r\ninterface IArguments {\r\n    [index: number]: any;\r\n    length: number;\r\n    callee: Function;\r\n}\r\n```\r\n\r\n#### any在数组中的应用\r\n\r\n一个比较常见的做法是用`any`表示数组中允许出现任意类型：\r\n\r\n```typescript\r\nlet list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];\r\n```\r\n\r\n### 7. 函数的类型\r\n\r\n#### 函数声明\r\n\r\n在JavaScript中，有两种常见的定义函数的方式——函数声明(Function Declaration) 和函数表达式（Function Expression).\r\n\r\n```typescript\r\n//函数声明\r\nfunction sum(x,y){\r\n    return x + y;\r\n}\r\n//函数表达式\r\nlet mySum = function(x,y) {\r\n    return x + y;\r\n}\r\n```\r\n\r\n在TypeScript中，需要把输入和输出都考虑到，函数声明的定义如下：\r\n\r\n```typescript\r\nfunction sum (x: number, y:number): number {\r\n    return x + y;\r\n}\r\n```\r\n\r\n#### 函数表达式\r\n\r\n如果要我们现在写一个对函数表达式的定义：\r\n\r\n```ts\r\nlet mySum = function (x: number, y: number): number {\r\n    return x + y;\r\n};\r\n```\r\n\r\n如果需要我们手动给 `mySum` 添加类型，则应该是这样：\r\n\r\n```ts\r\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\r\n    return x + y;\r\n};\r\n```\r\n\r\n#### 用接口定义函数的形状\r\n\r\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\r\n\r\n```ts\r\ninterface SearchFunc {\r\n    (source: string, subString: string): boolean;\r\n}\r\n\r\nlet mySearch: SearchFunc;\r\nmySearch = function(source: string, subString: string) {\r\n    return source.search(subString) !== -1;\r\n}\r\n```\r\n\r\n#### 可选参数\r\n\r\n前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\r\n\r\n与接口中的可选属性类似，我们用 `?` 表示可选的参数：\r\n\r\n```ts\r\nfunction buildName(firstName: string, lastName?: string) {\r\n    if (lastName) {\r\n        return firstName + ' ' + lastName;\r\n    } else {\r\n        return firstName;\r\n    }\r\n}\r\nlet tomcat = buildName('Tom', 'Cat');\r\nlet tom = buildName('Tom');\r\n```\r\n\r\n需要注意的是，可选参数必须接在必需参数后面。换句话说，**可选参数后面不允许再出现必需参数了**。\r\n\r\n#### 参数默认值\r\n\r\n在 ES6 中，我们允许给函数的参数添加默认值，**TypeScript 会将添加了默认值的参数识别为可选参数**：\r\n\r\n```ts\r\nfunction buildName(firstName: string, lastName: string = 'Cat') {\r\n    return firstName + ' ' + lastName;\r\n}\r\nlet tomcat = buildName('Tom', 'Cat');\r\nlet tom = buildName('Tom');\r\n```\r\n\r\n此时就不受「可选参数必须接在必需参数后面」的限制了。\r\n\r\n### 8. 类型断言\r\n\r\n类型断言（Type Assertion）可以用来手动指定一个值的类型。\r\n\r\n```ts\r\n值 as 类型\r\n```\r\n\r\n或者\r\n\r\n```ts\r\n<类型>值\r\n```\r\n\r\n#### 类型断言的用途\r\n\r\n##### 将一个联合类型断言为其中一个类型\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 5,
        "title": "Vue中全局事件总线",
        "essay": "# 全局事件总线\r\n\r\n​\t什么是全局事件总线：\r\n\r\n![image-20220511102446810](https://gitee.com/xiaomogui666/img/raw/master/202205111024012.png)\r\n\r\n​\t像如上的图片，通过建立一个中转站X并将所有的事件放在中转站中，这样将可以将各个组件连接起来，连成一个总线，因为该总线是关于事件的，全局的，所以称为全局事件总线。\r\n\r\n### \t建立全局事件总线\r\n\r\n##### \t\t1.由于所有的组件都要访问到X中转站，所以，我们可以在VC实例对象上创建中转站，也可以在Vue实例对象上创建中转站。\r\n\r\n​\t\t在VC实例对象上创建中转站：\r\n\r\n```javascript\r\n//通过VC实例对象创建全局中转站的步骤\r\nconst Demo = Vue.extend({});\r\nconst d = new Demo();\r\nVue.prototype.x = d;\r\n```\r\n\r\n​\t\t在Vue实例对象上创建中转站：\r\n\r\n```javascript\r\n//创建Vue实例对象\r\nnew Vue({\r\n    el: '#app',\r\n    render: h => h(App),\r\n    //这样做的好处是：\r\n    //  1.节省代码\r\n    //  2.创建方便\r\n    //但是一般不写成x，要写为$bus\r\n    beforeCreate() {\r\n        Vue.prototype.$bus = this;\r\n    }\r\n})\r\n```\r\n\r\n​\t\t这里，一般将中转站命名为$bus\r\n\r\n##### 2.在组件中将事件添加到中转站中\r\n\r\n```javascript\r\nmounted() {\r\n  console.log(\"School\", this);\r\n  this.$bus.$on(\"hello\", (data) => {\r\n     console.log(\"我是School组件，收到了数据\", data);\r\n  });\r\n},\r\n```\r\n\r\n​\t\t上面的代码在中转站$bus上添加一个自定义事件hello；\r\n\r\n##### 3.通过中转站，在组件中使用自定义事件\r\n\r\n```javascript\r\nmethods: {\r\n  sendStudentName() {\r\n    this.$bus.$emit(\"hello\", \"张三\");\r\n  },\r\n},\r\n```\r\n\r\n​\t\t通过点击事件等调用中转站$bus上的自定义事件\r\n\r\n### 全局事件总线的好处\r\n\r\n##### 1.可以进行父组件向子组件，子组件向父组件以及兄弟组件之间的信息传递，实现任意组件间通信\r\n\r\n### 注意\r\n\r\n​\t\t在组件销毁之前，我们要将该组件绑定在中转站中的事件解绑，以免引起不必要的错误，比如命名重复等等，代码如下：\r\n\r\n```javascript\r\nbeforeDestroy() {\r\n   //用完销毁\r\n   this.$bus.$off(\"hello\");\r\n},\r\n```\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 6,
        "title": "Vue中关于生命周期的总结",
        "essay": "# Vue生命周期全局\r\n\r\n首先附上图片\r\n\r\n![](https://gitee.com/xiaomogui666/img/raw/master/202204031222772.png)\r\n\r\n附上代码:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <script src=\"../js/vue.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"app\">\r\n        <div>\r\n            <h2>当前的n值是:{{n}}</h2>\r\n            <button @click=\"n++\">点我n+1</button>\r\n        </div>\r\n        <button @click=\"bye\">点我销毁vm</button>\r\n    </div>\r\n    <script>\r\n        var vm = new Vue({\r\n            el: '#app',\r\n            //将template中的内容替换到模板中，只能插入一个节点\r\n            //所以，要想插入多个标签，就只能将多个标签放到一个父盒子中\r\n            //另外，不能使用template标签作为组件\r\n            // template: `\r\n            //             <div>\r\n            //                 <h2>当前的n值是:{{n}}</h2>\r\n            //                 <button @click=\"n++\">点我n+1</button>\r\n            //             </div>\r\n            //         `,\r\n            data: {\r\n                n: 1\r\n            },\r\n            methods: {\r\n                //销毁vm后，Vue实例对象不在了，但是vm所造成的成果还在\r\n                bye() {\r\n                    console.log(\"bye\");\r\n                    //完全销毁一个实例，清理它与其他实例的连接，解绑它的全部指令及事件监听器\r\n                    //触发beforeDestroy和destroy的钩子\r\n                    //接触自定义事件，不是指click这一类的事件，因为这些事件都是原生DOM事件\r\n                    this.$destroy();\r\n                }\r\n            },\r\n            //在下列环节，不能够通过vm访问到data中的数据，methods中的方法\r\n            //初始化：生命周期、事件、但数据代理还未开始\r\n            beforeCreate() {\r\n                console.log(\"beforeCreate\");\r\n                //输出vm(this)没有_data这个对象\r\n                console.log(this);\r\n                //debugger;\r\n            },\r\n            //初始化：数据监测、数据代理\r\n            //在下列环节，可以通过vm反问道data中的数据，methods中的配置方法\r\n            created() {\r\n                console.log(\"created\");\r\n                //这时输出vm(this)就有了_data这个对象\r\n                console.log(this);\r\n                //debugger;\r\n            },\r\n            //此阶段Vue开始解析模板，生成虚拟DOM(内存中)\r\n            //页面还不能显示解析好的内容\r\n            //此时，页面呈现的是未经Vue编译的DOM结构\r\n            //所有对DOM的操作，最终都不奏效\r\n            //在这儿进行针对DOM的操作，会在后面被真实DOM所替换掉\r\n            beforeMount() {\r\n                console.log(\"beforeMount\");\r\n                //debugger;\r\n            },\r\n            //此时已经将内存中的虚拟DOM转为真实DOM插入页面\r\n            //从这开始，对DOM的操作均有效，至此初始化过程结束\r\n            //一般在此进行:开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作\r\n            mounted() {\r\n                console.log('mounted');\r\n                console.log(this);\r\n            },\r\n            //在更新之前调用，一更新，在更新之前就调用此函数\r\n            //数据是新的，但是页面是旧的\r\n            //面试会问\r\n            beforeUpdate() {\r\n                console.log(\"beforeUpdate\");\r\n                console.log(this.n);\r\n                // debugger;\r\n            },\r\n            //根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较最终就完成了页面更新\r\n            //由Model到View的更新\r\n\r\n            //此时的数据是新的，页面也是新的\r\n            //数据和页面保持一致\r\n            updated() {\r\n                console.log(\"updated\");\r\n                console.log(this.n);\r\n                // debugger;\r\n            },\r\n            //此时,vm中所有：data、methods、指令等,都处于可用状态，马上要执行销毁过程\r\n            //一般在此阶段：关闭定时器、取消订阅消息、结伴自定义事件等收尾操作\r\n            beforeDestroy() {\r\n                console.log(\"beforeDestroy\");\r\n                //这就可以表示在beforeDestroy这个阶段所有的data、methods、指令等都还是可用的\r\n                //但是在这里进行的所有流程都不会触发视图更新(也就是Vue模板的更新)\r\n                //数据还是可以进行修改\r\n                console.log(this.n);\r\n\r\n            },\r\n            //去掉vm实例中的所有的组件和事件监听器\r\n            //只有在Vue中才有，React中没有，React到上一步beforeDestroy就已经结束了\r\n            destroyed() {\r\n                console.log(\"destroyed\");\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n#### 好了，现在，开始总结：\r\n\r\n​\t首先，在一个生命周期中，总共有八个钩子，分别为beforeCreated、created、beforeMounted、mounted、beforeUpdate、updated、beforeDestroy、destroyed\r\n\r\n​\t这八个钩子分别对应**数据初始化前，数据已经初始化，解析模板前(生成虚拟DOM)，解析模板后(生成真实DOM)，更新之前(数据已更新，未发放到页面)，已经更新(数据放到页面)，Vue实例对象销毁之前，Vue实例对象销毁之后**\r\n\r\n​\t重要的钩子：mounted和beforeDestroy函数\r\n\r\n#### \tmounted：\r\n\r\n​\t\t主要操作:发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】\r\n\r\n#### \tbeforeDestroy：\r\n\r\n​\t\t清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】\r\n\r\n#### 关于销毁Vue实例：\r\n\r\n​\t1.销毁后借助Vue开发者工具看不到任何消息\r\n\r\n​\t2.销毁后自定义事件会失效，但原生DOM事件依然有效\r\n\r\n​\t3.一般不会在beforeDestroy操作数据，盈利为及时操作数据，也不会再出发更新数据了\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 7,
        "title": "Vue中的mixins属性",
        "essay": "# Vue中的mixins属性\r\n\r\n### 什么是mixins属性\r\n\r\n​\t首先，mixins翻译过来为混合的意思，主要是将Vue组件中的相同的代码整合到一个JavaScript文件中进行复用，大大提高了工作效率，可复用的Vue属性很多，包含一些常见的data、methods、mounted等等属性\r\n\r\n### 怎么使用mixins属性\r\n\r\n​\t1.创建mixins文件，并在文件中写一些需要复用的Vue属性，如下：\r\n\r\n```JavaScript\r\n//创建一个对象，用来写Vue的属性，并对其进行暴露\r\nexport const hunhe={\r\n\tmethods{\r\n\t\tshowName(){\r\n\t\t\talert(this.name);\r\n        }\r\n\t},\r\n    data(){\r\n\t\treturn {\r\n\t\t\tx:100,\r\n            y:200\r\n        }\r\n    },\r\n    mounted(){\r\n\t\tconsole.log(\"生命钩子666\");\r\n    }\r\n}\r\n```\r\n\r\n​\t2.局部mixins属性的使用，主要是在组件中进行使用，如下：\r\n\r\n```javascript\r\n<script>\r\n//引入文件，引入格式\r\n//import {mixin文件内对象名} from \"文件路径\"\r\nimport { hunhe } from \"../mixin.js\";\r\nexport default {\r\n  name: \"School\",\r\n  //如果data和methods中有同名的,则主要使用组件对象中的data和methods\r\n  data() {\r\n    return {\r\n      name: \"异类小魔鬼\",\r\n      age: 18,\r\n      x: 666,\r\n    };\r\n  },\r\n  //像生命周期这些钩子，如果与mixin中的重复\r\n  //都会执行，但是mixin内的钩子会在组件的钩子之前执行\r\n  mounted() {\r\n    console.log(\"生命钩子111\");\r\n  },\r\n  //文件中同样的东西，反复去使用\r\n  //mixins主要是复用，提高工作效率\r\n  mixins: [hunhe],\r\n};\r\n</script>\r\n```\r\n\r\n​\t3.全局mixins的使用，主要是在main.js中进行使用，如下：\r\n\r\n```javascript\r\nimport { hunhe } from 'mixin.js';\r\n//全局的混合\r\n//会给实例对象以及每个组件都加上mixin属性\r\nVue.mixin(hunhe);\r\n```\r\n\r\n### 关于mixins属性的一些注意事项\r\n\r\n​\t1.如果mixin文件中有和组件重名的属性\r\n\r\n​\t\t对于data和methods，使用组件中属性，而不使用mixin中的属性\r\n\r\n​\t\t对于生命钩子，组件中的钩子和mixin文件中的钩子都要使用，但是，无论书写顺序前后，先执行mixin内的生命钩子，再执行组件内的生命钩子\r\n\r\n​\t2.使用全局mixin，会给组件实例对象以及每个组件都加上mixins这一属性\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 8,
        "title": "Vue中的props属性",
        "essay": "# Vue中的props——向子组件传递数据\r\n\r\n### 什么是props\r\n\r\n​\tprop，翻译为属性，props则是属性的复数，props是Vue组件中的一个属性，可以用来动态传递和修改数据\r\n\r\n### props如何使用(三种用法,一般使用第一种)\r\n\r\n​\t1.数组型，只声明要进行传递的属性\r\n\r\n```VUE\r\nprops:[\"name\",\"sex\",\"age\"]\r\n```\r\n\r\n​\t2.对象型，声明要传递的属性以及限制传递值的类型\r\n\r\n```vue\r\nprops:{\r\n\tname:String,\r\n\tsex:String,\r\n\tage:Number\r\n}\r\n```\r\n\r\n​\t3.属性对象型，声明要传递的属性，限制传递值的类型，以及属性的必要性和属性的缺省值等等\r\n\r\n```javascript\r\nprops:{\r\n\tname:{\r\n\t\ttype:String,\r\n        require:true\t//属性必要性：true表示属性必须进行传递\r\n\t},\r\n    sex:{\r\n\t\ttype:String,\r\n        require:true,\r\n        default:'未知'\r\n    },\r\n    age:{\r\n\t\ttype:Number,\r\n        default:18\r\n    }\r\n}\r\n```\r\n\r\n### 使用props需要注意的事项：\r\n\r\n​\t1.需要用组件标签来传递属性，像这样：\r\n\r\n```vue\r\n<School name=\"异类小魔鬼\" sex=\"男\" age=\"18\"></School>\r\n```\r\n\r\n​\t2.使用v-bind去传输数字，不然会传成字符串，造成输出错误\r\n\r\n```vue\r\n<School name=\"异类小魔鬼\" sex=\"男\" :age=\"18\"></School>\r\n```\r\n\r\n​\t3.想要操作props传入属性的值，可以在data中创建一个新属性，将传入属性的值赋值给新属性，并用方法(methods)对其进行操作，如下\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    <h2>学生姓名：{{ name }}</h2>\r\n    <h2>学生性别：{{ sex }}</h2>\r\n    <h2>学生年龄：{{ myAge }}</h2>\r\n    <button @click=\"addNumber\">点我+1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \"Student\",\r\n  data() {\r\n    return {\r\n      //data内的值最终会被props覆盖掉\r\n      //   name: \"异类小魔鬼\",\r\n      //   sex: \"男\",\r\n      //   age: 18,\r\n      // 如果想要对props传进来的值进行操作，可以这样\r\n      myAge: this.age,\r\n      //然后利用方法对其进行操作\r\n    };\r\n  },\r\n  methods: {\r\n    addNumber() {\r\n      this.myAge++;\r\n    },\r\n  },\r\n  props: [\"name\", \"age\", \"sex\"],\r\n};\r\n</script>\r\n\r\n```\r\n\r\n​\t4.如果data中有与props中重名的属性，在页面上呈现时，**data中的属性会被props中的属性覆盖掉**\r\n\r\n​\t5.props内的属性尽量和组件标签传进来的属性一一对应，不多，也不少\r\n\r\n​\t6.**使用props不可使用关键字，比如ref，key等等已经被命名好的标签属性**",
        "timemini": ""
    },
    {
        "index": 9,
        "title": "Vue中的style使用scoped属性",
        "essay": "# Vue中的style使用scoped属性\r\n\r\n### 什么是style的scoped属性\r\n\r\n​\tscope，顾名思义，翻译过来就是范围、领域的意思，而style的scoped属性主要是用来约束style的使用范围，如果给style标签加上scoped属性，则会使style只能作用在当前组件中或者是当前Vue实例对象中\r\n\r\n### 为什么要使用style的scoped属性\r\n\r\n#### \t不使用scoped会有什么弊端\r\n\r\n​\t\t在平常，我们为我们的DOM元素写一些样式，但是**这些样式是应用在所有Vue组件以及实例对象中**的，如下，我分别在Vue的两个组件创建一个同名的class\r\n\r\n​\t\t第一个组件（Student）：\r\n\r\n```vue\r\n<template>\r\n  <div class=\"demo\">\r\n    <h2>学生姓名：{{ name }}</h2>\r\n    <h2>学生年龄：{{ age }}</h2>\r\n  </div>\r\n</template>\r\n<style>\r\n.demo {\r\n  background-color: orange;\r\n}\r\n</style>\r\n```\r\n\r\n​\t\t第二个组件（School）:\r\n\r\n```vue\r\n<template>\r\n  <div class=\"demo\">\r\n    <h2>学校名称：{{ name }}</h2>\r\n    <h2>学校地址：{{ address }}</h2>\r\n  </div>\r\n</template>\r\n<style>\r\n.demo {\r\n  background-color: skyblue;\r\n}\r\n</style>\r\n```\r\n\r\n​\t\t头组件(App.vue)：\r\n\r\n```vue\r\ntemplate>\r\n  <div>\r\n    <School></School>\r\n    <Student></Student>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n//引入School组件\r\nimport Student from \"./components/Student\";\r\nimport School from \"./components/School\";\r\nexport default {\r\n  name: \"App\",\r\n  components: {\r\n    Student,\r\n    School,\r\n  },\r\n  data() {\r\n    return {\r\n      msg: \"欢迎\",\r\n    };\r\n  },\r\n  methods: {\r\n    showDOM() {},\r\n  },\r\n};\r\n</script>\r\n```\r\n\r\n​\t\t那么，这样写的结果就为，两个组件的背景色都变为了天蓝色（skyblue）\r\n\r\n![image-20220418153801824](https://gitee.com/xiaomogui666/img/raw/master/202204181538945.png)\r\n\r\n​\t\t导致这种结果有两个原因：\r\n\r\n​\t\t\t1.两个组件内的demo样式都是应用于全局的，所以，当两个组件都要使用demo这个样式时，就会出现冲突，不知道是用School内的demo，还是用Student内的demo\r\n\r\n​\t\t\t2.为什么最终为天蓝色（skyblue）？因为在App.vue（头组件）中，School组件是在Student组件之后引用的，School组件内的demo覆盖掉了Student组件内的demo，因为两个demo都是全局的，就像在CSS中后者覆盖掉前者一样，如下：\r\n\r\n```css\r\n.demo{\r\n\tbackground-color:orange;\r\n}\r\n.demo{\r\n\tbackground-color:skyblue;\r\n    /*后者会把前者覆盖掉*/\r\n}\r\n```\r\n\r\n​\t\t到这里，我们已经知道了使用同名class的弊端\r\n\r\n#### \t使用scoped的好处\r\n\r\n​\t\tscoped可以将style标签内的class样式的作用域仅仅局限在本组件内，这样就可以避免同名class导致的样式错误\r\n\r\n### 注意\r\n\r\n​\t1.在App.vue（头组件）中style标签中一般不使用scoped属性，因为，如果我们在App.vue中style中写一个CSS样式，一般就是想让此样式作用于全局，所以不用scoped属性",
        "timemini": ""
    },
    {
        "index": 10,
        "title": "Vue中的组件自定义事件",
        "essay": "# Vue中的组件自定义事件\r\n\r\n### \t什么是Vue中的自定义事件：\r\n\r\n​\t\t我们经常会用一些v-on事件，比如说，常用一些简写的@click事件，有没有想过，写一些类似于click的事件，这里的自定义事件，就是指一些类似于click的事件，但是，这个自定义事件，主要是添加在子组件上的，用来从子组件向父组件传递数据，像这样（）：\r\n\r\n```html\r\n<School @xmg=\"getSchoolName\"></School>\r\n```\r\n\r\n​\t\t自定义一个\"xmg\"事件，getSchoolName这个方法是在methods中去写的，不像click事件，这些自定义事件需要在子组件中定义触发的事件。\r\n\r\n​\t\tOK，简介就到这，接下来进入正题，很多疑问会在本文主体中解决。\r\n\r\n### \tVue自定义事件的具体实现：\r\n\r\n#### \t\t\t1.在Vue父组件（这里用App组件代替）中自定义事件，并将自定义事件绑定给子组件（给VC组件绑定事件），此部分为两种方法：\r\n\r\n​\t\t\t**1.1 直接使用v-on或者@创建自定义事件：**\r\n\r\n ```html\r\n <School @xmg=\"getSchoolName\"></School\r\n ```\r\n\r\n​\t\t\t\t就像上面简介那样，直接自定义一个事件xmg，绑定给School组件，触发的方法为getSchoolName\r\n\r\n​\t\t\t**1.2 在生命周期钩子，通过ref属性来为子组件绑定事件**\r\n\r\n \t\t\t\t首先为子组件标签添加ref属性School\r\n\r\n ```html\r\n <School ref=\"School\"></School>\r\n ```\r\n\r\n​\t\t\t\t 接着为在生命周期钩子中，添加自定义事件，这里主要是通过Vue自带的$on去为子组件添加自定义事件\r\n ```javascript\r\n //基本格式this.$refs.School.$on('自定事件名称',触发自定义事件时调用的方法)\r\n mounted(){\r\n \tthis.$refs.School.$on('xmg',getSchoolName);\r\n }\r\n ```\r\n\r\n##### \t\t\t\t\t\t使用那种方法更好 ?\r\n\r\n​\t\t\t\t这里推荐使用第二种方法，因为第二种方法更具有操作性，可以设置时间函数回调，或者其他条件等等，像这样：\r\n\r\n ```javascript\r\n mounted(){\r\n    setTimeOut(()=>{\r\n         this.$refs.School.$on('xmg',getSchoolName);\r\n     },500);\r\n }\r\n ```\r\n\r\n#### \t\t\t2.在子组件中使用自定义事件\r\n\r\n##### \t\t\t\t\t这里子组件主要使用组件自带的$emit方法来调用自定义事件，基本格式如下：\r\n\r\n ```javascript\r\n this.$emit('自定义事件名称',要传递的参数：param1,param2...);\r\n ```\r\n\r\n​\t\t\t但是，想要触发以上的$emit方法，还需要事件，来触发此条代码的执行，像这样：\r\n\r\n​\t\t\t首先，在标签里添加一个点击事件\r\n\r\n ```html\r\n <button @click=\"setSchoolName\"></button>\r\n ```\r\n\r\n​\t\t\t接着，将写一个方法与点击事件绑定，用来触发this.$emit()的执行\r\n\r\n ```javascript\r\n methods:{\r\n \tsetSchoolName(){\r\n \t\tthis.$emit('xmg',this.name);\r\n \t}\r\n }\r\n ```\r\n\r\n​\t\t\t这样，就可以将子组件的数据传递到父组件中去\r\n\r\n​\t\t\t**可以在父组件中为子组件添加多个自定义事件**\r\n\r\n### \t子组件解绑自定义事件\r\n\r\n​\t\t解绑事件主要在子组件中，用的组件自带的$off方法\r\n\r\n​\t\t\t1.解绑一个自定义事件\r\n\r\n ```javascript\r\n this.$off(\"xmg\");\r\n ```\r\n\r\n​\t\t\t2.解绑多个自定义事件\r\n\r\n ```javascript\r\n this.$off([\"xmg1\",\"xmg2\"]);\r\n ```\r\n\r\n​\t\t\t3.解绑全部自定义事件\r\n\r\n ```javascript\r\n this.$off();\r\n ```\r\n\r\n\r\n\r\n###  注意事项：\r\n\r\n​\t1.1.1 如果我写一个@click表示什么：\r\n\r\n```html\r\n<School @click=\"getSchoolName\"></School>\r\n```\r\n\r\n​\t\t\t这表示**为子组件添加一个名为click的自定义事件**，和xmg自定义事件一样\r\n\r\n​\t\t\t如果我想要为子组件添加一个点击事件，怎么写？加一个native后缀\r\n\r\n```html\r\n<School @click.native=\"getSchoolName\"></School>\r\n```\r\n\r\n​\t\t\t这样就会为子组件最外层的标签添加一个点击事件\r\n\r\n​\t1.2.1 关于可不可以直接将方法写在$on中，像这样：\r\n ```javascript\r\n mounted(){\r\n \tthis.$refs.School.$on('xmg',function(name,...params){\r\n \t\tconsole.log(\"App收到了学校名：\",name,params);\r\n        \tthis.SchoolName=name;\r\n    \t});\r\n }\r\n ```\r\n 首先，可以将方法直接写在$on中，但是不可以这样写，要写成**箭头函数**，为什么呢？\r\n 因为this指代问题，function函数中的this指代的是子组件，而箭头函数的this指代的是父组件，这样就导致，当我们想要从子组件向父组件传递信息时，无法传递，所以要写为**箭头函数**\r\n\r\n​\t1.2.2 可以使用$once方法进行绑定，这样在子组件只能调用一次自定义事件：\r\n\r\n ```javascript\r\n mounted(){\r\n \tthis.$refs.School.$once('xmg',(name,...params)=>{\r\n         console.log(\"App收到了学校名：\",name,params);\r\n      \tthis.SchoolName=name;\r\n     });\r\n }\r\n ```\r\n\r\n##### \t\t\r\n\r\n##### \t最后，自定义事件会在组件摧毁时一并被销毁\t\t\t",
        "timemini": ""
    },
    {
        "index": 11,
        "title": "Vue生命周期",
        "essay": "##Chapter0 初识\r\n\r\n###MVVM(Model View ViewModel)\r\n\r\n###Vue的生命周期\r\n生命周期：事物从诞生到消亡的整个过程\r\n\r\n###ES6补充\r\n\r\n###列表展示v-for\r\n后面给数组追加元素时，新的元素也可以渲染出来\r\n\r\n\r\n##Chapter1 Vue基础语法\r\n###1.2插值操作\r\n\r\n#### Mustache语法\r\n不仅可以直接写变量，也可以写简单的表达式\r\n\r\n#### v-once指令\r\n只在第一次展示数据，当数据发生修改后展示的值不会相应修改\r\n\r\n#### v-html指令\r\n\r\n可以将内容转换为html内容输出\r\n\r\n\r\n#### v-text指令\r\n\r\n可以实现mustache的效果，但是会覆盖原来的文本\r\n\r\n\r\n#### v-pre指令\r\n使内容原封不动地展示出来而不做任何解析\r\n```html\r\n<h2>{{message}}</h2>\r\n<h2 v-pre>{{message}}</h2>\r\n```\r\n\r\n#### v-cloak\r\n在vue解析之前div中有一个v-cloak属性，\r\n直到vue解析，div中v-cloak属性会自动删除\r\n\r\n\r\n###1.3 v-bind\r\n- 实现动态绑定属性（基本属性：src,href等）\r\n- 语法糖：v-bind:value=\"\"  =>  :value=\"\"\r\n- 动态绑定class（对象语法{类名：boolean}，数组语法）\r\n- 动态绑定Style（对象语法{}，数组语法）\r\n\r\n\r\n###1.4计算属性computed\r\n获取各种属性，本质上就是一个属性而非函数，因此使用时不需要加括号\r\n####setter()和getter()\r\n计算属性其实是==一个对象==，对象中有setter()和getter()方法\r\n一般情况下没有setter()方法，此时计算属性是一个只读属性\r\ngetter()方法的返回值就是计算属性的属性值\r\n因此可以使用语法糖：\r\n```js\r\nfullName(){\r\n\treturn this.firstName + ' ' + lastName\r\n}\r\n```\r\n\r\n####计算属性和methods的对比\r\n计算属性在浏览器中具有缓存，每次浏览器页面发生改变时都会将计算属性与原来的值进行对比：若发生改变则重新调用函数，若未发生改变则无需重新调用函数\r\n==因此，计算属性在多次使用时只会调用一次==\r\n而methods方法每次都要重新调用整个函数\r\n\r\n###1.5事件监听\r\n语法糖：v-on:click=\"method\"  =>  @click=\"method\"\r\n在事件监听时，若函数没有参数需要传递则**可以省略括号**\r\n如果函数需要传入参数而事件监听时省略了小括号，则Vue会将浏览器产生的event对象作为参数传入\r\n方法定义时如果需要同时传入event和其他参数时，可以使用$event手动获取浏览器产生的event对象\r\n\r\n####修饰符\r\n1. .stop修饰符可以阻止事件的冒泡\r\n2. .prevent修饰符可以阻值默认事件的发生\r\n3. .监听键盘的某个键（如enter键）    @keyUp.enter=\"keyUp\"\r\n4. .once修饰符可以使事件监听的触发函数只触发一次\r\n5. .native\r\n\r\n###1.6条件判断\r\nv-if = \"Boolean\"\r\nv-else-if = \"Boolean\"\r\nv-else\r\n根据不同的条件选择不同页面的显示\r\n\r\nv-show = \"Boolean\"\r\nv-show 为false时，元素的display属性设置为none\r\n而v-if为false时，元素根本就不会存在在DOM中\r\n因此，当我们需要在显示与隐藏间反复多次进行切换时选用v-show，而如果只需要少次切换时则使用v-if\r\n\r\n###1.7循环遍历\r\n####遍历数组\r\n1. 仅遍历数组内的元素，而不遍历索引值\r\nv-for=\"value in arr\"\r\n2. 遍历元素和索引\r\nv-for=\"(value,index) in arr\"\r\n\r\n####遍历对象\r\n1. 仅遍历对象内的值\r\nv-for = \"value in obj\"\r\n2. 遍历键值对\r\nv-for = \"(value,key) in obj\"\r\n3. 遍历键值对和索引\r\nv-for = \"(value,key,index) in obj\"\r\n\r\n####数组中哪些方法是响应式的\r\n1. push()  向数组末端添加元素，可以一次添加多个元素\r\n2. pop()  删除数组末端元素\r\n3. shift()  删除数组的第一个元素\r\n4. unshift()  向数组最前面添加元素，也可以一次添加多个元素\r\n5. splice(a,b,c)  从第a个元素开始删除b个元素，在a之前添加元素c\r\n6. sort()  排序\r\n7. reverse()  反转\r\n\r\nVue.set(要修改的对象，索引值，修改后的值)(响应式)\r\nVue.set(this.arr,0,'bbb')\r\n\r\n==通过索引值改变元素（非响应式）==\r\n\r\n\r\n###1.8书籍购物车案例\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>书籍购物车</title>\r\n  <link rel=\"stylesheet\" href=\"./style.css\">\r\n</head>\r\n\r\n<body>\r\n  <div id=\"app\">\r\n    <div v-if=\"books.length\">\r\n      <table>\r\n        <thead>\r\n          <tr>\r\n            <th></th>\r\n                        <th>书籍名称</th>\r\n                        <th>出版日期</th>\r\n                        <th>价格</th>\r\n                        <th>购买数量</th>\r\n                        <th>操作</th>\r\n                    </tr>\r\n                </thead>\r\n                <tbody>\r\n                    <tr v-for=\"(item,index) in books\">\r\n                        <td>{{item.id}}</td>\r\n                        <td>{{item.name}}</td>\r\n                        <td>{{item.date}}</td>\r\n                        <td>{{item.price | showPrice}}</td>\r\n                        <td>\r\n                            <button @click=\"sub(index)\" v-bind:disabled=\"item.count <= 1\">-</button> {{item.count}}\r\n                            <button @click=\"add(index)\">+</button>\r\n                        </td>\r\n                        <td>\r\n                            <button @click=\"removeH(index)\">移除</button>\r\n                        </td>\r\n                    </tr>\r\n                </tbody>\r\n            </table>\r\n            <h2>总价格：{{totalPrice | showPrice}}</h2>\r\n        </div>\r\n        <h2 v-else>购物车为空</h2>\r\n    </div>\r\n    <script src=\"../js/vue.js\"></script>\r\n    <script src=\"./main.js\"></script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n```js\r\nconst app = new Vue({\r\n    el: '#app',\r\n    data: {\r\n        books: [\r\n            { id: 1, name: '《算法导论》', date: '2006-9', price: 85, count: 1 },\r\n            { id: 2, name: '《UNIX编程艺术》', date: '2006-2', price: 59, count: 1 },\r\n            { id: 3, name: '《编程珠玑》', date: '2008-10', price: 39, count: 1 },\r\n            { id: 4, name: '《代码大全》', date: '2006-3', price: 128, count: 1 },\r\n        ],\r\n\r\n    },\r\n    methods: {\r\n        getFinalPrice(price) {\r\n            return '￥' + price.toFixed(2)\r\n        },\r\n        add(index) {\r\n            this.books[index].count++\r\n        },\r\n        sub(index) {\r\n            this.books[index].count--\r\n        },\r\n        removeH(index) {\r\n            this.books.splice(index, 1)\r\n        }\r\n    },\r\n    filters: {\r\n        showPrice(price) {\r\n            return '￥' + price.toFixed(2)\r\n        }\r\n    },\r\n    computed: {\r\n        totalPrice() {\r\n            let totalPrice = 0\r\n            for (let i of this.books) {\r\n                totalPrice += i.price * i.count\r\n            }\r\n            return totalPrice\r\n        }\r\n    }\r\n})\r\n```\r\n\r\n```css\r\ntable {\r\n    border: 1px solid #e9e9e9;\r\n    border-collapse: collapse;\r\n    border-spacing: 0;\r\n}\r\n\r\nth,\r\ntd {\r\n    padding: 8px 16px;\r\n    border: 1px solid #e9e9e9;\r\n    text-align: center;\r\n}\r\n\r\nth {\r\n    background-color: #f7f7f7;\r\n    color: #5c6b77;\r\n    font-weight: 600;\r\n}\r\n```\r\n\r\n\r\n###1.9双向绑定\r\n####1.9.1基本使用与本质\r\nv-model\r\n```html\r\n<!-- 使用 v-model实现双向绑定 -->\r\n<input type=\"text\" v-model=\"message\">\r\n<!-- <input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"> -->\r\n```\r\n\r\n####1.9.2v-model和radio\r\n具有相同name属性的选项互斥，而给选项绑定相同的v-model也可以达到相同的效果\r\n通过给v-model设初值可以实现设置选项的默认值（在html中使用cheked属性），如不需设置默认值则将初值设为空字符串\r\n\r\n####1.9.3v-model和checkbox\r\n- 通过在input外添加label，并将label的for与input的id设置为相同，可实现点击文字也可触发点击选框的效果\r\n1. checkbox单选框\r\nv-model值为布尔值\r\n2. checkbox多选框\r\nv-model值为数组\r\n\r\n####1.9.4v-model和select\r\n1. 选择一个\r\nv-model值为字符串\r\n2. 选择多个\r\nv-model值为数组\r\n\r\n####1.9.5修饰符\r\n1. .lazy修饰符可以使数据不再实时绑定，而是在敲回车或失去焦点时才绑定\r\n2. .number修饰符可以使v-model的赋值类型为Number而非String\r\n//input中键入数字 type=\"number\"\r\n3. .trim修饰符可以将v-model的空格删除\r\n\r\n\r\n\r\n\r\n\r\n##Chapter2 组件化开发\r\n组件的使用分三个步骤：\r\n1. 创建组件构造器\r\n\r\n2. 注册组件\r\n\r\n3. 使用组件\r\n\r\n###2.1全局组件和局部组件\r\n\r\n###2.2父组件和子组件\r\n\r\n###2.3组件注册的语法糖\r\n\r\n###2.4模板的分离写法\r\n####script\r\n####template\r\n\r\n###2.5数据的存放\r\n- 子组件不能直接访问父组件的数据\r\n- 子组件有自己的data，且必须是一个函数\r\n- 为什么必须是一个函数？\r\n>组件之间相互影响\r\n\r\n###2.6父子组件的通信\r\n####父传子pros\r\n\r\n####子传父$emit\r\n\r\n###2.7项目\r\nnpm install\r\nnpm run serve\r\n\r\n###2.8父子组件的访问\r\n\r\n\r\n###2.9slot\r\n\r\n\r\n\r\n##3模块化\r\n###3.1为什么要使用模块化\r\n\r\n###3.2ES6中模块化的使用\r\n- export \r\n- import\r\n\r\n\r\n##Chapter4 Webpack\r\n###4.1什么是 webpack\r\n###4.2webpack起步\r\n###4.3webpack的loader\r\n###4.4webpack配置Vue\r\n###4.5webpack的plugin\r\n###4.6搭建本地服务器\r\n###4.7配置文件的分离\r\n\r\n   \r\n\r\n\r\n\r\n##Chapter5 Vue CLI详解\r\nCommand-Line Interface译为命令行界面，俗称脚手架\r\n###5.2 CLI2初始化项目的过程\r\n###5.3 CLI2生产的目录结构的解析\r\n\r\n##Chapter6 vue-router\r\n\r\n####:earth_asia:扩展笔记：\r\n1. 什么是前端渲染什么是后端渲染？\r\n>1. 后端渲染阶段：jsp(java server page)/php\r\n>在后端通过各种技术直接将页面渲染完成再返回给前端并直接展示\r\n>（一个页面有自己的网址，就是url）前端将url发送到服务器，服务器对url（通过正则）进行匹配，然后通过控制器处理，生成 HTML和css代码返回给前端\r\n>后端路由：后端处理url和页面之间关系的路由\r\n\r\n\r\n>2. 前后端分离阶段：随着Ajax出现，有了前后端分离的开发模式\r\n>  后端只提供API来返回数据，前端通过Ajax获取数据，并通过JS渲染页面\r\n>     当获取到url时，先去静态资源服务器中请求html+css+js代码，当执行js时发现api请求，再去服务器请求api相关资源，再根据这些资源对页面进行渲染\r\n>     前端渲染：浏览器中显示的大部分内容都由前端js代码在浏览器中执行，最终渲染出来的网页\r\n>\r\n> \r\n>\r\n\r\n\r\n>3. 单页面富应用阶段(SPA--Single Page web Application)：在前后端分离的基础上添加了前端路由\r\n>整个页面只有一个HTML页面，当url发生改变时整个页面不刷新，不再向服务器请求新的资源\r\n>前端路由：映射url->页面\r\n>\r\n\r\n2. 如何改变页面的url却不使页面发生刷新（不向服务器发送新的请求）\r\n>1. url的hash\r\n>直接修改hash\r\n>2. history方法\r\n>history.pushState({},'','home'),   history.back(),  history.replaceState({},'','home'),  history.go(-1),  history.forward()\r\n>\r\n\r\n3. 网址含义\r\n>:earth_asia: URL:协议//localhost:端口/路径？查询    Scheme//host:port/path?query#fragment\r\n\r\n###vue-router基于路由和组件\r\n\r\n####router-link\r\ntag=\"button\"  设置router-link的样式为按钮（默认为 a标签）\r\nto=\"/home\"  设置点击后url改变的值\r\n点击时按钮会增添一个router-link-active类\r\nclass的名字可以通过class-active属性修改\r\n\r\n####代码跳转路由\r\n####动态路由\r\n\r\n**this.$route.params.userId\r\n####路由的懒加载\r\n打包时打包三个文件\r\napp.js   自己写的代码\r\nmanifest.js   底层支撑的代码\r\nvendor.js  第三方代码\r\n\r\n==懒加载：用到时再加载==\r\n将不同路由由不同组件分割成不同的代码块，当路由被访问时才加载对应组件\r\n懒加载的方式：\r\n1. const Home = resolve =>{}...\r\n2. AMD写法\r\n\tconst About = resolve => require(['../components/About.vue'],resolve)\r\n3. ES6写法\r\n\tconst Home = () => import('../components/Home.vue')\r\n\t\r\n\t\r\n####嵌套路由\r\n实现嵌套路由的步骤：\r\n1. 创建对应的子组件，并且在路由映射中配置对应的子路由\r\n2. 在组件内部使用\\<router-view>标签\r\n\r\n\r\n####参数传递\r\n传递参数主要有两种类型: params和query\r\n#####    params的类型\r\n配置路由格式： /router/:id\r\n传递的方式： 在path后跟上对应的值\r\n传递后形成的路径： /router/123,/touter/abc\r\n\r\n#####    query的类型(传递对象)\r\n配置路由格式： /router,也就是普通配置\r\n传递的方式： 对象中使用query的key作为传递方式\r\n传递后形成的路径： /router?id=123,/router?id=abc\r\n\r\n####router和route\r\n任何一个组件里的this.\\$router就是router对象，是VueRouter的实例，具有push()等方法\r\nthis.\\$route是当前处于活跃的路由对象，具有参数params,query等\r\n\r\n####导航守卫\r\n监听导航栏的变化\r\n\r\n1. 全局守卫\r\n\r\n```js\r\n//设置导航(前置)守卫\r\nrouter.beforeEach((to, from, next) => {\r\n    //从from跳转到to时执行（跳转前执行）\r\n    document.title = to.matched[0].meta.title\r\n    next()\r\n})\r\n\r\n//设置导航(后置)守卫\r\nrouter.afterEach((to, from) => {\r\n    //从from跳转到to时执行（跳转后执行）\r\n    document.title = to.matched[0].meta.title\r\n    next()\r\n})\r\n```\r\n2. 路由独享守卫\r\n在路由配置时直接定义beforeEnter守卫\r\n进入之前（跳转之前之后，跳转之后之前）\r\n3. 组件内的守卫\r\n\r\n####keep-alive\r\nkeep-alive是Vue内置的一个组件，可以使被包含的组件保留状态或避免被重新渲染\r\nrouter-view也是一个组件，如果直接被包在keep-alive里面，所有路径匹配到的视图组件都会被缓存\r\n\r\n##Chapter7 Vuex详解\r\nVuex是一个专为Vue.js应用程序开发的状态管理模式\r\n- 把需要多个组件共享的变量全部存储在一个对象里\r\n- 然后将这个对象放在顶层的Vue实例里，让其他组件可以使用\r\n\r\n:earth_asia:哪些状态需要管理呢？\r\n- 用户的登录状态、用户名称、头像、地理位置信息等\r\n- 商品的收藏、购物车中的物品等\r\n- 响应式，需要共享的\r\n\r\n##Chapter8 网络封装axios\r\nVue中发送网络请求有非常多的方式\r\n1. 传统的Ajax是基于XHR (配置和调用方式非常混乱)\r\n2. jQuery-Ajax  (Vue中不需要jQuery，得不偿失)\r\n3. Vue-resourse (Vue2.x之后已不再维护)\r\n4. :star2:axios\r\n\r\n\r\n##Chapter9 项目实践\r\n1. 划分目录结构\r\nassets(资源)\r\n\t  imgs\r\n\t  css\r\ncommon(公共的常量和方法)\r\n\t  const.js\r\n\t  utils.js\r\ncomponents(公共的组件)：\r\n\t  common(其他项目里也会用到的组件)\r\n\t  content(仅在当前项目中会用到的公共组件)\r\nnetwork()\r\nrouter\r\nstore\r\nview(各个主要的视图)\r\n2. css文件的引入\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvue2中组件不能直接监听事件，需要添加.native\r\n\r\n```vue\r\n<back @click.native=\"backClick\"></back>\r\n```\r\n\r\nvue3中则可以直接监听\r\n\r\n\r\n\r\n\r\n\r\n不使用v-bind绑定的props会传递字符串，绑定之后则可以传递各种类型的数据\r\n\r\n\r\n\r\n事件总线$bus\r\n\r\n\r\n####防抖节流\r\n- **防抖debounce**\r\n```js\r\ndebounce(func, delay) {\r\n      let timer = null;\r\n      return function (...args) {\r\n        if (timer) clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n          func.apply(this, args);\r\n        }, delay);\r\n      };\r\n    }\r\n```\r\n- **节流throttle**\r\n\r\n####tab-control吸顶效果\r\n1. 必须直到滚动到多少时开始有吸顶效果（**获取到tab-control的offsetTop**）\r\n\t- 但不能直接在mounted中获取该值，在mounted中的值并没有将图片高度计算在内\r\n\t- 因此要监听HomeSwiper中img的加载完成\r\n\t- 加载完成后发出事件，并在Home.vue中获取正确的值\r\n\t- 为了不让HomeSwiper多次发出事件，可以使用一个isLoad变量记录状态\r\n2. 利用两个tabControl组件实现“假动画”\r\n\r\n\r\n####Home离开时状态记录\r\n1. keep-alive\r\n2. 让Home中内容保持\r\n\t- 离开时保存一个位置信息saveY\r\n\r\n\r\n####跳转至商品详情页\r\n1. 创建新组件，绑定路由并设置点击跳转事件\r\n2. this.iid = this.$route.params.iid\r\n3. 搭建详情页\r\n\r\n\r\n###搭建详情页\r\n\r\n####导入navbar\r\n- 导入DetailNavBar  DetailNavBar  中导入NavBar\r\n- 设置title与back\r\n\r\n####请求数据及轮播图展示\r\n\r\n2. Detail也keep-alive，要使用exclude将其剔除，则需要为组件设置name属性\r\n\r\n\r\n###混入mixin\r\n\r\n\r\n###toast弹窗\r\n\r\n##Chapter10 项目部署\r\n服务器：一台没有显示器的电脑，24小时开机为用户提供服务\r\n下载nginx 最新stable版本\r\n\r\n将自己的电脑作为服务器\r\n\r\n\r\n\r\n\r\n\r\ngit add .\r\n\r\ngit commit -m '初始化项目'\r\n\r\ngit push\r\n\r\n\r\n\r\n\r\n\r\n####面试题\r\n#####Vue响应式原理\r\n- 数据更新页面跟着更新其实不是理所当然的\r\n\r\n1. app.message修改数据，Vue内部是如何监听message数据改变的？\r\n>Object.defineProperty   -> 监听对象属性的改变\r\n\r\n2. 当数据发生改变，Vue是如何通知哪些人页面发生刷新？\r\n>发布订阅者模式\r\n\r\n\r\n\r\n\r\n\r\n## Chapter11 Element-UI\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 12,
        "title": "一些普遍的JavaScript问题",
        "essay": "\r\n## 1. 原始值和引用值类型及区别、内存图\r\n\r\n栈：原始数据类型（Undefined,Null,Boolean,Number,String,Symbol,BigInt）\r\n\r\n堆：引用数据类型（对象、数组、函数）\r\n\r\n原始数据：\r\n\r\n![image-20220721234037737](http://cdn.yangdw.cn/img/image-20220721234037737.png)\r\n\r\n引用数据：\r\n\r\n![image-20220721234156511](http://cdn.yangdw.cn/img/image-20220721234156511.png)\r\n\r\n区别：\r\n\r\n1. 声明变量时不同的内存分配\r\n    * 原始值：直接存储在栈(stack)中，因为占据空间固定，便于迅速查找\r\n    * 引用值：存储在堆(heap)中的对象，而存储在变量处的值是一个指针，这个变量存储在栈中，指向堆中的内存地址。因为引用值大小会改变，存储在栈中会降低查寻速度。\r\n2. 复制变量时的不同\r\n    * 原始值：将原始值的副本复制给新变量，之后这两个变量完全独立。\r\n    * 引用值：将保存着对象内存地址的变量复制给另一个变量，即两个变量指向同一个对象。\r\n3. 参数传递的不同\r\n    * ECMAScript中所有函数的参数都是按值传递的。\r\n    * 但是原始值把值传递给参数，之后参数和这个变量互不影响\r\n    * 引用值传递的是内存地址，也就是说函数内部对这个参数的修改会体现在外部。\r\n\r\n## 2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor\r\n\r\n### 1. `Object.prototype.toString.call()`方法，可以判断任何类型，返回的是一个字符串\r\n\r\n![image-20220722000521190](http://cdn.yangdw.cn/img/image-20220722000521190.png)\r\n\r\n如果想获取后面指定的部分String的话，可以使用字符串的slice方法。\r\n\r\n```js\r\nfunction myClass(target){\r\n    return Object.prototype.toString.call(target).slice(8,-1)\r\n}\r\n```\r\n\r\n### 2. `typeof()`方法,用来判断准确判断基本类型（除了null），返回字符串\r\n\r\ntypeof()在能够准确判断基本类型和function。但是判断null和引用类型（对象，数组，正则等）都会返回'object'\r\n\r\n因为数据存储在计算机内部时是转换为64位二进制数，引用类型的二进制的前三位为000，null转换为二进制时全为0。同时typeof()判断的原理是判断前三位二进制数，如果前三位为0，则认为是对象，再去查看是否实现了call()方法，如果实现了则返回'function'，没有实现则返回'object'\r\n\r\n所以**typeof不能准确判断引用类型**\r\n\r\n### 3. `instanceof()`方法，判断对象类型，返回布尔值\r\n\r\ninstanceof()的原理是通过判断对象的原型中是否能找到同类型的prototype。\r\n\r\n![image-20220722001543598](http://cdn.yangdw.cn/img/image-20220722001543598.png)\r\n\r\n原型链\r\n\r\n![image-20220722002422995](http://cdn.yangdw.cn/img/image-20220722002422995.png)\r\n\r\n模拟手写一个instanceof()\r\n\r\n```js\r\nfunction myinstanceof(left,right){\r\n    let prototype = right.prototype\r\n    let __proto__ = left.__proto__\r\n    while(true){\r\n        if(__proto__ === null){\r\n            return false\r\n        }\r\n        if(__proto__ === prototype){\r\n            return true\r\n        }\r\n        __proto__ = __proto__.__proto__\r\n    }\r\n}\r\n```\r\n\r\n### 4. constructor,判断对象，返回布尔值\r\n\r\n原理：每一个实例对象都可通过constructor来访问它的构造函数，其实也是根据原型链原理。\r\n\r\n```js\r\n'5'.__proto__.constructor === String // true\r\n[5].__proto__.constructor === Array // true\r\n```\r\n\r\n```js\r\nundefined.__proto__.constructor // Cannot read property '__proto__' of undefined\r\n\r\nnull.__proto__.constructor // Cannot read property '__proto__' of undefined\r\n```\r\n\r\n但是，由于undefined和null是无效对象，没有constructor属性，所以无法进行判断。\r\n\r\n## 3. 类数组和数组的区别和转化\r\n\r\n类数组：\r\n\r\n1. 能够用索引值访问当前元素，并且能知道当前数组的长度\r\n2. 不能使用数组的其他方法，诸如map，filter等，类数组一般在函数参数上使用较多，arguments就是一个类数组.\r\n\r\n对象的常用方法：\r\n\r\n```js\r\nobj = {a:1, b: \"1\",c: true,d: {} }\r\nfor ... in ...  ---数组的常用遍历方法\r\nhasOwnProperty  --- 返回一个布尔值，判断是否有该属性\r\ntoString        --- 判断数值变量的万能方法\r\ndefineProperty  --- Vue2实现数据双向绑定的核心算法\r\nvalueOf         --- 返回这个对象的原始值  //{a:1, b: \"1\",c: true,d: {} }\r\nfor ... of ...  --- 可以对具有迭代器的对象进行遍历，比如map,set,array等\r\nkeys, values    --- 分别返回由这个对象的属性和属性值组成的数组\r\n```\r\n\r\n数组的常用方法：\r\n\r\n```js\r\n常用的数组本身的操作方法\r\nshift           --- 从头部删除元素  返回值为删去的元素\r\nunshift         --- 从头部增加元素，没有返回值\r\npop             --- 从尾部删去元素，返回值为删除的元素\r\npush            --- 从尾部增加元素，没有返回值\r\nconcat          --- 将多个数组合并为一个数组，返回值为合并的数组\r\nsplice          --- 可传入多个参数，返回值为被改变的数组，\r\n\t\t\t\t\t第一个参数为删除元素的起始位置，后面没有参数的话就是全部删除\r\n                    第二个参数为删除元素的个数，如果超出删除的个数也是全部删除\r\n                    第三个参数是在删除的位置上加上要加的值\r\n                    [1,2].splice(0,1,2,2)  // [2,2,2]\r\nreverse         --- 将数组改变排列顺序\r\nsort            --- 将数组按照升序排列，可以通过传函数变为降序，[1,2,1].sort((a,b)=>b-a)\r\nslice           --- 将原来数组中的一部分进行切分出来并作为返回值返回，\r\njoin            --- 将数组的所有元素连接成一个字符串并返回这个字符串，默认使用逗号,分割。\r\n常用的数组遍历的方法\r\nfilter          --- 根据给出的回调函数遍历整个数组条件相符的元素 返回值为经过筛选后的数组\r\nforEach         --- 对整个数组进行进行遍历 返回值为undefined\r\nmap             --- 对整个数组根据回调函数进行遍历并返回经过调用的元素组成的数组\r\nevery,some      --- 对整个数组进行条件判断是否符合某个条件，every是对整个数组的元素比较，一个不符\t\t\t\t\t 合就是false , some是一个符合就全部符合 返回值是一个boolean值\r\nreduce          --- 对整个数组进行累计操作，需要至少一个累计值，一个当前值\r\nfind            --- 寻找整个数组是否含有某个值,有则返回索引,没有返回undefined\r\nvalueOf         --- 寻找整个数组是否含有某个值，有则返回索引，没有返回-1\r\n```\r\n\r\n### 类数组和数组的互相转化\r\n\r\nES6\r\n\r\n```js\r\n// 1.\r\nconst newArr = [...arguments]\r\n//2. \r\nArray.from()\r\n```\r\n\r\nES5\r\n\r\n```js\r\nfunction toArray(s){\r\n    var arr = []\r\n    try {\r\n        arr = Array.prototype.slice.call(s)\r\n    }catch{\r\n        for(var i = 0;i < s.length;i++){\r\n            arr.push(s[i])\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 4.  this, bind、call、apply的区别\r\n\r\n### 怎么改变this的指向\r\n\r\n1. 使用ES6的箭头函数\r\n2. 在函数内使用_this = this\r\n3. 使用apply,call,bind\r\n4. new 实例化一个对象\r\n\r\n**this永远指向最后调用的它的那个对象**\r\n\r\n`apply`: apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或类数组的对象）提供的参数\r\n\r\n```js\r\nvar a ={\r\n        name : \"Cherry\",\r\n        fn : function (a,b) {\r\n            console.log( a + b)\r\n        }\r\n    }\r\n\r\nvar b = a.fn;\r\nb.apply(a,[1,2]) // 3\r\nb.call(a,1,2) // 3\r\nb.bind(a,1,2)() //3\r\n```\r\n\r\n apply和call基本类型，只是传入的参数不同，apply传入的参数列表为数组。\r\n\r\nbind和apply,call区别，是创建一个新的函数，需要手动调用。\r\n\r\n## 5. new操作符的原理\r\n\r\n```js\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\nlet obj = new Person(\"Jalenl\");\r\n```\r\n\r\n对象实例的创建过程：\r\n\r\n1. 在内存中创建一个新对象\r\n2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性\r\n3. 构造函数内部的this被赋值为这个新对象(即this指向新对象)\r\n4. 执行构造函数内部的代码（给新对象添加属性）\r\n5. 如果构造函数返回对象，则返回该对象，否则，返回刚创建的新对象（空对象）\r\n\r\n```js\r\nfunction _new(constructor,...args){\r\n    // 1.创建新对象\r\n    let obj = {}\r\n    // 2.将构造函数的原型绑定到新创建的对象实例\r\n    obj.__proto__ = Object.create(constructor.prototype)\r\n    // 3.调用构造函数并判断返回值\r\n    let res = constructor.apply(obj,args)\r\n    // 如果有返回值且返回值是对象类型，那么就将它作为返回值，否则返回新创建的对象\r\n    return res instanceof Object ? res : obj\r\n}\r\n```\r\n\r\n## 6. 闭包及其作用\r\n\r\n### 定义\r\n\r\n闭包是指有权访问另一个函数作用域中的变量的函数。创建一个闭包最常见的方式，就是在一个函数内部创建另一个函数。\r\n\r\n### 作用\r\n\r\n1. 在函数外部能够访问到函数内部的变量，通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量。\r\n2. 让已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\r\n\r\n## 7. 原型和原型链\r\n\r\n### 原型\r\n\r\n在js中使用构造函数来新建一个对象的，每一个构造函数的内部都有一个prototype属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值。 ES5中新增了一个Object.getPrototypeOf()方法，可以通过这个方法获得对象的原型。\r\n\r\n### 原型链\r\n\r\n当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又有做自己的原型，就这样一直找下去，这就是原型链。原型链的尽头一般来说是Object.prototype。\r\n\r\n## 8. JS中的深浅拷贝\r\n\r\n浅拷贝：指的是将一个对象的属性值复制给另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的\t\t\t\t地址复制给对象，因此两个对象会有同一个引用类型的引用。\r\n\r\n浅拷贝可以使用Object.assign和展开运算符来实现。\r\n\r\n```js\r\n// 法1\r\nfunction shallowCopy(object){\r\n    if(!object || typeof object !== 'object') return\r\n    let newObject = Array.isArray(object)? []:{}\r\n    for(let key in object){\r\n        if(object.hasOwnProperty(key)){\r\n            newObject[key] = object[key]\r\n        }\r\n    }\r\n    return newObject\r\n}\r\n// 法2 \r\nlet newObject = Object.assign({},object)\r\n//法3 拓展运算符\r\nlet newObject = {...object}\r\n```\r\n\r\n深拷贝：创建一个新的对象把原始对象的所有属性拷贝一份，并且引用类型的引用地址和内存时间都会被拷贝一份，重新分配内存空间，修改新对象不会影响原始对象。\r\n\r\n```js\r\nfunction deepCopy(object){\r\n    if(!object || typeof object !== \"object\") return object\r\n    let newObject = Array.isArray(object) ? [] : {}\r\n    for(let key in object){\r\n        if(object.hasOwnProperty(key)){\r\n            newObject[key] = deepCopy(object[key])\r\n        }\r\n    }\r\n    return newObject\r\n}\r\n```\r\n\r\n## 9. 防抖和节流\r\n\r\n函数防抖：是指事件被触发后n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。这可以使用在一些\t\t\t\t\t点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\r\n\r\n```js\r\nfunctiohn debounce(fn,wait){\r\n    var timer = null;\r\n    return function(){\r\n        var context = this,\r\n        args = arguments\r\n        if(timer){\r\n            clearTimeout(timer)\r\n            timer = null\r\n        }\r\n        timer = setTimeout(()=>{\r\n            fn.apply(context,args)\r\n        },wait)\r\n    }\r\n}\r\n```\r\n\r\n函数节流：是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如有在同一个单位事件内某事件被触发多次，只有一次能生效。可以使用在scroll函数的事件监听，通过事件节流来降低事件调用的频率。\r\n\r\n```js\r\nfunction throttle(fn,delay){\r\n    var preTime = Date.now()\r\n    return function(){\r\n        var context = this,\r\n        \targs = arguments,\r\n        \tnowTime = Date.now();\r\n        if(nowTime - preTime >= delay){\r\n            preTime = Date.now()\r\n            return fn.apply(context,args)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 13,
        "title": "前端与HTML",
        "essay": "这是我参与「第四届青训营 」笔记创作活动的的第1天\r\n##### 本节课主要介绍HTML的相关知识\r\n# 一.什么是前端\r\n前端即网站前台部分，运行在pc端，移动端等浏览器上展现给用户浏览的网页。\r\n# 二.前端技术栈\r\n- HTML（内容） **HyperText Markup Language**\\\r\n超文本标记语言，HTML是一门描述性语言\r\n- CSS（样式）\\\r\n层叠样式表，是用来控制网页外观的一种技术\r\n- JavaScript（行为）\\\r\n是一种嵌入到HTML页面中的语言，由浏览器一边解释一边执行\\\r\n*HTML用来控制网页的结构，CSS用来控制网页的外观，JavaScript用来控制网页的行为*\r\n# 三.DOM树\r\n**Document Object Model** 文档对象模型\\\r\nDOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分\r\n![dom.svg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/197df3577a924200a1fba3a1b0531a6c~tplv-k3u1fbpfcp-watermark.image?)\r\n# 四.HTML语法\r\n- 标签和属性不区分大小写，推荐*小写*\r\n- 空标签可以不闭合，比如input、meta\r\n- 属性值推荐用*双引号*包裹\r\n- 某些属性值可以省略，比如required、rereadonly\r\n### HTML\r\n \\<h1> - \\<h6> 定义HTML标题\r\n### HTML链接\r\n 使用\\<a> - \\</a>来设置链接\\\r\n \\<a href=\"*url*\" target=\"_blank\">*链接文本*\\</a>\\\r\n href属性表示链接的目标，target定义被链接的文档在何处显示\r\n# 五.语义化是什么\r\nHTML语义化：用正确的标签做正确的事情\\\r\n**语义化例子：\\\r\narticle:定义文章\\\r\naside：定义文章的侧边栏\\\r\nfooter:定义页脚\\\r\nheader:定义页眉\\\r\nsection:定义文档中的区段\\\r\nnav:定义导航栏**\r\n### 语义化的好处：\r\n- 代码可读性高，便于理解\r\n- 可维护性强\r\n- 搜索引擎优化，利于SEO\r\n- 提升无障碍性\r\n# 总结\r\nHTML 是一种在 Web 上使用的通用标记语言，其关键是标签，标签具体的内容可以在很多网站上进行查询。\r\n##### 本文若有不足之处,欢迎纠正。",
        "timemini": ""
    },
    {
        "index": 14,
        "title": "前端与数据结构面试",
        "essay": "\r\n\r\n参考：掘金小册—[前端算法与数据结构面试：底层逻辑解读与大厂真题训练](https://juejin.cn/book/6844733800300150797)\r\n\r\n# 数组\r\n\r\n## 数组的创建 new Array()   fill\r\n\r\n```js\r\nconst arr = [1,2,3,4] //方式1\r\n```\r\n\r\n```js\r\nconst arr = new Array() //构造函数创建  一般方法\r\n//等同于 \r\nconst arr = []\r\n//指定长度\r\nconst arr = new Array(7)\r\n```\r\n\r\n`fill`方法 : 创建一个长度确定，每一个元素值也确定的数组\r\n\r\n```js\r\nconst arr = (new Array(7)).fill(1)\r\n```\r\n\r\n## 数组的访问和遍历\r\n\r\n访问数组元素，指定索引\r\n\r\n```js\r\narr[0]\r\n```\r\n\r\n遍历数组\r\n\r\n### 1. for循环\r\n\r\n```js\r\nconst len = arr.length\r\nfor(let i = 0; i < len; i++){\r\n    console.log(arr[i],i)\r\n}\r\n```\r\n\r\n### 2. forEach方法\r\n\r\n通过取`forEach`方法中传入函数的第一个入参和第二个入参，可以取到数组每个元素的值及其对应索引。\r\n\r\n```js\r\narr.forEach((item,index)=>{\r\n    console.log(item,index)\r\n})\r\n```\r\n\r\n### 3. Map方法\r\n\r\n`map`方法会根据传入的函数逻辑对数组中每个元素进行处理，进而返回一个全新的数组。\r\n\r\n当我们需要对数组内容做批量修改、同时修改的逻辑高度一致时，可以调用`map`。\r\n\r\n```js\r\nconst newArr = arr.map((item,index)=>{\r\n    console.log(item,index)\r\n    return item + 1\r\n})\r\n```\r\n\r\n## 二维数组\r\n\r\n```js\r\nconst arr = [\r\n  [1,2,3,4,5],\r\n  [1,2,3,4,5],\r\n  [1,2,3,4,5],\r\n  [1,2,3,4,5],\r\n  [1,2,3,4,5]\r\n]\r\n```\r\n\r\n### fill的局限性\r\n\r\n```js\r\nconst arr = (new Array(7)).fill([])\r\narr[0][0] = 1\r\n```\r\n\r\n当修改某一个数值时，会将整个一整列的元素都设为了1。\r\n\r\n当你给 fill 传递一个入参时，**如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用**。\r\n\r\n### 二维数组的初始化\r\n\r\n\r\n\r\n```js\r\nconst len = arr.length\r\nfor(let i = 0; i < len;i++){\r\n    arr[i] = []\r\n}\r\n```\r\n\r\n### 二维数组的访问\r\n\r\n访问二维数组和访问一维数组差别不大，需要的是两层循环。\r\n\r\n```js\r\n// 缓存外部数组的长度\r\nconst outerLen = arr.length\r\nfor(let i=0;i<outerLen;i++){\r\n    const innerLen = arr[i].length\r\n    for(let j = 0;j < innerLen;j++){\r\n        console.log(arr[i][j],i,j)\r\n    }\r\n}\r\n```\r\n\r\n## 数组中增加元素的三种方法\r\n\r\n### unshift方法 -添加元素到数组的头部\r\n\r\n```js\r\nconst arr = [1,2]\r\narr.unshift(0)\r\n```\r\n\r\n### push 方法 - 添加元素到数组的尾部\r\n\r\n```js\r\nconst arr = [1,2]\r\narr.push(3)\r\n```\r\n\r\n### splice 方法 - 添加元素到数组的任何位置 (3参数)\r\n\r\n```js\r\nconst arr = [1,2]\r\narr.splice(1,0,3)\r\n//在这个例子里，我们就指明了从 arr[1] 开始，删掉 0 个元素，并且在索引为1的地方新增了值为3的元素。\r\n```\r\n\r\n### splice 方法 （2参数 - 删除）\r\n\r\n第一个入参是起始的索引值，第二个入参表示从起始索引开始需要删除的元素个数。\r\n\r\n## 数组中删除元素的三种\r\n\r\n### shift 方法- 删除数组头部的元素\r\n\r\n```js\r\nconst arr = [1,2,3]\r\narr.shift() //[2,3,]\r\n```\r\n\r\n### pop 方法-删除数组尾部的元素\r\n\r\n```js\r\nconst arr = [1,2,3]\r\narr.pop() // [1,2]\r\n```\r\n\r\n### spilce 方法 - 如上\r\n\r\n## 栈（Stack） — 只用pop和push完成增删的“数组\"\r\n\r\n栈是一种后进先出(LIFO,Last In First Out)的数据结构。\r\n\r\n可以看做只能用`push`和`pop`方法的数组。\r\n\r\n## 队列 (Queue) - 只用push和shift完成增删的\"数组\"\r\n\r\n队列是一种先进先出（FIFO，First In First Out）的数据结构。\r\n\r\n整个过程只涉及了数组的 `push` 和 `shift` 方法。\r\n\r\n# 链表\r\n\r\n链表中的节点，允许散落在内存空间的各个角落里， 而内存是连续空间。\r\n\r\n![image-20220610212506175](http://cdn.yangdw.cn/img/image-20220610212506175.png)\r\n\r\n在链表中，每一个节点的结果都包括了两部分的内容：数据域和指针域。\r\n\r\n### 链表节点的创建\r\n\r\n```js\r\nfunction ListNode(val){\r\n    this.val  = val;\r\n    this.next = null;\r\n}\r\n```\r\n\r\n在使用构造函数创建结点时，传入 `val` （数据域对应的值内容）、指定 `next` （下一个链表结点）即可：\r\n\r\n```js\r\nconst node = new ListNode(1)\r\nnode.next = new ListNode(2)\r\n```\r\n\r\n就创建出了一个数据域值为1，next 节点数据域值为2的链表结点。\r\n\r\n![image-20220610220852348](http://cdn.yangdw.cn/img/image-20220610220852348.png)\r\n\r\n### 链表元素的添加\r\n\r\n1. 尾部添加\r\n\r\n    * 直接改变尾结点的next指向\r\n\r\n2. ==节点中部添加（重要）==\r\n\r\n    * 需要变更的是前驱节点和目标节点的next指针指向\r\n\r\n    * ![image-20220610221148633](http://cdn.yangdw.cn/img/image-20220610221148633.png)\r\n\r\n    * ```js\r\n        //如果目标节点不存在的话，需要手动创建\r\n        const node3 = new ListNode(3)\r\n        //把node3的next指针指向node2（即node1.next）\r\n        node3.next = node1.next\r\n        //把node1的next指针指向node3\r\n        node1.next = node3\r\n        ```\r\n\r\n### 链表元素的删除\r\n\r\n只需要让它的前驱节点node1的next指针跳过它，指向node3。\r\n\r\n![image-20220610221517655](http://cdn.yangdw.cn/img/image-20220610221517655.png)\r\n\r\n## \r\n\r\n```js\r\n// 利用 node1 可以定位到 node3\r\nconst target = node1.next  \r\nnode1.next = target.next\r\n```\r\n\r\n# 树结构\r\n\r\n![image-20220610223356961](http://cdn.yangdw.cn/img/image-20220610223356961.png)\r\n\r\n## 重点概念\r\n\r\n* 树的层次计算： 根节点所在的那一层为第一层，子节点为第二层\r\n* 节点和树的高度计算：叶子节点高度记为1，每向上一层高度就加1，树种节点的最大高度即为树的高度\r\n* \"度\"的概念：一个节点开叉出去多少个字树，被记为节点的“度”。上图中，根节点的“度\"为3\r\n* “叶子节点”：叶子节点就是度为0的节点\r\n\r\n## 二叉树\r\n\r\n二叉树是指满足一下要求的树：\r\n\r\n* 它可以没有根节点，作为一颗空树存在\r\n* 如果不是空树，必须由**根节点、左子树和右子树组成，且左右字树都是二叉树**\r\n\r\n![image-20220610224443047](http://cdn.yangdw.cn/img/image-20220610224443047.png)\r\n\r\n**二叉树不能被简单定义为每个结点的度都是2的树**。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。\r\n\r\n### 二叉树的编码实现\r\n\r\n在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：\r\n\r\n```js\r\n// 二叉树节点的构造函数\r\nfunction TreeNode(val){\r\n    this.val = val\r\n    this.left = this.right = null\r\n}\r\n```\r\n\r\n新建一个二叉树结点\r\n\r\n```js\r\nconst node = new TreeNode(1)\r\n```\r\n\r\n如此便能得到一个值为1的二叉树节点，从结构上看如下图：\r\n\r\n![image-20220611201802641](http://cdn.yangdw.cn/img/image-20220611201802641.png)\r\n\r\n### 二叉树的遍历\r\n\r\n按照顺序规则的不同，遍历方式有以下四种：\r\n\r\n* 先序遍历\r\n* 中序遍历\r\n* 后序遍历\r\n* 层次遍历\r\n\r\n按照实现方式的不同，遍历方式又可以分为以下两种：\r\n\r\n* 递归遍历（先、中、后序遍历）\r\n* 层次遍历\r\n\r\n遍历顺序：分别对应了二叉树的先序、中序、后序遍历规则。\r\n\r\n* 根节点 - > 左子树 - > 右子树\r\n* 左子树 - > 根节点 -> 右子树\r\n* 左子树 - > 右子树 - > 根节点\r\n\r\n先序遍历如下图所示：\r\n\r\n\r\n\r\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec42acc57e04~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\r\n\r\n上述二叉树结构编码：\r\n\r\n```js\r\nconst root = {\r\n    val: \"A\",\r\n    left:{\r\n        val:\"B\",\r\n        left:{\r\n            val:\"D\"\r\n        },\r\n        right:{\r\n            val:\"E\"\r\n        }\r\n    },\r\n    right:{\r\n        val:\"C\",\r\n        right:{\r\n            val:\"F\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 递归函数的编写要点\r\n\r\n* 递归式\r\n* 递归边界\r\n\r\n#### 第一个递归遍历函数\r\n\r\n先序遍历的编码实现：\r\n\r\n```js\r\n// 所有遍历函数的入参都是树的根节点对象\r\nfunction preorder(root){\r\n    //递归边界，root为空\r\n    if(!root){\r\n        return\r\n    }\r\n    //递归遍历左子树\r\n    preorder(root.left)\r\n    //递归遍历右子树\r\n    preorder(root.right)\r\n}\r\n```\r\n\r\n详细图解可参考小册第5节。",
        "timemini": ""
    },
    {
        "index": 15,
        "title": "如何写好js代码",
        "essay": "**这是我参与「第四届青训营 」笔记创作活动的的第4天**\r\n# 如何写好JS代码（下）\r\n## 当年的Leftpad事件\r\n```js\r\n function leftpad(str, len, ch) {\r\n      str = String(str);\r\n      var i = -1;\r\n      if (!ch && ch !== 0) ch = ' ';\r\n      len = len - str.length;\r\n      while (++i < len) {\r\n          str = ch + str;\r\n      }\r\n      return str;\r\n  } \r\n```\r\n||\r\n\r\nV\r\n### 事件本身的槽点：\r\n\r\n-   NPM 模块粒度\r\n-   代码风格\r\n-   代码质量/效率\r\n\r\n有 while 循环，所以它实际上它是一个时间复杂度O(n)的代码。\r\n\r\n我们要补CH 的时候，就 repeat, repeat 是一个加时功能内置函数。但我们补 repeat 的时候，其实它可以用二次幂的快速的方法去优化，不用线性的 while 循环去加。\r\n```js\r\nfunction leftpad(str, len, ch) {\r\n      str = \"\" + str;\r\n      const padLen = len - str.length;\r\n      if(padLen <= 0) {\r\n        return str;\r\n      }\r\n      return (\"\"+ch).repeat(padLen)+str;\r\n  } \r\n```\r\n||\r\n\r\nV\r\n-   代码更简洁\r\n-   效率提升\r\n\r\n二次幂算法：假如说我们要 repeat 一个count ，那个这个时候 N 就等于这个 count，然后我们会去把这个 N 转换成 2 定制数，从那个最末位开始，依次地去判断 N 的每一位的值。如果这个值是 1 的话，我把我就把这个 string 给加到这个 result 上面去。同时这个 N 如果这个时候还有值的话，那么我们就下一次再继续循环来跑的时候。因为我每次循环的时候是把这个 N 给那个就是右移一位的。这个时候每移一位的话，实际上就相当于在二进制里面往高位移动一位。那这个时候把这个 string 乘以 2 就翻倍，所以就把 string 加上 string ，那这样的话就是它是一个二次幂的一个快速幂的算法\r\n\r\n时间复杂度O(logn)\r\n\r\n\r\n\r\n```js\r\n /*! https://mths.be/repeat v1.0.0 by @mathias */\r\n\r\n  'use strict';\r\n\r\n  var RequireObjectCoercible = require('es-abstract/2019/RequireObjectCoercible');\r\n  var ToString = require('es-abstract/2019/ToString');\r\n  var ToInteger = require('es-abstract/2019/ToInteger');\r\n\r\n  module.exports = function repeat(count) {\r\n    var O = RequireObjectCoercible(this);\r\n    var string = ToString(O);\r\n    var n = ToInteger(count);\r\n    // Account for out-of-bounds indices\r\n    if (n < 0 || n == Infinity) {\r\n      throw RangeError('String.prototype.repeat argument must be greater than or equal to 0 and not be Infinity');\r\n    }\r\n\r\n    var result = '';\r\n    while (n) {\r\n      if (n % 2 == 1) {\r\n        result += string;\r\n      }\r\n      if (n > 1) {\r\n        string += string;\r\n      }\r\n      n >>= 1;\r\n    }\r\n    return result;\r\n  };\r\n```\r\n-   [性能更好](https://github.com/mathiasbynens/String.prototype.repeat/blob/master/implementation.js)\r\n```js\r\n /**\r\n   * String.prototype.repeat() polyfill\r\n   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill\r\n  */\r\n  if (!String.prototype.repeat) {\r\n    String.prototype.repeat = function(count) {\r\n      'use strict';\r\n      if (this == null)\r\n        throw new TypeError('can't convert ' + this + ' to object');\r\n\r\n      var str = '' + this;\r\n      // To convert string to integer.\r\n      count = +count;\r\n      // Check NaN\r\n      if (count != count)\r\n        count = 0;\r\n\r\n      if (count < 0)\r\n        throw new RangeError('repeat count must be non-negative');\r\n\r\n      if (count == Infinity)\r\n        throw new RangeError('repeat count must be less than infinity');\r\n\r\n      count = Math.floor(count);\r\n      if (str.length == 0 || count == 0)\r\n        return '';\r\n\r\n      // Ensuring count is a 31-bit integer allows us to heavily optimize the\r\n      // main part. But anyway, most current (August 2014) browsers can't handle\r\n      // strings 1 << 28 chars or longer, so:\r\n      if (str.length * count >= 1 << 28)\r\n        throw new RangeError('repeat count must not overflow maximum string size');\r\n\r\n      var maxCount = str.length * count;\r\n      count = Math.floor(Math.log(count) / Math.log(2));\r\n      while (count) {\r\n        str += str;\r\n        count--;\r\n      }\r\n      str += str.substring(0, maxCount - str.length);\r\n      return str;\r\n    }\r\n  }\r\n```\r\n\r\n## 交通灯状态切换\r\n### 异步+函数式\r\n```html\r\n<ul id=\"traffic\" class=\"wait\">\r\n  <li></li>\r\n  <li></li>\r\n  <li></li>\r\n</ul>\r\n```\r\n```css\r\n#traffic {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n#traffic li{\r\n  display: inline-block;\r\n  width: 50px;\r\n  height: 50px;\r\n  background-color: gray;\r\n  margin: 5px;\r\n  border-radius: 50%;\r\n}\r\n\r\n#traffic.stop li:nth-child(1) {\r\n  background-color: #a00;\r\n}\r\n\r\n#traffic.wait li:nth-child(2) {\r\n  background-color: #aa0;\r\n}\r\n\r\n#traffic.pass li:nth-child(3) {\r\n  background-color: #0a0;\r\n}\r\n```\r\n```js\r\nconst traffic = document.getElementById('traffic');\r\n\r\nfunction wait(time){\r\n  return new Promise(resolve => setTimeout(resolve, time));\r\n}\r\n\r\nfunction setState(state){\r\n  traffic.className = state;\r\n}\r\n\r\nasync function start(){\r\n  //noprotect\r\n  while(1){\r\n    setState('wait');\r\n    await wait(1000);\r\n    setState('stop');\r\n    await wait(3000);\r\n    setState('pass');\r\n    await wait(3000);\r\n  }\r\n}\r\n\r\nstart();\r\n```\r\n\r\n## 判断是否是4的幂\r\n```html\r\n<input id=\"num\" value=\"65536\"></input>\r\n<button id=\"checkBtn\">判断</check>\r\n```\r\n```css\r\n#num {\r\n  color: black;\r\n}\r\n\r\n#num.yes {\r\n  color: green;\r\n}\r\n\r\n#num.no {\r\n  color: red;\r\n}\r\n```\r\n```js\r\n//   while(num > 1) {\r\n//     if(num & 0b11) return false;\r\n//     num >>>=2;\r\n//   }\r\n//   return num === 1;\r\n// }\r\n\r\n// function isPowerOfFour(num) {\r\n//   num = parseInt(num).toString(2);\r\n  \r\n//   return /^1(?:00)*$/.test(num);\r\n// }\r\n\r\nfunction isPowerOfFour(num){\r\n  num = parseInt(num);\r\n  \r\n  return num > 0 &&\r\n         (num & (num - 1)) === 0 &&\r\n         (num & 0xAAAAAAAAAAAAA) === 0;\r\n}\r\n\r\nnum.addEventListener('input', function(){\r\n  num.className = '';\r\n});\r\n\r\ncheckBtn.addEventListener('click', function(){\r\n  let value = num.value;\r\n  num.className = isPowerOfFour(value) ? 'yes' : 'no';\r\n});\r\n```\r\n\r\n## 洗牌-错误写法\r\n```html\r\n<div id=\"app\">洗牌-错误写法</div>\r\n<hr/>\r\n<div id=\"log\"></div>\r\n<script>\r\n  window.console = JCode.logger(log);\r\n</script>\r\n```\r\n```js\r\nconst cards = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n\r\nfunction shuffle(cards) {\r\n  return [...cards].sort(() => Math.random() > 0.5 ? -1 : 1);\r\n}\r\n\r\nconsole.log(shuffle(cards));\r\n\r\nconst result = Array(10).fill(0);\r\n\r\nfor(let i = 0; i < 1000000; i++) {\r\n  const c = shuffle(cards);\r\n  for(let j = 0; j < 10; j++) {\r\n    result[j] += c[j];\r\n  }\r\n}\r\n\r\nconsole.table(result);\r\n```\r\n现在我们发现了一个很有意思的现象，就是我们的 index 越靠前，得到的总的数值就越小。也就是说它意味着什么呢？就意味着越小的这些数值，它的排布越靠前的几率越大。所以我们会看到 0 的时候只有 38 万多只有 380 多万。然后在 9 的时候，实际上有五百多万，就是这个值的分布是这样的，我们越小的序号出现在越前面的概率是越大的。所以就是这个是一个分布不均匀的算法。\r\n\r\n那为什么分布不均匀呢？是因为我们用的是 sort 方法的随机交换。但我们知道 sort 方法它不是两位置都均匀的交换的，在每个位置他交换的次数是不一样的，所以他的越靠前的位置换到最后的概率是越低的。\r\n\r\n\r\n## 洗牌-正确写法\r\n\r\n###### O(n) 时间复杂度的算法:\r\n\r\n我们可以遍历每一张牌。这么做:一开始的时候，我们从这里总的这个牌里面抽一张出来，随机抽一张出来，把它换到最后面的位置去，换到那个位置以后它就不动了。接下来我们再从剩下这 9 张牌里面随机地抽一张牌出来，再把它塞到最后的位置去。然后我们从剩下的八张牌里头再随机取张牌，再把它塞到最后的位置去，就相当于是一张牌随机的抽出来，抽出来以后就把它放在那里。这样是可以确保说那个每张牌被抽到任何一个位置的概率都均等。\r\n\r\n就这个问题，也可以通过数学归纳法证明:  假设我们现在只有两张牌，就是 A 和 B 。这个时候我们抽牌的时候，A 有 50% 的概率被抽到和 B 交换。交换后的结果就是最后就得到BA 。还有 50% 概率是直接抽到 B ，直接抽到 B 的话它也是跟 B 自己交换。所以剩下的 50% 的概率就是 AB ，所以概率是均等的。\r\n\r\n```html\r\n<div id=\"app\">洗牌-正确写法</div>\r\n<hr/>\r\n<div id=\"log\"></div>\r\n<script>\r\n  window.console = JCode.logger(log);\r\n</script>\r\n```\r\n```js\r\nconst cards = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n\r\nfunction shuffle(cards) {\r\n  const c = [...cards];\r\n  for(let i = c.length; i > 0; i--) {\r\n    const pIdx = Math.floor(Math.random() * i);\r\n    [c[pIdx], c[i - 1]] = [c[i - 1], c[pIdx]];\r\n  }\r\n  return c;\r\n}\r\n\r\nconsole.log(shuffle(cards));\r\n\r\nconst result = Array(10).fill(0);\r\n\r\nfor(let i = 0; i < 10000; i++) {\r\n  const c = shuffle(cards);\r\n  for(let j = 0; j < 10; j++) {\r\n    result[j] += c[j];\r\n  }\r\n}\r\n\r\nconsole.table(result);\r\n```\r\n## 洗牌-使用生成器\r\n\r\n\r\n但是有的时候比如说我们要抽奖，在 100 个人里面，抽出 10 个中奖的，那就没有必要把这 100 张牌全部都洗完，只需要从这 100 张牌里抽出 10 张牌来就可以了。在这种情况下，就是在 javascript 里面，我们可以把刚才的那个版本的代码给改成一个生成器，区别是我们之前是把 for 循环跑完了，然后把整个牌给返回。但现在我们不这么做，不跑完这个 for 循环，我们直接取了一张牌，就直接把这张牌给 add 出来。那么这样我们也一样是能够洗牌的。把牌洗了以后，直接用 sprint 操作符把它展开，这就相当于把这个牌给洗完了。\r\n```html\r\n<div id=\"app\">洗牌-生成器</div>\r\n<hr/>\r\n<div id=\"log\"></div>\r\n<script>\r\n  window.console = JCode.logger(log);\r\n</script>\r\n```\r\n```js\r\nconst cards = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n\r\nfunction * draw(cards){\r\n    const c = [...cards];\r\n\r\n  for(let i = c.length; i > 0; i--) {\r\n    const pIdx = Math.floor(Math.random() * i);\r\n    [c[pIdx], c[i - 1]] = [c[i - 1], c[pIdx]];\r\n    yield c[i - 1];\r\n  }\r\n}\r\n\r\nconst result = draw(cards);\r\nconsole.log([...result]);\r\n```\r\n\r\n## 分红包-[切西瓜法](https://code.juejin.cn/pen/7108203981549076511)\r\n切西瓜法\r\n\r\n首先随机切一刀，切下一刀以后，它切成了两半不一样大的，就是一半小一半大。接下来我们切大的那一半，切完以后把大的那半再切一刀，切成两半以后，我们就一共有三块西瓜了，然后我们再去切这三块西瓜当中最大的那块。也就是说我们每次切的时候都去切最大的块。\r\n\r\n对应的我们分红包时候也是一样的。先把红包的总的金额给随机的拆成两部分。拆成两部分之后我们再去拆，继续拆的时候就去取大的那部分再往下拆，这样就不会有分到不够分的情况了。\r\n\r\n## 分红包-[抽牌法](https://code.juejin.cn/pen/7108204495883993118)\r\n\r\n比如100 块钱的红包，也就是 1 万分，我们把它看成是一个数列，就是一个从 0 到 99 的数列。在这个数列里面，随机的插入就是一个范围，比如说一直到 99 的一个数列，在这个数列里面，插入 9 个分隔符。比如第一个分隔符在49，这个时候我就把四毛九的钱给他。然后比如说另外一个分隔符在199。那就把一块九毛九减去四毛九，然后把剩下的一块 5 再分给另外一个人。然后往序列里面随机的插入。\r\n\r\n<hr/>\r\n\r\n# 前端设计模式应用\r\n\r\n## 软件设计中常见问题的解决方案模型\r\n- 历史经验的总结\r\n- 与特定语言无关\r\n\r\n## 设计模式背景\r\n1.模式语言：城镇、建筑、建造\r\n2.设计模式：可复用面向对象软件的基础\r\n### 23种设计模式\r\n- 创建型：如何创建一个对象\r\n- 结构型：如何灵活的将对象组装成较大的结构\r\n- 行为型：负责对象间的高校通信和职责划分\r\n## 浏览器中的设计模式\r\n### 单例模式\r\n#### 定义\r\n全局唯一访问对象\r\n#### 应用场景\r\n缓存，全局状态管理等\r\n\r\n### 发布订阅模式\r\n#### 定义\r\n一种订阅机制，可在被订阅对象发生变化时通知订阅者\r\n#### 应用场景\r\n从系统架构之间的解耦，到业务中一些实现模式，像邮件订阅、上线订阅等，应用广泛。\r\n\r\n## JS中的设计模式\r\n### 原型模式\r\n#### 定义\r\n复制已有对象来创建新的对象\r\n#### 应用场景\r\nJS中对象创建的基本模式\r\n\r\n### 代理模式\r\n#### 定义\r\n可自定义控制对原对象的访问方式，并且允许在更新前后做一些额外处理\r\n#### 应用场景\r\n监控、代理工具，前端框架实现等等\r\n\r\n### 迭代器模式\r\n#### 定义\r\n在不保留数据类型的情况下访问集合中的数据\r\n#### 应用场景\r\n数据结构中有多种数据类型，列表、树等，提供通用操作接口。\r\n\r\n## 前端框架中的设计模式\r\n- 代理模式\r\n- 组合模式\r\n\r\n### Vue组件实现定时器\r\n### 前端框架中对DOM操作的代理\r\n\r\n- 更改DOM属性->视图更新\r\n- 更改DOM属性->更改虚拟DOM-Diff->视图更新\r\n\r\n### 组合模式\r\n#### 定义\r\n可多个对象组合使用，也可单个对象独立使用\r\n#### 应用场景\r\nDOM、前端组件、文件目录、部门\r\n\r\n## 练习题：使用组件模式实现一个文件夹结构\r\n- 为个文件夹可以包含文件和文件夹\r\n- 文件有大小\r\n- 可以获取每个文件夹下文件的整体大小\r\n",
        "timemini": ""
    },
    {
        "index": 16,
        "title": "字节青训营笔记",
        "essay": "### 01 前端与HTML\r\n\r\nHTML是什么？\r\n\r\n> HyperText Markup Language 超文本标记语言\r\n\r\n如\r\n\r\n```html\r\n<h1>一级标题</h1>\r\n<img src = \"photo.jpg\">\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <h1>一级标题</h1>\r\n    <p>段落内容</p>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n浏览器拿到HTML代码后会将其解析为一个DOM树\r\n\r\n其中每一个节点称为DOM节点\r\n\r\n![image-20220725161408710](C:\\D\\PCR\\Notes\\Pictures\\image-20220725161408710.png)\r\n\r\n\r\n\r\n#### HTML语法\r\n\r\n- 标签和属性不区分大小写，推荐小写\r\n- 空标签可以不闭合，如input、meta\r\n- 属性值推荐用双引号包裹\r\n- 某些属性值可以省略，如required、readonly\r\n\r\n\r\n\r\n#### HTML标签\r\n\r\n##### 1.标题\r\n\r\nh1~h6 六级标签\r\n\r\n\r\n\r\n##### 2.列表标签\r\n\r\n###### 1）有序列表\r\n\r\n```html\r\n<ol>\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n</ol>\r\n```\r\n\r\n###### 2) 无序列表\r\n\r\n```html\r\n<ul>\r\n    <li>1</li>\r\n    <li>1</li>\r\n    <li>1</li>\r\n</ul>\r\n```\r\n\r\n###### 3) 定义列表\r\n\r\n使用dl标签来创建一个定义列表\r\n\r\n使用dt来表示定义的内容\r\n\r\n使用dd来对内容进行解释说明\r\n\r\ndt和dd可以一对一也可以一对多或多对一、多对多\r\n\r\n```html\r\n<dl>\r\n    <dt>导演：</dt>\r\n    <dd>陈凯歌</dd>\r\n    <dt>主演：</dt>\r\n    <dd>张国荣</dd>\r\n    <dd>张丰毅</dd>\r\n</dl>\r\n```\r\n\r\n\r\n\r\n##### 3.超链接\r\n\r\n链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置\r\n\r\n```html\r\n<a href=\"https://bilibili.com\"\r\n   target=\"_blank\">B站\r\n</a>\r\n```\r\n\r\n使用 a 标签来定义超链接\r\n\r\n属性：\r\n\r\n- href 指定跳转的目标路径,值可以是一个外部网站的地址，也可以写一个内部页面的地址\r\n\r\n- target用来指定超链接打开的位置\r\n\r\n  可选值：\r\n\r\n  - _self 默认值 在当前页面中打开超链接\r\n\r\n  - _blank 在一个新的页面中打开超链接\r\n\r\n\r\n\r\n超链接是一个行内元素，在a标签中可以嵌套除它自身外的任何元素。\r\n\r\n可以直接将超链接的href属性设置为#，这样点击超链接以后页面不会发生跳转，而是转到当前页面的顶部的位置。\r\n\r\n在开发中可以将#作为超链接的路径的展位符使用。\r\n\r\n可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生。\r\n\r\n可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值。\r\n\r\n\r\n\r\n##### 4.图片标签\r\n\r\n```html\r\n<img><img src=\"./img/1.gif\" alt=\"松鼠\" width=\"200\">\r\n```\r\n\r\n属性：\r\n\r\n- src 属性指定的是外部图片的路径（路径规则和超链接是一样的）\r\n\r\n- alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示\r\n\r\n  搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录\r\n\r\n- width 图片的宽度 (单位是像素)、height 图片的高度\r\n\r\n  宽度和高度中如果只修改了一个，则另一个会等比例缩放\r\n\r\n\r\n\r\n### 02 CSS\r\n\r\n\r\n\r\n### 03 JavaScript\r\n\r\n\r\n\r\n### 04 前端设计模式应用\r\n\r\n#### 前端设计模式\r\n\r\n- 单例模式\r\n  - 定义：全局唯一访问对象\r\n  - 应用场景：缓存，全局状态管理。\r\n\r\n首次创建新request，之后使用原来的request\r\n\r\n\r\n\r\n- 发布订阅模式\r\n  - 定义：一种订阅机制，可在被订阅对象发生变化时通知订阅者。\r\n  - 应用场景：从系统架构之间的解耦，到业务中一些实现模式，像邮件订阅上线订阅等，应用广泛。\r\n\r\n\r\n\r\n#### JS中的设计模式\r\n\r\n- 原型模式\r\n  - 定义：复制已有对象来创建新的对象\r\n  - 应用场景：JS中对象创建的基本模式\r\n- 代理模式\r\n  - 定义：可自定义控制对原对象的访问方式，并且允许在更新前后做一些额外处理。\r\n  - 应用场景：监控，代理工具，前端框架实现等\r\n- 迭代器模式\r\n  - 定义：在不暴露数据类型的情况下访问集合中的数据\r\n  - 应用场景：数据结构中有多种数据类型结构，列表，树等，提供通用操作接口\r\n\r\n\r\n\r\n#### 前端框架中的设计模式\r\n\r\n- 代理模式\r\n\r\n  对DOM操作的代理：  更改DOM属性 -->  更新虚拟DOM  -->  视图更新\r\n\r\n- 组合模式\r\n\r\n  - 定义：可多个对象组合使用，也可单个对象独立使用\r\n\r\n  - 应用场景：DOM，前端组件，文件目录，部门\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 05 Web开发安全\r\n\r\n#### hacker —— 攻击篇\r\n\r\n##### Cross-Site Scripting(XSS)\r\n\r\n- 主要利用：\r\n  - 盲目信任用户的提交内容\r\n  - 将用户提交的string直接转换为DOM\r\n- 特点\r\n  - 通常难以从UI上感知\r\n  - 窃取用户信息(cookie/token)\r\n  - 绘制UI，诱骗用户点击/填写表单\r\n- 分类\r\n  - 存储型：\r\n    - 恶意脚本将被存在数据库中\r\n    - 访问页面 -> 读数据 -> 被攻击\r\n    - 危害最大，对全部用户可见\r\n  - 反射型：\r\n    - 不涉及数据库\r\n    - 从URL上攻击\r\n  - 基于DOM的攻击：\r\n    - 不需要服务器的参与\r\n    - 恶意攻击的发起+执行，全在浏览器完成\r\n  - 基于Mutation的攻击\r\n    - 利用浏览器渲染DOM的特性（独特优化)\r\n    - 不同浏览器会有区别（按浏览器进行攻击）\r\n\r\n##### Cross-site request forgery(CSRF)\r\n\r\n- 特点：\r\n\r\n  - 在用户不知情的前提下\r\n\r\n  - 利用用户权限(cookie)\r\n\r\n  - 构造指定HTTP请求，窃取或修改用户敏感信息\r\n\r\n- 常见攻击方式：\r\n\r\n  - GET\r\n  - beyond GET\r\n\r\n##### Injection\r\n\r\n- SQL Injection\r\n  - 请求SQL参数（恶意注入）\r\n  - Server参数 ->  SQL运行SQL code  \r\n  - 获取其他数据，修改数据，删除数据\r\n- 不止于SQL\r\n  - CLI\r\n  - OS command\r\n  - Server-Side Request Forgery(SSRF) 服务端伪造请求（严格来讲不是注入攻击）\r\n\r\n##### Denial of Service (Dos)\r\n\r\n- 正则表达式的贪婪模式，带\"?\"即为关闭贪婪模式，不带\"?\"的正则表达式即为贪婪模式。处于贪婪模式的正则表达式会尽可能多的匹配字符\r\n- ReDoS:基于正则表达式的DoS\r\n  - n次不匹配则回溯到n-1次尝试，导致响应时间增加，接口吞吐量下降\r\n- Distributed Dos(DDoS)\r\n  - 短时间内来自大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积，进而雪崩效应，无法响应新请求。\r\n  - 攻击特点：\r\n    - 直接访问IP\r\n    - 任意API\r\n    - 消耗大量带宽\r\n\r\n##### 基于传输层的攻击\r\n\r\n- 中间人攻击\r\n\r\n  - 明文传输\r\n\r\n  - 信息篡改不可知\r\n\r\n  - 对方身份未验证\r\n\r\n    \r\n\r\n#### 防御篇\r\n\r\n##### XSS\r\n\r\n- 永远不信任用户的提交内容\r\n- 不要将用户提交内容直接转换成DOM\r\n- 现成工具：\r\n  - 前端\r\n    - 主流框架默认防御XSS\r\n    - google-closure-library\r\n  - 服务端(Node)\r\n    - DOMPurify\r\n- 对于必须要将string转换成为DOM的情况：\r\n  - 对string进行转义\r\n- 用户上传svg：\r\n  - 对svg文件进行一次扫描\r\n- 自定义跳转链接：\r\n  - 尽量不要做允许用户自定义跳转链接的页面，即使要做也必须对自定义跳转链接做扫描\r\n\r\n\r\n\r\n- 同源策略Same-origin Policy(SOP)\r\n\r\n  - 协议、域名、端口均相同才叫同源\r\n\r\n  - HTTP请求一般对于同源是可行的，而对于跨域则不可行（更多是要看服务器的配置）\r\n\r\n    \r\n\r\n- Content Security Policy(CSP)\r\n\r\n  - 哪些源被认为是安全的\r\n  - 来自安全源的脚本的脚本可以执行，否则直接抛错\r\n  - 对eval或内联script直接报错\r\n\r\n##### CSRF的防御\r\n\r\n- 如果伪造请求是异常来源，限制请求\r\n\r\n- token防御机制：\r\n\r\n  - 浏览器向服务器请求页面\r\n  - 服务器返回页面+token\r\n  - 浏览器请求API时携带token\r\n  - 服务器验证token并返回数据\r\n\r\n  ![image-20220731161009382](C:\\D\\PCR\\Notes\\Pictures\\image-20220731161009382.png)\r\n\r\n- iframe攻击——同源请求\r\n  - X-Frame-Options:DENY/SAMEORIGIN\r\n- GET请求不应该既可以请求数据又可以修改数据\r\n- SameSite Cookie\r\n  - 避免用户信息被携带\r\n  - 第三方cookie不会被携带\r\n\r\n##### Injection的防御\r\n\r\n- 找到项目中查询SQL的地方\r\n- 使用prepared statement\r\n\r\n##### 防御DoS\r\n\r\n- 完善代码，避免贪婪模式的正则表达式\r\n- 拒绝用户提供的使用正则\r\n\r\n##### 防御DDoS\r\n\r\n- 流量治理\r\n  - 负载均衡\r\n  - API网关\r\n  - CDN\r\n- 快速自动扩容\r\n- 非核心服务降级\r\n\r\n##### 防御中间人\r\n\r\n- HTTPS\r\n\r\n  - 可靠性\r\n  - 完整性\r\n  - 不可依赖性\r\n\r\n  ![image-20220731162441881](C:\\D\\PCR\\Notes\\Pictures\\image-20220731162441881.png)\r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n### 06 HTTP实用指南\r\n\r\n#### 6.1 初识HTTP\r\n\r\n在浏览器地址栏输入字符串后到页面渲染发生了什么？\r\n\r\n> 输入字符串  ->   浏览器识别并处理输入信息  ->  浏览器内核发起请求  ->  目标服务器响应请求  ->  渲染页面  ->  页面加载完成\r\n\r\n其中网络请求相关的部分就会使用到应用层的HTTP协议(超文本传输协议)\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801145705895.png\" alt=\"image-20220801145705895\" style=\"zoom: 67%;\" />\r\n\r\n- 特点:\r\n  - 应用层协议,基于TCP协议\r\n  - 请求  响应\r\n  - 简单可扩展\r\n  - 无状态\r\n\r\n\r\n\r\n#### 6.2 协议分析\r\n\r\n##### 发展\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801150502941.png\" alt=\"image-20220801150502941\" style=\"zoom: 80%;\" />\r\n\r\n###### HTTP/2\r\n\r\n- 更快、更稳定、更简单\r\n- 帧(frame)：HTTP/2通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。\r\n- 采用二进制\r\n- 消息：与逻辑请求或响应消息对应的完整的一系列帧\r\n- 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。\r\n- 帧可以交错发送，接收方重组织\r\n- HTTP/2连接是永久的，而且仅需要每个来源一个连接\r\n- 流控制：阻止发送反向接收方发送大量数据的机制\r\n- 服务器推送\r\n\r\n###### HTTPS\r\n\r\n- 经过TSL/SSL加密\r\n- 对称加密：加密和解密都是使用同一个密钥\r\n- 非对称加密：加密和解密需要使用两个不同的密钥：公钥和私钥\r\n\r\n\r\n\r\n##### 报文\r\n\r\n(以HTTP/1.1为例)\r\n\r\n###### 请求报文\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801150909691.png\" alt=\"image-20220801150909691\" style=\"zoom: 80%;\" />\r\n\r\n第一行为Method,常见取值有:GET  POST  PUT  DELETE  HEAD  CONNECT  OPTIONS  TRACE  PATCH\r\n\r\n某些方法是安全的(Safe)(不会修改服务器的数据的方法),如GET、HEAD、OPTIONS\r\n\r\n某些方法是幂等的(Idempotent)(同样的请求被执行一次与连续执行多次的效果是一样的,服务器的状态也是一样的。所有safe的方法都是Idempotent的)，如GET、HEAD、OPTIONS、PUT、DELETE\r\n\r\n![image-20220801151128360](C:\\D\\PCR\\Notes\\Pictures\\image-20220801151128360.png)\r\n\r\n\r\n\r\n常用请求头\r\n\r\n![image-20220801152450150](C:\\D\\PCR\\Notes\\Pictures\\image-20220801152450150.png)\r\n\r\n\r\n\r\n缓存相关，浏览器缓存有两类：\r\n\r\n- 强缓存(资源若在本地存在则可以直接使用本地的已有资源)\r\n  - Expires,时间戳\r\n  - Cache-Control\r\n    - 可缓存性\r\n      - no-cache:协商缓存验证\r\n      - no-store:不使用任何缓存\r\n    - 到期\r\n      - max-age:单位秒,存储的最大周期,相对于请求的时间\r\n    - 重新验证*重新加载\r\n      - must-revalidate:一旦资源过期,在成功向原始服务器验证之前不能使用\r\n- 协商缓存(需与server端协商验证是否可以使用本地缓存)\r\n  - Etag/If-None-Match:资源的特定版本的标识符,类似于指纹\r\n  - Last-Modified/If-Modified-Since:最后修改时间\r\n\r\n使用缓存的流程:\r\n\r\n![image-20220801153510991](C:\\D\\PCR\\Notes\\Pictures\\image-20220801153510991.png)\r\n\r\n\r\n\r\n\r\n\r\n###### 响应报文\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801151744368.png\" alt=\"image-20220801151744368\" style=\"zoom: 80%;\" />\r\n\r\n第一行为状态码，用于表示响应的结果。\r\n\r\n状态码都是三位数字，规则如下：\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801151939084.png\" alt=\"image-20220801151939084\" style=\"zoom: 80%;\" />\r\n\r\n常见的状态码有\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801151850763.png\" alt=\"image-20220801151850763\" style=\"zoom: 80%;\" />\r\n\r\n​\t304:缓存资源未修改\r\n\r\n\r\n\r\n常用响应头：\r\n\r\n![image-20220801152719964](C:\\D\\PCR\\Notes\\Pictures\\image-20220801152719964.png)\r\n\r\n\r\n\r\nSet-Cookie响应头\r\n\r\n![image-20220801154119407](C:\\D\\PCR\\Notes\\Pictures\\image-20220801154119407.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 6.3 场景分析\r\n\r\n##### 静态资源\r\n\r\n静态资源方案：缓存+CDN+文件名hash\r\n\r\n- CDN：Content Delivery Network\r\n- 通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。\r\n\r\n##### 跨域\r\n\r\n- CORS(Cross-Origin Resource Sharing)\r\n- 预请求：获知该服务器是否允许该跨源请求\r\n- 跨域解决方案：\r\n  - 代理服务器\r\n    - 同源策略是浏览器的安全策略，不是HTTP的\r\n  - Iframe（诸多不便）\r\n\r\n\r\n\r\n#### 6.4 实战\r\n\r\n##### 浏览器\r\n\r\n- 浏览器内置了XHR(XMLHttpRequest)\r\n- readyState取值不同 表示请求的四个不同阶段\r\n\r\n<img src=\"C:\\D\\PCR\\Notes\\Pictures\\image-20220801162449157.png\" alt=\"image-20220801162449157\" style=\"zoom:50%;\" />\r\n\r\n- Fetch方法\r\n  - XHR的升级版\r\n  - 使用Promise解决回调地狱\r\n  - 模块化设计，Response,Request,Header对象\r\n  - 通过数据流处理对象，支持分块读取\r\n\r\n##### node\r\n\r\n- 标准库HTTP/HTTPS\r\n  - 默认板块，无需安装其他依赖\r\n  - 功能有限/不是十分友好\r\n- 常用的请求库axios\r\n  - 支持浏览器、nodejs环境\r\n  - 丰富的拦截器\r\n\r\n##### 用户体验\r\n\r\n###### 网络优化\r\n\r\n![image-20220801162932297](C:\\D\\PCR\\Notes\\Pictures\\image-20220801162932297.png)\r\n\r\n- CDN开启H2\r\n- 预解析、预连接等\r\n\r\n###### 稳定性\r\n\r\n![image-20220801163025123](C:\\D\\PCR\\Notes\\Pictures\\image-20220801163025123.png)\r\n\r\n- 重试是保证稳定的有效手段，但要防止加剧恶劣情况\r\n- 缓存合理使用，作为最后一道防线\r\n\r\n\r\n\r\n#### 6.5 扩展\r\n\r\n##### WebSocket\r\n\r\n- 浏览器与服务器进行全双工通讯的网络技术\r\n- 典型场景：实时性要求高，如聊天室\r\n- URL使用ws://或wss://等开头\r\n\r\n##### QUIC\r\n\r\n- Quick UDP Internet Connection\r\n- 0-RTT建联（首次建联除外）\r\n- 类似TCP的可靠传输\r\n- 类似TLS的加密传输，支持完美前向安全\r\n- 用户空间的拥塞控制，最新的BBR算法。\r\n- ......\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 07 前端开发调试\r\n\r\n前端开发Debug的特点：\r\n\r\n- 多平台：浏览器、Hybrid、NodeJs、小程序、桌面应用等\r\n- 多环境：本地开发环境、线上环境\r\n- 多工具：Chrome devTools、Charles、Spy-Debugger、Whistle...\r\n- 多技巧：Console、BreakPoint、sourceMap、代理等\r\n\r\n\r\n\r\n#### Chrome devTools\r\n\r\n##### Elements\r\n\r\n![image-20220802150053143](C:\\D\\PCR\\Notes\\Pictures\\image-20220802150053143.png)\r\n\r\n- 点击.cls开启动态修改元素的class\r\n- 输入字符串可以动态的给元素添加类名\r\n- 勾选/取消类名可以动态查看类名生效效果\r\n- 点击具体的样式值可以进行编辑，浏览器内容区域实时预览\r\n- 激活伪类的方法：\r\n  - 选中具有伪类的元素点击：hov \r\n  - DOM树右键菜单，选择Force state\r\n- Computed下点击样式里的箭头可以跳转到styles面板中的css规则\r\n\r\n\r\n\r\n##### Console\r\n\r\n```js\r\nconsole.log('Hi')\r\nconsole.warn('Warn')\r\nconsole.error('Error')\r\nconsole.debug('debug')\r\nconsole.info('info')\r\n//占位符：给日志添加样式，可以突出重要信息。%s 字符串占位符；%o对象占位符；%c样式占位符；%d数字占位符\r\nconsole.log('%s %o,%c%s','hello',{name:'tom',age:18},'font-size:24px;color:red','Welcome to BD')\r\nconsole.table(arr)   //具象化地展示JSON和数组数据\r\nconsole.dir(box1)  //通过类似文件树的方式展示对象的属性\r\n```\r\n\r\n\r\n\r\n##### Source\r\n\r\n- source可以看到页面的HTML、CSS、JS等代码\r\n\r\n- 在程序中加入debugger关键词可以设置断点，当程序运行到断点时会暂停运行\r\n\r\n- 也可以在source中的代码里左侧行号处标记以添加断点\r\n\r\n- 在source的代码中，将鼠标悬停在变量上可以查看变量的值。\r\n\r\n- 也可以在source页面右侧的Watch栏手动添加要观测的变量\r\n\r\n- Breakpoints栏可以临时操控断点\r\n\r\n- 展开Scope可以查看作用域列表（包含闭包）\r\n\r\n- 展开Call Stack 可以查看当前js代码的调用栈\r\n\r\n- XHR Breakpoint 可以记录发生网络请求时断点的状态\r\n\r\n- DOM Breakpoints 可以查看当HTML中某一个元素发生变化时断点的状态\r\n\r\n- 压缩后的代码如何调试？\r\n\r\n  > 使用Source Map 可以将压缩之后的代码与源码进行映射，而为了安全和节省体积，代码上线时是不带SourceMap的，SourceMap则被上传到监控平台\r\n\r\n![image-20220802155002184](C:\\D\\PCR\\Notes\\Pictures\\image-20220802155002184.png)\r\n\r\n\r\n\r\n##### Network\r\n\r\n监控浏览器向服务端请求的资源\r\n\r\n- No throttling可以模拟弱网环境\r\n- 可以点击具体某一项资源查看其相关信息\r\n\r\n![image-20220802161718274](C:\\D\\PCR\\Notes\\Pictures\\image-20220802161718274.png)\r\n\r\n\r\n\r\n##### Application\r\n\r\n存储相关\r\n\r\n\r\n\r\n##### Performance\r\n\r\n![image-20220802162341525](C:\\D\\PCR\\Notes\\Pictures\\image-20220802162341525.png)\r\n\r\n从上到下依次为：控制面板、概览面板、线程面板、统计面板\r\n\r\n用于分析性能问题\r\n\r\n页面卡顿  ->  查看FPS指标  ->  寻找性能瓶颈  ->  性能优化\r\n\r\n\r\n\r\n##### LightHouse\r\n\r\n衡量站点性能\r\n\r\n核心Web指标：\r\n\r\n- LCP：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP应在页面首次开始加载后的2.5秒内发生。\r\n- FID：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的FID应为100毫秒或更短。\r\n- CLS：累计布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的CLS应保持在0.1或更少。\r\n\r\n\r\n\r\n#### 移动端H5调试\r\n\r\n##### 真机调试\r\n\r\n##### VConsole\r\n\r\n##### 使用代理工具调试\r\n\r\n- 常用代理工具：Charles、Spy-Debugger\r\n\r\n\r\n\r\n#### NodeJs调试\r\n\r\n##### Inspector Protocol + Chrome Devtool\r\n\r\n1. 执行命令 node --inspect=8888 index.js\r\n2. chrome浏览器访问服务\r\n3. 点击绿色node图标打开node调试面板\r\n4. 在node调试面板中使用断点调试\r\n\r\n\r\n\r\n#### 常用开发调试技巧\r\n\r\n##### 线上即时修改Overrides\r\n\r\n1. 打开Source面板下的Overrides\r\n2. 选择一个本地的空文件夹目录\r\n3. 允许授权\r\n4. 在page中修改代码，修改完成后Ctrl+S保存\r\n5. 打开devTools，点击右上角三点->More tools-> Changes,就能看到所有修改\r\n\r\n##### 利用代理解决开发阶段的跨域问题\r\n\r\n![image-20220802165328962](C:\\D\\PCR\\Notes\\Pictures\\image-20220802165328962.png)\r\n\r\n##### 启用本地SourceMap\r\n\r\n线上不存在SourceMap时可以使用Map Local网络映射功能来访问本地的SourceMap文件\r\n\r\n##### 使用代理工具Mock数据\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 08 TypeScript\r\n\r\n#### 为什么要选择typescript？\r\n\r\n> JS是动态类型，弱类型语言；而TS是静态类型弱类型语言\r\n>\r\n> (动态类型语言在执行时才进行(编译)类型匹配，而静态类型语言则会提前进行类型匹配\r\n>\r\n> 弱类型语言会隐式类型转换,而强类型语言则不会)\r\n>\r\n> 静态类型语言的可读性增强、可维护性增强，因此在多人合作的大型项目中可以获得更好的稳定性和开发效率\r\n>\r\n> 在此基础上，TS是JS的超集，包含于兼容所有JS特性，支持共存，支持渐进式引入与升级。\r\n\r\n#### 基本语法\r\n\r\n##### 基本类型\r\n\r\n```typescript\r\nconst q: string = 'lapi'\r\nconst w: number = 20\r\nconst e: boolean = true\r\nconst r: null = null\r\nconst t: undefined = undefined\r\n```\r\n\r\n##### 对象类型\r\n\r\n```typescript\r\nconst obj: Obj = {\r\n    jobId: 191910,\r\n    name:'Lapi',\r\n    sex:'man',\r\n    age:20,\r\n    hobby:'running'\r\n}\r\n\r\ninterface Obj {\r\n    /*只读属性：约束属性不可在对象初始化外赋值*/\r\n    readonly jobId: number\r\n    name: string\r\n    sex: 'man'|'women'|'other'\r\n    age: number\r\n    /*可选属性：定义该属性可以不存在*/\r\n    hobby?: string\r\n    /*任意属性：约束所有对象属性都必须是该属性的子类型*/\r\n    [key: string]: any\r\n}\r\n```\r\n\r\n##### 函数类型\r\n\r\n```typescript\r\nfunction add(x: number,y: number): number{\r\n    return x+y\r\n}\r\n\r\nconst mult: (x: number,y: number) => number = (x,y) => x*y\r\n\r\n\r\ninterface Imult {\r\n    (x: number,y: number): number\r\n}\r\nconst mult: Imult = (x,y) => x*y\r\n```\r\n\r\n##### 函数重载\r\n\r\n可以对函数类型进行多次声明以实现不同输入类型对于不同输出的类型\r\n\r\n如下例：\r\n\r\n编写一个生成时间函数，函数有一个参数type，若type为'date'，则返回值为一个Date对象；若type为'string'，则返回值为一个字符串。\r\n\r\n另外函数有一个缺省值参数time，若这个参数存在则根据此参数构造时间，否则返回当前时间\r\n\r\n```typescript\r\nfunction getDate(type: 'string',time?: string): string\r\nfunction getDate(type: 'date',time?: string): Date\r\nfunction getDate(type: 'string'|'date',time?: string): string|Date{\r\n    const date = new Date(time)\r\n    return type === 'string' ? date.toLocalString() : date\r\n}\r\n```\r\n\r\n##### 数组类型\r\n\r\n```typescript\r\n//  类型+方括号  表示\r\ntype IArr1 = number[]\r\n//  泛型  表示\r\ntype IArr2 = Array<string | number | Record<string,number>>\r\n//  元组  表示\r\ntype IArr3 = [number,number,string,string]\r\n//  接口  表示\r\ninterface IArr4 {\r\n    [key: number]: any\r\n}\r\n\r\nconst arr1: IArr1 = [1,2,3,4]\r\nconst arr2: IArr2 = [1,2,'3','4',{a: 1}]\r\nconst arr3: IArr3 = [1,2,'3','4']\r\nconst arr4: IArr4 = ['string',()=>null,{},[]]\r\n```\r\n\r\n##### TS补充类型\r\n\r\n```typescript\r\n// 空类型\r\ntype IEmptyFunction = ()=> void\r\n// 任意类型\r\ntype IAnyType = any\r\n// 枚举类型:支持枚举值到枚举名的正反映射\r\nenum Enum{\r\n    add = '+',\r\n    mult = '*'\r\n}\r\n// 泛型\r\ntype INumArr = Array<number>\r\n```\r\n\r\n##### 泛型\r\n\r\n不预先指定具体的类型，而在使用的时候再指定类型的一种特性\r\n\r\n```typescript\r\nfunction getRepeatArr(target): IGetRepeatArrR {\r\n    return new Array(100).fill(target)\r\n}\r\n\r\ntype IGetRepeatArrR = <T>(target: T)=> T[]\r\n\r\n//泛型约束\r\ntype IGet = <T extends string>(target: T)=> T[]  //将泛型限定在字符串内\r\n//泛型参数默认类型\r\ntype IGet<T = number> = (target: T) => T[]\r\n```\r\n\r\n##### 类型别名、类型断言\r\n\r\n```typescript\r\ntype IObj = Array<{\r\n    key: string\r\n    [objKey: string]: any\r\n}>\r\n\r\n//通过as关键字断言result类型为正确类型\r\nfunction kb<T>(o: Array<T>){\r\n    const result\r\n    return result as Record<string,T>\r\n}\r\n```\r\n\r\n##### 字符串/数字 字面量\r\n\r\n允许指定字符串/数字 必须的固定值\r\n\r\n```typescript\r\ntype IDomtag = 'html' | 'body' | 'div' | 'span'\r\ntype IOdd = 1 | 3 | 5 | 7 | 9\r\n```\r\n\r\n\r\n\r\n#### 高级类型\r\n\r\n##### 联合/交叉类型\r\n\r\n联合类型  IA | IB  表示一个值可以是几种类型之一\r\n\r\n交叉类型  IA  &  IB  多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性\r\n\r\n##### 类型守卫\r\n\r\n定义一个函数，它的返回值是一个类型谓词，生效范围为子作用域\r\n\r\n```typescript\r\nfunction getIsIA(arg: IA | IB): arg is IA{\r\n    return !!(arg as IA).a\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 09 React\r\n\r\n#### 9.1 React的设计思路\r\n\r\n- 原生JS编写UI时有以下痛点\r\n\r\n  - 状态更新，UI不会自动更新，需要手动地调用DOM进行更新。\r\n  - 欠缺基本的代码层面的封装和隔离，代码层面没有组件化。\r\n  - UI之间的数据依赖关系，需要手动维护，如果依赖链路长，则会遇到Callback Hell\r\n\r\n- 转换式与响应式\r\n\r\n  - 转换式系统：给定输入求解输出，如编译器、数值计算\r\n  - 响应式系统：监听事件，消息驱动。如监控系统、UI界面\r\n    - 事件  ->  执行既定的回调  ->  状态变更  ->  UI更新\r\n\r\n- 对React框架的期望\r\n\r\n  - 状态更新，UI自动更新。\r\n  - 前端代码组件化，可复用，可封装。\r\n  - 状态之间的互相依赖关系，只需声明即可。\r\n\r\n- 组件化\r\n\r\n  - 组件是组件的组合/原子组件\r\n  - 组件内拥有状态，外部不可见\r\n  - 父组件可将状态传入组件内部\r\n\r\n- 状态归属问题\r\n\r\n  - React是单向数据流，还是双向数据流？\r\n\r\n    >单向数据流，只有父组件可以传递数据给子组件\r\n\r\n  - 如何解决状态不合理上升的问题？\r\n\r\n    >使用状态管理库统一管理\r\n\r\n  - 组件的状态改变后，如何更新DOM？\r\n\r\n    >使用虚拟DOM，Diff算法\r\n\r\n- 组件设计\r\n\r\n  - 组件声明了状态和UI的映射。\r\n  - 组件有Props/State两种状态。\r\n    - 组件内部拥有私有状态State.\r\n    - 组件接受外部的Props状态提供复用性。\r\n    - 根据当前的State/Props，返回一个UI\r\n  - 组件可由其他组件拼装而成。\r\n\r\n- 生命周期\r\n\r\n  ![image-20220806170620692](C:\\D\\PCR\\Notes\\Pictures\\image-20220806170620692.png)\r\n\r\n\r\n\r\n#### 9.2 Hooks\r\n\r\n挂载到React的生命周期函数上执行的函数\r\n\r\n- useState\r\n\r\n  - 传入一个初始值，返回一个状态，和set该状态的函数，可以通过调用该函数来实现状态的修改。\r\n\r\n    ```react\r\n    function Example(){\r\n        const [x,setX] = useState(0)\r\n        \r\n        return (\r\n        \t<div>\r\n            \t<p>你点击了{x}次</p>\r\n                <button onClick = {()=> setX(x+1)}>点我</button>\r\n            </div>\r\n        );\r\n    }\r\n    ```\r\n\r\n    \r\n\r\n- useEffect\r\n\r\n  - 传入一个函数，和一个数组，数组是状态的数组，称作依赖项，该函数在mount时，和依赖性被set时会执行。\r\n\r\n  - 有”副作用“的函数，要传入useEffect来执行。副作用代表除了单纯的计算之外，还要做一些其他的事情，比如网络请求，更新DOM，localStorage存储数据等。\r\n\r\n    ```react\r\n    function Example(){\r\n        const [x,setX] = useState(0)\r\n        \r\n        useEffect(()=>{\r\n            document.title = `x`\r\n        })\r\n        \r\n        return (\r\n        \t<div>\r\n            \t<p>你点击了{x}次</p>\r\n                <button onClick = {()=> setX(x+1)}>点我</button>\r\n            </div>\r\n        );\r\n    }\r\n    ```\r\n\r\n- 注意：不要在循环，条件或嵌套中调用Hook\r\n\r\n\r\n\r\n#### 9.3 React的实现\r\n\r\n- JSX不符合JS标准语法\r\n\r\n  > 转译即可\r\n\r\n- 返回的JSX发生改变时，如何更新DOM\r\n\r\n  - 虚拟DOM\r\n    - 一种用于和真是DOM同步，而在JS内存中维护的一个对象，它具有和DOM类似的树状结构，并和DOM可以建立一一对应的关系。\r\n    - 它赋予了React声明式的API：你告诉React希望UI是什么状态，React就确保DOM匹配该状态。这使你可以从属性操作、事件处理和手动DOM更新这些构建应用程序时必要的操作中解放出来。\r\n\r\n- State/Props更新时，要重新触发render函数\r\n\r\n![image-20220806181713460](C:\\D\\PCR\\Notes\\Pictures\\image-20220806181713460.png)\r\n\r\n![image-20220806181737558](C:\\D\\PCR\\Notes\\Pictures\\image-20220806181737558.png)\r\n\r\n\r\n\r\n#### 9.4 状态管理库\r\n\r\n将状态抽离到UI外部进行统一管理\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 10 Node.Js\r\n\r\n#### 10.1 Node.js的应用场景\r\n\r\n- 前端工程化\r\n  - Bundle: Webpack,vite,esbuild,parcel\r\n  - Uglify: uglifyjs\r\n  - Transpile: bablejs,typescript\r\n  - 其他语言加入竞争：esbuild,parcel,prisma\r\n  - 现状：难以替代\r\n- Web服务端应用\r\n  - 学习曲线平缓，开发效率较高\r\n  - 运行效率接近常见的编译语言\r\n  - 社区生态丰富及工具链成熟(npm,V8 inspector)\r\n  - 与前端结合的场景会有优势(SSR)\r\n  - 现状：竞争激烈，Node.Js有自己独特的优势\r\n- Electron跨端桌面应用\r\n  - 商业应用：vscode,slack,discord,zoom\r\n  - 大型公司内的效率工具\r\n  - 现状：大部分场景在选型时都值得考虑\r\n\r\n\r\n\r\n#### 10.2 Node.js运行时结构\r\n\r\n![image-20220807142452268](C:\\D\\PCR\\Notes\\Pictures\\image-20220807142452268.png)\r\n\r\nV8: JavaScript Runtime,诊断调试工具(inspector)\r\n\r\nlibuv: eventloop(事件循环),syscall(系统调用,跨平台操作)\r\n\r\n##### 特点\r\n\r\n- 异步I/O\r\n\r\n  - 当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻塞线程并占用额外内存等待\r\n\r\n- 单线程\r\n\r\n  - worker_thread 可以起独立线程，但每个线程的模型没有太大变化\r\n  - JS单线程\r\n    - 实际：JS线程+uv线程池+V8任务线程池+V8 Inspector线程\r\n  - 优点：不用考虑多线程状态同步问题，也就不需要锁；同时还能比较高效地利用系统资源\r\n  - 缺点：阻塞会产生更多负面影响\r\n    - 解决办法：多线程或多进程\r\n\r\n- 跨平台(大部分功能、api)\r\n\r\n  - Node.js 跨平台 + JS无需编译环境(+Web跨平台 + 诊断工具跨平台) = 开发成本低(大部分场景无需担心跨平台问题)，整体学习成本低\r\n\r\n  \r\n\r\n#### 10.3 编写Http Server\r\n\r\n\r\n\r\n\r\n\r\n### 11 Vite\r\n\r\n#### 11.1 浅谈构建工具\r\n\r\n> 为什么要构建工具？\r\n>\r\n> 前端工程的痛点：模块化(ESM、CommanJS、UMD)、资源编译(高级语法的编译)、产物质量(代码体积、性能)、开发效率(热更新)\r\n\r\n\r\n\r\n构建工具的意义：\r\n\r\n- 模块化方案\r\n\r\n  - 提供模块加载方案\r\n  - 兼容不同模块规范\r\n\r\n- 语法转译\r\n\r\n  - 高级语法转译，如Sass、TypeScript\r\n  - 资源加载，如图片、字体、worker\r\n\r\n- 产物质量\r\n\r\n  - 产物压缩、无用代码删除、语法降级\r\n\r\n- 开发效率\r\n\r\n  - 热更新\r\n\r\n  \r\n\r\n#### 11.2 Vite概要介绍\r\n\r\n定位：新一代前端构建工具\r\n\r\n两大组成部分：\r\n\r\n- No-bundle开发服务，源文件无需打包\r\n- 生产环境基于Rollup 的 Bundler\r\n\r\n核心特征：\r\n\r\n- 高性能，dev启动速度和热更新速度非常快\r\n- 简单易用，开发者体验好\r\n\r\n\r\n\r\n当下问题(Webpack、Rollup)\r\n\r\n- 缓慢的启动   ->  项目编译等待成本高\r\n- 缓慢的热更新  ->  修改代码后不能实时更新\r\n\r\n\r\n\r\n> 瓶颈在哪里？\r\n>\r\n> bundle带来的性能开销\r\n>\r\n> JavaScript语言的性能瓶颈\r\n\r\n\r\n\r\n两大行业趋势\r\n\r\n- 全球浏览器对原生ESM的普遍支持(目前占比92%以上)\r\n\r\n  - 两大要素：\r\n\r\n    - script标签增加type = \"module\"属性\r\n\r\n    - 使用ESM模块导入导出语法\r\n\r\n  - 基于原生ESM的开发服务优势：\r\n\r\n    - 无需打包项目源代码\r\n    - 天然的按需加载\r\n    - 可以利用文件级的浏览器缓存\r\n\r\n- 基于原生语言(Go、Rust)编写前端编译工具链\r\n\r\n  - 基于Esbuild的编译性能优化\r\n    - Esbuild——基于Golang开发的前端工具，具备如下能力：\r\n      - 打包器Bundler\r\n      - 编译器Transformer\r\n      - 压缩器Minifier\r\n\r\n\r\n\r\nVite内置的Web构建能力\r\n\r\n- Vite开箱即用的功能等价于\r\n\r\n  - webpack\r\n\r\n  - webpack-dev-server\r\n\r\n  - css-loader\r\n\r\n  - style-loader\r\n\r\n  - less-loader\r\n\r\n  - sass-loader\r\n\r\n  - postcss-loader\r\n\r\n  - file-loader\r\n\r\n  - MiniCssExtractPlugin\r\n\r\n  - HTMLWebpackPlugin\r\n\r\n    ......\r\n\r\n\r\n\r\n#### 11.3 Vite上手实战\r\n\r\n生产环境Tree Shaking\r\n\r\n- 优化原理：\r\n  - 基于ESM的import/export语句依赖关系，与运行时状态无关\r\n  - 在构建阶段将未使用到的代码删除\r\n- 在vite中无需配置，默认开启\r\n\r\n\r\n\r\n#### 11.4 Vite整体架构\r\n\r\n![image-20220809153548968](C:\\D\\PCR\\Notes\\Pictures\\image-20220809153548968.png)\r\n\r\n##### 依赖预打包\r\n\r\n> 为什么要进行预打包？\r\n>\r\n> 1. 避免node_modules 过多的文件请求\r\n> 2. 将CommanJS格式转换为ESM格式\r\n>\r\n> 实现原理：\r\n>\r\n> 1. 服务启动前扫描代码中用到的依赖\r\n> 2. 用Esbuild对依赖代码进行预打包\r\n> 3. 改写import语句，指定依赖为预构建产物的路径\r\n\r\n##### 单文件编译\r\n\r\n用Esbuild编译TS/JSX\r\n\r\n优势：编译速度提升10-100x\r\n\r\n局限性：不支持类型检查、不支持语法降级到ES5\r\n\r\n##### 代码压缩\r\n\r\nEsbuild作为默认压缩工具，替换传统的Terser、Uglify.js等压缩工具\r\n\r\n##### 插件机制\r\n\r\n开发阶段 -> 模拟Rollup插件机制\r\n\r\n生产环境 -> 直接使用Rollup\r\n\r\n插件兼容性具体可查阅 https://vite-rollup-plugins.patak.dev/\r\n",
        "timemini": ""
    },
    {
        "index": 17,
        "title": "操作系统笔记",
        "essay": "## 1、进程与线程的区别\r\n\r\n**进程**\r\n\r\n我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。\r\n\r\n**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体**。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志\r\n\r\n进程具有的**特征**：\r\n\r\n动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；\r\n\r\n并发性：任何进程都可以同其他进行一起并发执行；\r\n\r\n独立性：进程是系统进行资源分配和调度的一个独立单位；\r\n\r\n结构性：进程由程序，数据和进程控制块三部分组成\r\n\r\n**线程**\r\n\r\n在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。\r\n\r\n后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，**线程是程序执行中一个单一的顺序控制流程，是程序执行的最小单元，是处理器调度和分派的基本单位**。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。\r\n\r\n**线程与进程的区别**\r\n\r\n1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；\r\n\r\n2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线\r\n\r\n3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；\r\n\r\n4. 调度和切换：线程上下文切换比进程上下文切换要快得多\r\n\r\n总之，线程和进程都是一种抽象的概念，线程是一种比进程还小的抽象，线程和进程都可用于实现并发。\r\n\r\n在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位，它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程\r\n\r\n后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念-线程，一般一个进程会有多个(也可以是一个)线程。\r\n\r\n**线程和进程关系示意图**\r\n\r\n![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/c47130a65e58499ca4e539e7729bb8bc.jpg)\r\n\r\n总之，线程和进程都是一种抽象的概念，线程是一种比进程还小的抽象，线程和进程都可用于实现并发。\r\n\r\n在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位，它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程\r\n\r\n后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念-线程，一般一个进程会有多个(也可以是一个)线程\r\n\r\n![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/800567fa3af1494b82ab253a4f3e5015.jpg)\r\n\r\n**任务调度**\r\n\r\n大部分操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发\r\n\r\n**线程之间共享了哪些资源**\r\n\r\n**共享的资源有**\r\n\r\n- 堆：由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）\r\n\r\n- 全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的\r\n- 静态变量：虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的\r\n- 文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。\r\n\r\n**独享的资源有**\r\n\r\n- 栈：栈是独享的\r\n- 寄存器：这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC\r\n\r\n\r\n\r\n**为何不使用多进程而是使用多线程？**\r\n\r\n线程廉价，线程启动比较快，退出比较快，对系统资源的冲击也比较小。而且线程彼此分享了大部分核心对象(File Handle)的拥有权\r\n\r\n如果使用多重进程，不可预期，且测试困难\r\n\r\n\r\n\r\n**为什么线程上下文切换比进程上下问切换消耗低**\r\n\r\n首先要明白进程是什么：\r\n\r\n关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。 一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文（Context）。可见，想要切换进程，保存的状态还不少。\r\n\r\n其次就要了解线程是什么：\r\n\r\n线程存在于进程中，一个进程可以有一个或多个线程。线程是运行在进程上下文中的逻辑流，简单说，线程可以理解为一个方法(Java)或函数（C），这个线程可以独立完成一项任务。同样线程有自己的上下文，包括唯一的整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码。可以理解为线程上下文是进程上下文的子集。\r\n\r\n> 由于保存线程的上下文明显比进程的上下文小，因此系统切换线程时，必然开销更小。\r\n\r\n## 2、线程同步的方式有哪些\r\n\r\nhttps://blog.csdn.net/qq_37685457/article/details/89738269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\r\n\r\n1. 锁机制：包括互斥锁、条件变量、读写锁\r\n   互斥锁提供了以排他方式防止数据结构被并发修改的方法。\r\n   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。\r\n   条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\r\n2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量\r\n3. 信号机制(Signal)：类似进程间的信号处理\r\n   线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。\r\n\r\n\r\n\r\n1、synchronized + wait + notifyAll + 条件\r\n2、Lock + Condition + 条件\r\n3、Semaphore\r\n4、CountDownLatch\r\n5、Cyclicbarrier\r\n6、Exchanger\r\n7、sleep、join、yeild\r\n\r\n## 3、进程间的通信方式有哪些\r\n\r\n1. 管道( pipe )：\r\n   管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\r\n2. 有名管道 (namedpipe) ：\r\n   有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\r\n3. 信号量(semophore ) ：\r\n   信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\r\n4. 消息队列( messagequeue ) ：\r\n   消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\r\n5. 信号 (sinal ) ：\r\n   信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\r\n6. 共享内存(shared memory ) ：\r\n   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\r\n7. 套接字(socket ) ：\r\n   套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\r\n\r\n每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。\r\n\r\n![img](file://C:\\Users\\86158\\Desktop\\掘金笔记\\操作系统.assets\\640?lastModify=1660104233)\r\n\r\nLinux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？\r\n\r\n### 管道\r\n\r\n如果你学过 Linux 命令，那你肯定很熟悉「`|`」这个竖线。\r\n\r\n```\r\n$ ps auxf | grep mysql\r\n```\r\n\r\n上面命令行里的「`|`」竖线就是一个**管道**，它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从这功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行。\r\n\r\n同时，我们得知上面这种管道是没有名字，所以「`|`」表示的管道称为**匿名管道**，用完了就销毁。\r\n\r\n管道还有另外一个类型是**命名管道**，也被叫做 `FIFO`，因为数据是先进先出的传输方式。\r\n\r\n在使用命名管道前，先需要通过 `mkfifo` 命令来创建，并且指定管道名字：\r\n\r\n```\r\n$ mkfifo myPipe\r\n```\r\n\r\nmyPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：\r\n\r\n```\r\n$ ls -l\r\nprw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe\r\n```\r\n\r\n接下来，我们往 myPipe 这个管道写入数据：\r\n\r\n```\r\n$ echo \"hello\" > myPipe  // 将数据写进管道\r\n                         // 停住了 ...\r\n```\r\n\r\n你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。\r\n\r\n于是，我们执行另外一个命令来读取这个管道里的数据：\r\n\r\n```\r\n$ cat < myPipe  // 读取管道里的数据\r\nhello\r\n```\r\n\r\n可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。\r\n\r\n我们可以看出，**管道这种通信方式效率低，不适合进程间频繁地交换数据**。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。\r\n\r\n> 那管道如何创建呢，背后原理是什么？\r\n\r\n匿名管道的创建，需要通过下面这个系统调用：\r\n\r\n```\r\nint pipe(int fd[2])\r\n```\r\n\r\n这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。\r\n\r\n其实，**所谓的管道，就是内核里面的一串缓存**。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。\r\n\r\n看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？\r\n\r\n我们可以使用 `fork` 创建子进程，**创建的子进程会复制父进程的文件描述符**，这样就做到了两个进程各有两个「 `fd[0]` 与 `fd[1]`」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。\r\n\r\n管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：\r\n\r\n- 父进程关闭读取的 fd[0]，只保留写入的 fd[1]；\r\n- 子进程关闭写入的 fd[1]，只保留读取的 fd[0]；\r\n\r\n所以说如果需要双向通信，则应该创建两个管道。\r\n\r\n到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。\r\n\r\n在 shell 里面执行 `A | B`命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。\r\n\r\n所以说，在 shell 里通过「`|`」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。\r\n\r\n我们可以得知，**对于匿名管道，它的通信范围是存在父子关系的进程**。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。\r\n\r\n另外，**对于命名管道，它可以在不相关的进程间也能相互通信**。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。\r\n\r\n不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。\r\n\r\n### 消息队列\r\n\r\n前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。\r\n\r\n对于这个问题，**消息队列**的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。\r\n\r\n再来，**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。\r\n\r\n消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。\r\n\r\n消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。\r\n\r\n但邮件的通信方式存在不足的地方有两点，**一是通信不及时，二是附件也有大小限制**，这同样也是消息队列通信不足的点。\r\n\r\n**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。\r\n\r\n**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。\r\n\r\n------\r\n\r\n### 共享内存\r\n\r\n消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那**共享内存**的方式，就很好的解决了这一问题。\r\n\r\n现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。\r\n\r\n**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。\r\n\r\n### 信号量\r\n\r\n用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。\r\n\r\n为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。\r\n\r\n**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。\r\n\r\n信号量表示资源的数量，控制信号量的方式有两种原子操作：\r\n\r\n- 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。\r\n- 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\r\n\r\nP 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。\r\n\r\n接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 `1`。\r\n\r\n具体的过程如下：\r\n\r\n- 进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。\r\n- 若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。\r\n- 直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。\r\n\r\n可以发现，信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。\r\n\r\n另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。\r\n\r\n例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。\r\n\r\n那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 `0`。\r\n\r\n具体过程：\r\n\r\n- 如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；\r\n- 接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；\r\n- 最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。\r\n\r\n可以发现，信号初始化为 `0`，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行。\r\n\r\n------\r\n\r\n### 信号\r\n\r\n上面说的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**\r\n\r\n信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。\r\n\r\n在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号：\r\n\r\n```\r\n$ kill -l\r\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP\r\n 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1\r\n11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM\r\n16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\r\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ\r\n26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR\r\n31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\r\n38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\r\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\r\n48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\r\n53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\r\n58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\r\n63) SIGRTMAX-1  64) SIGRTMAX\r\n```\r\n\r\n运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如\r\n\r\n- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；\r\n- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；\r\n\r\n如果进程在后台运行，可以通过 `kill` 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：\r\n\r\n- kill -9 1050 ，表示给 PID 为 1050 的进程发送 `SIGKILL` 信号，用来立即结束该进程；\r\n\r\n所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。\r\n\r\n信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。\r\n\r\n**1.执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。\r\n\r\n**2.捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。\r\n\r\n**3.忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。\r\n\r\n------\r\n\r\n### Socket\r\n\r\n前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**\r\n\r\n实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。\r\n\r\n我们来看看创建 socket 的系统调用：\r\n\r\n```\r\nint socket(int domain, int type, int protocal)\r\n```\r\n\r\n三个参数分别代表：\r\n\r\n- domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；\r\n- type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；\r\n- protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；\r\n\r\n根据创建 socket 类型的不同，通信的方式也就不同：\r\n\r\n- 实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；\r\n- 实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；\r\n- 实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；\r\n\r\n接下来，简单说一下这三种通信的编程模式。\r\n\r\n> 针对 TCP 协议通信的 socket 编程模型\r\n\r\n- 服务端和客户端初始化 `socket`，得到文件描述符；\r\n- 服务端调用 `bind`，将绑定在 IP 地址和端口;\r\n- 服务端调用 `listen`，进行监听；\r\n- 服务端调用 `accept`，等待客户端连接；\r\n- 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；\r\n- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；\r\n- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；\r\n- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。\r\n\r\n这里需要注意的是，服务端调用 `accept` 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。\r\n\r\n所以，监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。\r\n\r\n成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。\r\n\r\n> 针对 UDP 协议通信的 socket 编程模型\r\n\r\nUDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。\r\n\r\n对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。\r\n\r\n另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。\r\n\r\n> 针对本地进程间通信的 socket 编程模型\r\n\r\n本地 socket  被用于在**同一台主机上进程间通信**的场景：\r\n\r\n- 本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；\r\n- 本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；\r\n\r\n对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。\r\n\r\n对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。\r\n\r\n本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**，这也就是它们之间的最大区别。\r\n\r\n------\r\n\r\n### 总结\r\n\r\n由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。\r\n\r\nLinux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。\r\n\r\n**匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。\r\n\r\n**命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。\r\n\r\n**消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**\r\n\r\n**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**\r\n\r\n那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。\r\n\r\n与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。\r\n\r\n前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。\r\n\r\n以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？\r\n\r\n同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：\r\n\r\n- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；\r\n- 同步的方式，可保证线程 A 应在线程 B 之前执行；",
        "timemini": ""
    },
    {
        "index": 18,
        "title": "数字图像处理",
        "essay": "## Chapter1绪论\r\n\r\n### 1.数字图像\r\n\r\n​\t\t一幅图像可定义为一个二维函数f(x,y)，其中x和y是空间（平面）坐标，而在任何一对空间坐标处的幅值f称为图像在该点的强度或灰度。当x,y,f是有限的离散数值时，我们称该图像为数字图像。\r\n\r\n### 2.数字图像处理\r\n\r\n​\t\t数字图像处理是指借助于数字计算机来处理图像。\r\n\r\n### 3.数字图像处理领域图像类型\r\n\r\n​\t\t①伽马射线\t②X射线\t③紫外波段\t④可见光及红外波段\t⑤微波波段\t⑥无线电波段\t⑦使用其他成像方式：声波、电子显微镜方法和（由计算机产生的）合成成像\r\n\r\n### 4.数字图像处理基本步骤\r\n\r\n\r\n\r\n![image-20220524102545971](C:\\Users\\86181\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220524102545971.png)\r\n\r\n\r\n\r\n### 5.数字图像处理系统组成\r\n\r\n\r\n\r\n<img src=\"C:\\Users\\86181\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220524102639187.png\" alt=\"image-20220524102639187\" style=\"zoom:70%;\" />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Chapter2数字图像基础\r\n\r\n### 1.亮度适应与辨别\r\n\r\n​\t\t感知亮度不是简单的强度的函数。\r\n\r\n### 2.光与电磁波谱\r\n\r\n​\t\t波长与频率的关系：\r\n$$\r\n\\lambda = c/v\r\n$$\r\n​\t\t其中c是光速，波长单位是m，频率单位为Hz\r\n\r\n​\t\t电磁波谱的各个分量的能量由下式给出：\r\n$$\r\nE = hv\r\n$$\r\n​\t\t==能量与频率成正比，更高频率的电磁现象的每个光子携带更多的能量==\r\n\r\n​\t\t**从黑到白的单色光的度量值范围通常称为灰度级，单色图像常称为灰度图像。**\r\n\r\n### 3.图像获取方式\r\n\r\n​\t\t①使用单个传感器获取图像\t②使用条带传感器获取图像\t③使用传感器阵列获取图像\t\r\n\r\n​\t\t灰度级：[L~min~,L~max~]         L~min~<波长<L~max~\r\n\r\n### 4.图像取样和量化\r\n\r\n​\t\t对坐标值进行数字化称为==取样==，对幅度值数字化称为==量化==。\r\n\r\n​\t\t数字图像的质量很大程度上取决于==取样和量化中所用的样本数和灰度级==。\r\n\r\n​\t\tf(x,y)表示任意坐标处的值，其中x,y都是整数。由一幅图像的坐标张成的实平面部分称为空间域，x和y称为空间变量或空间坐标\r\n\r\n​\t\t当数字图像用矩阵表示时，矩阵中的每一个元素称为==像素==。\r\n\r\n​\t\t对于数字化过程，针对M值，N值和离散灰度级数L有，MN为正整数，L = 2^k^\r\n\r\n​\t\t对比度：一幅图像中最高和最低灰度级间的灰度差，即L-1\r\n\r\n​\t\t存储数字图像所需的比特数b为 b= M\\*N*k\r\n\r\n### 5.空间和灰度变化\r\n\r\n​\t\t空间分辨率：图像中可辨别的最小细节的度量。N\r\n\r\n​\t\t灰度分辨率：用于量化灰度的比特数。k\r\n\r\n​\t\t对于N更大的图像，可能只需要较小的k就可以有相等的主观判定质量\r\n\r\n### 6.图像内插\r\n\r\n​\t\t内插是在诸如放大、收缩、旋转和几何校正等任务中广泛应用的基本工具。\r\n\r\n​\t\t如将500X500像素的图像放大到750X750像素\r\n\r\n\t\t1. 最近邻内插法：将原图像中最近邻的灰度赋给每个新位置。\r\n\t\t1. 双线性内插法：用4个最近邻去估计给定位置的灰度。（结果更好，计算量更大）\r\n\t\t1. 双三次内插：包括16个最近邻点。\r\n\r\n### 7.像素间基本关系\r\n\r\n​\t\t4邻域N~4~(P)\r\n\r\n​\t\t对角邻域N~D~(P)\r\n\r\n​\t\t8邻域N~8~(P) = N~4~(P) + N~D~(P)\r\n\r\n​\t\t==邻接性==：①是否相邻\t②灰度值是否满足特定的相似性准则\r\n\r\n​\t\t4邻接：在4邻域中且满足相似性准则（灰度在V中）\r\n\r\n​\t\t8邻接：在8领域中且满足相似性准则（灰度在V中）\r\n\r\n​\t\tm邻接(混合邻接):满足下列条件之一：①在4邻域中②在对角邻域中,且p4邻域与q4邻域的交集中没有V中数值\r\n\r\n​\t\t==连通性==：从(x,y)到(x~n~,y~n~)，每下一步都是邻接的。\r\n\r\n### 8.距离度量\r\n\r\n​\t\t距离D，有①D(p,q) = D(q,p)\t②D(p,q) >= 0\t③D(p,z)<=D(p,q)+D(q,z)\r\n\r\n​\t\t1.欧式距离：$$D_E(p,q) = \\sqrt{(x-s)^2+(y-t)^2}$$\r\n\r\n​\t\t2.城市距离：$$D_4(p,q) = |x-s|+|y-t|$$\r\n\r\n​\t\t3.棋盘距离：$$D_8(p,q) = max(|x-s|,|y-t|)$$\r\n\r\n### 9.线性和非线性操作\r\n\r\n​\t\t 线性操作：对于H[f(x,y)] = g(x,y),若有H[af(x~1~,y~1~)+bf(x~2~,y~2~)] = ag(x~1~,y~1~)+bg(x~2~,y~2~)则H为**线性操作**\r\n\r\n### 10.图像像素操作\r\n\r\n​\t\t阵列操作：每一个像素进行操作\r\n\r\n​\t\t矩阵操作：对矩阵进行操作\r\n\r\n​\t\t图像间的算术操作是阵列操作\r\n\r\n### 11.集合和逻辑操作\r\n\r\n​\t\tA与B的并集为{max(a,b)}\r\n\r\n### 12.图像空间操作\r\n\r\n### 13.图像变换\r\n\r\n### 14.概率方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Chapter3灰度变换与空间滤波\r\n\r\n#### 3.1.1灰度变换和空间滤波基础\r\n\r\n​\t\t空间域处理表示：\r\n$$\r\ng(x,y) = T[f(x,y)]\r\n$$\r\n​\t\t==对于任意指定的位置(x,y),输出图像g在这些坐标处的值，等于对f中以(x,y)为原点的邻域应用算子T的结果==\r\n\r\n​\t\t边界处理：①用T做指定的计算时忽略外侧邻点\t②用0或其他指定灰度值填充图像边缘\t③被填充边界的厚度取决于邻域的大小\r\n\r\n#### 3.1.2对比度拉伸和阈值处理函数\r\n\r\n​\t\t对比度拉伸：将原图像对比度提高，低于K的灰度级更暗，高于K的灰度级更亮。\r\n\r\n​\t\t阈值处理函数：一幅两级图像，低于K的灰度级为0，高于K的灰度级为1.\r\n\r\n### 3.2一些基本的灰度变换函数\r\n\r\n​\t\t$$s = T(r)$$,其中T是把像素值r映射到像素值S的一种变换\r\n\r\n#### 3.2.1图像增强常用的三类基本函数\r\n\r\n​\t\t①线性函数\t②对数函数\t③幂律函数\r\n\r\n​\t\t图像反转变换：$$s = L-1-r$$\r\n\r\n​\t\t对数变换：$$s = c\\ log(1+r)$$ 其中c是一个常数      ==低灰度区扩展，高灰度区压缩==\r\n\r\n​\t\t幂律变换(伽马变换)：$$s = c\\ (r+\\varepsilon)^\\gamma$$     ① 指数<1：提高灰度级，使图象变亮\t②指数>1：降低灰度级，使\t\t图象变暗\t③指数=1：线性变换，灰度级不变\r\n\r\n#### 3.2.2灰度级分层\r\n\r\n​\t\t突出图像中特定灰度范围的亮度：消除背景细节/保留背景细节\r\n\r\n#### 3.2.3比特平面分层\r\n\r\n​\t\t最后两个比特平面，包含了在视觉上很重要的大多数数据。\r\n\r\n​\t\t重建一幅图像：==使用第n个平面的像素乘以2^n-1^常数来完成==\r\n\r\n​\t\t存储4个高阶平面将可以接收的细节来重建原图像 ，存储这4个平面代替原始图像可减少50%的存储量\r\n\r\n### 3.3直方图处理\r\n\r\n​\t\t数字图像的直方图是离散函数$$h(r_k) = n_k$$  ,其中 r~k~是第k级灰度值，n~k~是图像中灰度为r~k~的像素个数。\r\n\r\n​\t\t归一化直方图：$$p(r_k) = n_k/MN$$  ,通常MN是图像的行和列的维数。\r\n\r\n​\t\t归一化直方图的所有分量之和为1.\r\n\r\n​\t\t4种图像：暗图像：分量集中在灰度级的低端\r\n\r\n​\t\t\t\t\t\t  亮图像：分量集中在灰度级的高端\r\n\r\n​\t\t\t\t\t\t  低对比度图像：具有较窄的直方图，且集中在灰度级的中部\r\n\r\n​\t\t\t\t\t\t  高对比度图像：分量覆盖了很宽的灰度级范围，而且像素的分布较为均匀\r\n\r\n​\t\t直方图修正：通过灰度映射函数，将原灰度直方图改造成所希望的直方图。\t\t\r\n\r\n​\t\t直方图均衡化：通过对原始图像进行灰度非线性变换，将其直方图变成均匀分布。（图像增强）\r\n\r\n#### 3.3.1直方图均衡\r\n\r\n​\t\tT(r)单调递增，双向一一映射\r\n\r\n​\t\t$$p_s(s) = p_r(r)|\\frac{dr}{ds}| = \\frac{1}{L-1}$$ \r\n\r\n​\t\t$$s = T(r) = (L-1)\\int_0^r p_r(w)dw$$\r\n\r\n\r\n\r\n​\t\t离散形式：$$s_k = T(r_k) = (L-1)\\ \\Sigma p_r(r_j)$$\r\n\r\n\r\n\r\n\r\n\r\n直方图规定化：修改一幅图像的直方图，使得它与另一幅图像的直方图匹配或具有一种预先规定的函数形状。\r\n\r\n\r\n\r\n#### 3.3.3局部直方图处理\r\n\r\n#### 3.3.4均值方差\r\n\r\n均值  $$m = \\Sigma^m_0r_ip(r_i) = \\frac{1}{MN}\\ \\Sigma^M_0\\Sigma^N_0f(x,y)$$\r\n\r\n方差  $$\\sigma^2 = \\frac{1}{MN}\\ \\Sigma^M_0\\Sigma^N_0[f(x,y)-m]^2$$\r\n\r\n\r\n\r\n\r\n\r\n### 3.4空间滤波\r\n\r\n在图像中任意一点滤波器的响应是滤波器系数与由该滤波器包围的图像像素的乘积之和\r\n\r\n$$g(x,y) = w(-1,-1)f(x-1,y-1)+w(-1,0)f(x-1,y)+...+w(0,0)f(x,y)+...+w(1,1)f(x+1,y+1)$$\r\n\r\n\r\n\r\n相关：滤波器模板移过图像并计算每个位置乘积之和的处理\r\n\r\n卷积：滤波器首先选旋转80°，然后滤波器模板移过图像并计算每个位置乘积之和的处理\r\n\r\n\r\n\r\n相关是滤波器位移的函数，相关的第一个值对应滤波器的零位移，第二个值对应一个位移单元，……\r\n\r\n滤波器w与包含全部0和单个1的函数相关，得到的结果是w的一个副本，但旋转了180°\r\n\r\n离散单位冲激：包含单个1而其余都是0的函数\r\n\r\n相关：$$w(x,y)*f(x,y) = \\Sigma\\Sigma \\ w(s,t)f(x+s,y+t)$$\r\n\r\n卷积：$$w(x,y)*f(x,y) = \\Sigma\\Sigma \\ w(s,t)f(x-s,y-t)$$\r\n\r\n\r\n\r\n#### 3.4.4空间滤波模板\r\n\r\n均值滤波器：w=1/9\r\n\r\n高斯滤波器：$$w(x,y) = e^\\frac{x^2+y^2}{-2\\sigma^2}$$\r\n\r\n加权滤波器：中心点最高权重，然后随中心点距离的增加而减小\r\n\r\n\r\n\r\n#### 3.5.2中值滤波器\r\n\r\n将像素邻域内灰度的中值代替该像素的值（去噪，模糊程度低）\r\n\r\n主要功能：使不同灰度的点看起来更接近于它的相邻点\r\n\r\n椒盐噪声（脉冲噪声）\r\n\r\n==中值滤波比均值滤波更适合去除椒盐噪声==\r\n\r\n\r\n\r\n### 3.6锐化空间滤波器\r\n\r\n锐化处理的主要目的：突出灰度的过渡部分\r\n\r\n==图像微分会增强边缘和其他突变（如噪声），而削弱灰度变化平缓的区域==\r\n\r\n各向同性滤波器：滤波器的响应与滤波器作用的图像的突变反向无关\r\n\r\n拉普拉斯算子$$\\Delta^2f(x,y) = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$\r\n\r\n#### 3.6.3非锐化遮掩\r\n\r\n从原图像中减去一幅非锐化版本\r\n\r\n①模糊原图像\t②从原图像中减去模糊图像\t③将模板加到原图像上\r\n\r\n**Sobel算子**：-1 -2 -1  0 0 0 1 2 1     \r\n\r\nReborts算子  ： -1 0 0 1  0 -1 1 0\r\n\r\n\r\n\r\n## Chapter4频率域滤波\r\n\r\n\r\n\r\n## Chapter6彩色图像处理\r\n\r\n\r\n\r\n## Chapter9形态学图像处理",
        "timemini": ""
    },
    {
        "index": 19,
        "title": "数据结构与算法",
        "essay": "##Chapter1 线性结构\r\n\r\n#####复杂度\r\nO(1)  常数\r\nO(log(n))  对数\r\nO(n)  线性\r\nO(nlog(n))  线性和对数乘积\r\nO(n^2^)  平方\r\nO(2^n^)  指数\r\n\r\n:earth_asia: 仅保留最高项，且去除系数\r\n\r\n###1.1 数组\r\n1. 数组的扩容：16 -> 18，先申请一个大小翻倍的数组，然后将原来的元素依次复制到新数组中，再向里面添加新元素，然后将多余空间释放掉（性能比较低）\r\n2. 数组在前面插入(删除)元素：元素位移，将原有的元素一个个向后移，再将新元素插入到最前面，在中间或最前面插入和删除元素性能非常低\r\n3. 查找数据(index) O(1)\r\n\r\n\r\n###1.2 栈stack\r\n一种受限的线性表，==后进先出==\r\n仅允许在表的一端进行插入和删除操作，这一端被称为==栈顶==，另一端称为栈底\r\n进栈，入栈，压栈\r\n出栈，退栈\r\n\r\n函数的调用栈：基于栈的调用方式\r\n封装栈结构（基于数组）\r\n\r\n###1.3 队列\r\n一种受限的线性表，==先进先出==\r\n仅允许在表的一端(前端/队首)进行删除，另一端(后端/队尾)进行插入操作\r\n\r\n事件队列\r\n\r\n####优先级队列\r\n- 每个元素具有优先级，插入时会根据优先级放入正确的位置\r\n\r\n###1.4 链表\r\n数组的内存需要是连续的空间\r\n而链表的元素在内存中不必是连续的\r\n链表不必在创建时就确定大小，并且大小可以无限延申下去\r\n链表在插入和删除数据时，时间复杂度可以达到O(1)，相对数组效率高很多\r\n==链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(指针)组成==\r\n链表访问任何一个元素时都需要从头开始访问，无法通过下标值直接访问元素\r\n\r\n####双向链表\r\n- 单向链表：只能从头到尾遍历，链表相连的过程是单向的\r\n- 双向链表：既可以从头到尾，也可以从尾到头，缺点是插入和删除时需要处理四个引用，占用内存空间更大\r\n\r\n\r\n\r\n##Chapter2 哈希表\r\n###2.1 哈希表理论\r\n\r\n####集合\r\n- 无序，不重复\r\n- Set类就是集合类\r\n\r\n#####集合间操作\r\n######交集\r\n######并集\r\n######差集\r\n######子集\r\n\r\n####字典\r\n- 一一对应，键值对，键不可重复值可以重复，键无序\r\n\r\n####哈希表\r\n- 数组在进行插入删除的操作时，效率低下（基于索引查询效率高基于内容查找效率低）\r\n- 通过对数组进行变化，得到了哈希表\r\n- 哈希表的优点：快速增删查，时间复杂度O(1)，速度比树还快，编码比树容易\r\n- 哈希表相对于数组的不足：没有顺序，key不能重复\r\n- 它的==结构就是数组==，神奇之处在于对==下标值的一种变换==，这种变化称为==哈希函数==，通过哈希函数可以获取到==HashCode==\r\n\r\n==**将字符串转成下标值**==\r\n\r\n编码方式：ASCII UTF-8\r\n\r\n#####哈希化\r\n一种压缩方法，将幂的连乘压缩到可接受的数组范围中\r\n压缩方法：取余操作\r\n哈希化：将大数字转化成数组范围下标的过程\r\n哈希函数：单词->大数字->哈希化\r\n\r\n#####冲突\r\n下标值可能会重复,这种情况就叫做冲突\r\n冲突不可避免,我们只能解决冲突\r\n解决冲突的两种方案:1.链地址法(拉链法),开放地址法\r\n\r\n######链地址法(拉链法)\r\n数组内每个单元存储的都是链表/数组而非简单的元素,查询时先根据哈希化的下标值取出链表再依次查询找寻数据\r\n新数据用的更多则使用链表,新数据使用更少则使用数组更好\r\n\r\n######开放地址法\r\n寻找空白的位置来放置冲突的数据项\r\n寻找空白位置的方法:\r\n1. 线性探测 \r\n- 查询时查到空格即返回\r\n- 删除时不能设置为null(-1)\r\n2. 二次探测 \r\n- 对探测时的步长进行优化,(线性探测即步长为1),x+1^2^,x+2^2^,x+3^2^...\r\n- 避免聚集带来的影响\r\n3. 再哈希法\r\n- 把关键字用另一个哈希函数,再做一次哈希化,结果作为步长\r\n- 第二次哈希化不能与第一次哈希函数相同,且结果不能为0\r\n- stepSize = const - (key%const)\r\n\r\n\r\n#####填装因子\r\n填装因子 = 总数据项/哈希表长度\r\n开放地址法最大为1\r\n链地址法最大为∞\r\n填装因子越大,查询需要的平均次数会呈指数增长\r\n因此,用链地址法更多\r\n\r\n#####优秀的哈希函数\r\n1. 快速的计算(减少乘除法)\r\n- 霍纳法则(秦九韶算法) (...(((a~n~x+a~n-1~)x+a~n-2~)x+a~n-3~)x+...+a~1~)x+a~0~\r\n2. 均匀的分布\r\n- 在使用常量的地方,尽可能使用质数(哈希表的长度,幂计算的底数)\r\n\r\n#####哈希表的扩容\r\n- 随着LoadFactor增大,效率会不断降低\r\n- 因此要在合适的时候对哈希表进行扩容,如扩容两倍\r\n\r\n######如何扩容?\r\n- 简单扩容:将容量扩大两倍\r\n- 一旦扩容,所有数据需要重新插入,获取\r\n- 通常情况下,当LoadFactor大于0.75时就进行扩容\r\n\r\n扩容实现:\r\n1. 建一个oldStorage\r\n2. 让oldStorage指向this.storage\r\n3. 让this.storage指向新的Storage\r\n\r\n\r\n#####容量质数\r\n实现容量恒为质数\r\n扩容时,将容量\\*2,然后+1直到新的容量为质数\r\n\r\n\r\n\r\n##Chapter3 树结构\r\n###3.1 树相关概念\r\n- 树：n个节点构成的有限集合（当n=0时，称为==空树==）\r\n- 根（Root)：用r表示\r\n- 其余节点可分为m个互不相交的有限集，称为原来树的子树(SubTree)\r\n- 节点的度(Degree)：节点的子树个数\r\n- 树的度：树的所有节点的度中最大的度\r\n- 叶节点：度为0的节点\r\n- 父节点、子节点\r\n- 兄弟节点：具有相同父节点的节点\r\n- 路径和路径长度：路径所包含边的个数就是路径长度\r\n- 节点的层次：规定根节点所在的层次为1，依次增加\r\n- 树的深度：最大节点的层次\r\n\r\n\r\n\r\n儿子-兄弟表示法：Data,leftSon,Brother   => 二叉树\r\n###3.2 二叉搜索树\r\n- 二叉树：每一个节点最多有两个子节点的树\r\n- 空树，仅有根节点，仅有左子节点，仅有右子节点，具有两个子节点\r\n- 一个二叉树第i层最大节点数：2^i-1^\r\n- 深度为k的二叉树最大节点总数2^k^-1\r\n- 对于任何非空树，度为2的节点数+1=叶节点数\r\n- 完美二叉树：满二叉树（除叶节点外所有节点都有2个子节点）\r\n- 完全二叉树：\r\n\t- 除二叉树最后一层外，其他各层节点数都达最大。\r\n\t- 最后一层左侧叶节点连续存在，只缺右侧若干节点。\r\n  \r\n-  二叉搜索树：(BST,Binary Search Tree)\r\n  BST的性质：可以为空，但不为空时非空左子树所有键值小于根节点的键值，非空右子树所有键值大于根节点的键值\r\n  **二分查找的思想**\r\n  查找所需最大次数等于树的深度\r\n  插入节点时也是一层层比较大小，找到新节点合适的位置\r\n####二叉树的表示方式\r\n1. 使用数组：完全二叉树好存储也好使用，但非完全二叉树需要转化成完全二叉树\r\n2. **链表表示**：每个节点封装成一个Node,Node包含存储的数据，左右子节点的引用\r\n###3.3 树的遍历\r\n\r\n```js\r\n //遍历二叉搜索树\r\n    //先序遍历（根节点=>左子树=>右子树）\r\n    preOrderTraversal = function(handler) {\r\n            this.preOrderTraversalNode(this.root, handler)\r\n        }\r\n        //先序遍历依赖的函数\r\n    preOrderTraversalNode = function(node, handler) {\r\n        if (node != null) {\r\n            //处理经过的节点\r\n            handler(node.key)\r\n                //处理经过节点的左子节点\r\n            this.preOrderTraversalNode(node.left, handler)\r\n                //处理经过节点的右子节点\r\n            this.preOrderTraversalNode(node.right, handler)\r\n        }\r\n    }\r\n\r\n    //中序遍历（左子树=>根节点=>右子树）\r\n    midOrderTraversal = function(handler) {\r\n            this.midOrderTraversalNode(this.root, handler)\r\n        }\r\n        //中序遍历依赖的函数\r\n    midOrderTraversalNode = function(node, handler) {\r\n        if (node != null) {\r\n            //处理经过节点的左子节点\r\n            this.midOrderTraversalNode(node.left, handler)\r\n                //处理经过的节点\r\n            handler(node.key)\r\n                //处理经过节点的右子节点\r\n            this.midOrderTraversalNode(node.right, handler)\r\n        }\r\n    }\r\n\r\n    //后序遍历（左子树=>右子树=>根节点）\r\n    postOrderTraversal = function(handler) {\r\n            this.postOrderTraversalNode(this.root, handler)\r\n        }\r\n        //后序遍历依赖的函数\r\n    postOrderTraversalNode = function(node, handler) {\r\n        if (node != null) {\r\n            //处理经过节点的左子节点\r\n            this.postOrderTraversalNode(node.left, handler)\r\n                //处理经过节点的右子节点\r\n            this.postOrderTraversalNode(node.right, handler)\r\n                //处理经过的节点\r\n            handler(node.key)\r\n        }\r\n    }\r\n\r\n    //搜索最大值和最小值\r\n    max() {\r\n        let node = this.root\r\n            //依次向右寻找直到节点为null\r\n        while (node != null && node.right != null) {\r\n            node = node.right\r\n        }\r\n        return node.key\r\n    }\r\n    min() {\r\n        let node = this.root\r\n            //依次向左寻找直到节点为null\r\n        while (node != null && node.left != null) {\r\n            node = node.left\r\n        }\r\n        return node.key\r\n    }\r\n\r\n    //搜索特定key\r\n    search(key) {\r\n            return this.searchNode(this.root, key)\r\n        }\r\n        //搜索依赖的函数\r\n    searchNode(node, key) {\r\n        if (node == null) {\r\n            return false\r\n        }\r\n        if (node.key > key) {\r\n            return this.searchNode(node.left, key)\r\n        } else if (node.key < key) {\r\n            return this.searchNode(node.right, key)\r\n        } else {\r\n            return true\r\n        }\r\n    }\r\n\r\n```\r\n\r\n###3.4 二叉搜索树的删除\r\n```js\r\n//删除节点\r\n    remove(key) {\r\n        //1. 寻找要删除的节点\r\n        let current = this.root\r\n        let parent = null\r\n        let isLeft = true\r\n        while (current.key != key) {\r\n            parent = current\r\n            if (key < current.key) {\r\n                current = current.left\r\n                isLeft = true\r\n            } else if (key > node.key) {\r\n                current = current.right\r\n                isLeft = false\r\n            }\r\n            //若没有找到目标节点\r\n            if (current == null) {\r\n                return false\r\n            }\r\n        }\r\n\r\n        //删除目标节点\r\n        //1. 目标节点没有子节点\r\n        if (current.left == null && current.right == null) {\r\n            //若目标节点同时也是根节点\r\n            if (current == this.root) {\r\n                this.root = null\r\n            } else {\r\n                if (isLeft) {\r\n                    parent.left = null\r\n                } else {\r\n                    parent.right = null\r\n                }\r\n            }\r\n        }\r\n\r\n        //2. 目标节点有一个子节点\r\n        else if (current.right == null && current.left != null) {\r\n            //若目标节点同时也是根节点\r\n            if (current == this.root) {\r\n                this.root = current.left\r\n            } else {\r\n                if (isLeft) {\r\n                    parent.left = current.left\r\n                } else {\r\n                    parent.right = current.left\r\n                }\r\n            }\r\n        } else if (current.left == null && current.right != null) {\r\n            //若目标节点同时也是根节点\r\n            if (current == this.root) {\r\n                this.root = current.right\r\n            } else {\r\n                if (isLeft) {\r\n                    parent.left = current.right\r\n                } else {\r\n                    parent.right = current.right\r\n                }\r\n            }\r\n        }\r\n\r\n        //3. 目标节点有两个子节点\r\n        //若用左子树里的节点替代被删的，则用左子树里最大的；若用右子树里的节点替代被删的，则用右子树里最小的。\r\n    }\r\n```\r\n###3.5 二叉树的补充\r\n#### 红黑树\r\n除了符合二叉搜索树的基本规则外\r\n- 节点是红/黑色\r\n- 根节点是黑色\r\n- 叶节点是黑色的空节点\r\n- 每个红色节点的两个子节点都是黑色\r\n- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点\r\n##Chapter4 图结构\r\n###4.1 图相关概念\r\n###4.2 图的表示\r\n###4.3 自定义图\r\n###4.4 图的遍历\r\n##Chapter5 排序&搜索\r\n###5.1 简单排序\r\n###5.2 高级排序\r\n\r\n#### 快速排序\r\n\r\n- 大多数情况下是最快的排序，也是最优的排序\r\n\r\n- 冒泡排序的升级版，分而治之的思想\r\n\r\n左指针，右指针，枢纽\r\n\r\n左指针向右依次寻找比枢纽大的，然后停下\r\n\r\n右指针向左依次寻找比枢纽小的，然后停下\r\n\r\n然后交换两个指针指向的值\r\n\r\n直到两个指针重叠，交换枢纽与指针指向的值\r\n\r\n枢纽的选择：头中尾的中位数\r\n\r\n```js\r\nfunction quick(arr) {\r\n    if (arr.length <= 1) return arr\r\n    let center = Math.floor(arr.length / 2)\r\n    let pivot = arr.splice(center, 1)[0]\r\n    let left = []\r\n    let right = []\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (arr[i] < pivot) {\r\n            left.push(arr[i])\r\n        } else {\r\n            right.push(arr[i])\r\n        }\r\n    }\r\n    return quick(left).concat([pivot], quick(right))\r\n}\r\n\r\nlet arr = [10, 376, 4, 278, 38, 16, 890, 26, 46]\r\nconsole.log(quick(arr));\r\n```\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 20,
        "title": "深入css",
        "essay": "\r\n**这是我参与「第四届青训营 」笔记创作活动的的第2天**\r\n<hr/>\r\n\r\n#### 继承\r\n\r\n某些属性会自动继承其父元素的*计算值*，除非显式指定一个值\r\n\r\n#### 显式继承\r\n## 初始值\r\n\r\n-   CSS 中，每个属性都有一个初始值\r\n\r\n    -   background-color 的初始值为 transparent\r\n    -   margin-left 的初始值为 0\r\n\r\n-   可以使用 initial 关键字显式重置为初始值\r\n\r\n    -   background-color: initial\r\n    \r\n### 布局相关技术\r\n- 常规流：行级  块级  表格布局  FlexBox  Grid 布局\r\n- 浮动   \r\n- 绝对定位\r\n### width\r\n\r\n-   指定 content box 宽度\r\n-   取值为长度、百分数、auto\r\n-   auto 由浏览器根据其它属性确定\r\n-   百分数相对于容器的 content box 宽度\r\n### height\r\n\r\n-   指定 content box 高度\r\n-   取值为长度、百分数、auto\r\n-   auto 取值由内容计算得来\r\n-   百分数相对于容器的 content box 高度\r\n-   容器有指定的高度时，百分数才生效\r\n### padding\r\n\r\n-   指定元素四个方向的内边距\r\n-   百分数相对于容器宽度\r\n### border\r\n\r\n-   指定容器边框样式、粗细和颜色 none solid dotted dashed\r\n### border\r\n\r\n-   三种属性\r\n\r\n    -   border-width\r\n    -   border-style\r\n    -   border-color\r\n\r\n-   四个方向\r\n\r\n    -   border-top\r\n    -   boder-right\r\n    -   border-bottom\r\n    -   border-left\r\n### margin\r\n\r\n-   指定元素四个方向的外边距\r\n-   取值可以是长度、百分数、auto\r\n-   百分数相对于容器宽度\r\n\r\n    ```margin:auto水平居中```\r\n### margin collapse\r\n### box-sizing: border-box\r\n### overflow：visiblehiddenscroll\r\n## 块级 vs. 行级\r\n\r\n| Block Level Box | Inline Level Box     |\r\n| --------------- | -------------------- |\r\n| 不和其它盒子并列摆放      | 和其它行级盒子一起放在一行或拆开成多行  |\r\n| 适用所有的盒模型属性      | 盒模型中的width、height不适用\r\n块级元素                                         | 行级元素                  |\r\n| 生成块级盒子                                       | - 生成行级盒子 - 内容分散在多个行盒 (line box) 中 |\r\n| body、article、div、main、section、h1-6、p、ul、li 等 | span、em、strong、cite、code 等        |\r\n| display: block                               | display: inline\r\n\r\n## display 属性\r\n\r\n| block        | 块级盒子                                |\r\n| ------------ | ----------------------------------- |\r\n| inline       | 行级盒子                                |\r\n| inline-block | 本身是行级，可以放在行盒中；可以设置宽高；作为一个整体不会被拆散成多行 |\r\n| none         | 排版时完全被忽略\r\n\r\n## 常规流 Normal Flow\r\n\r\n-   根元素、浮动和绝对定位的元素会脱离常规流\r\n-   其它元素都在常规流之内（in-flow）\r\n-   常规流中的盒子，在某种排版上下文中参与布局\r\n\r\n行级排版上下文\r\n\r\n块级排版上下文\r\n\r\nTable 排版上下文\r\n\r\nFlex 排版上下文\r\n\r\nGrid 排版上下文\r\n## 行级排版上下文\r\n\r\n-   Inline Formatting Context (IFC)\r\n\r\n-   只包含行级盒子的容器会创建一个IFC\r\n\r\n-   IFC 内的排版规则\r\n\r\n    -   盒子在一行内水平摆放\r\n    -   一行放不下时，换行显示\r\n    -   text-align 决定一行内盒子的水平对齐\r\n    -   vertical-align 决定一个盒子在行内的垂直对齐\r\n    -   避开浮动(float)元素*\r\n    ## 块级排版上下文\r\n\r\n-   Block Formatting Context (BFC)\r\n\r\n-   某些容器会创建一个BFC\r\n\r\n    -   根元素\r\n    -   浮动、绝对定位、inline-block\r\n    -   Flex子项和Grid子项\r\n    -   overflow 值不是 visible 的块盒\r\n    -   display: flow-root;\r\n## 块级排版上下文\r\n\r\n-   Block Formatting Context (BFC)\r\n\r\n-   某些容器会创建一个BFC\r\n\r\n    -   根元素\r\n    -   浮动、绝对定位、inline-block\r\n    -   Flex子项和Grid子项\r\n    -   overflow 值不是 visible 的块盒\r\n    -   display: flow-root;\r\n## Flex Box\r\n\r\n-   一种新的排版上下文\r\n\r\n-   它可以控制子级盒子的：\r\n\r\n    -   摆放的流向 ( → ← ↑ ↓ )\r\n    -   摆放顺序\r\n    -   盒子宽度和高度\r\n    -   水平和垂直方向的对齐\r\n    -   是否允许折行\r\n## flex-direction\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dca2e1067f545ad982aabca45afac06~tplv-k3u1fbpfcp-zoom-1.image)\r\n## 主轴与侧轴\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79c8f8453c984725a2f8c3caafaab44f~tplv-k3u1fbpfcp-zoom-1.image)\r\n## justify-content\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efbf33b86344405e914c54c8764a4263~tplv-k3u1fbpfcp-zoom-1.image)\r\n## align-items\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b08e5d36178b472087e1eca8c34adf03~tplv-k3u1fbpfcp-zoom-1.image)\r\n## align-self\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c019099ec3d84cf2a65e982b963ffbed~tplv-k3u1fbpfcp-zoom-1.image)\r\n## align-self\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79930f8947154692b86f55c3278f8f66~tplv-k3u1fbpfcp-zoom-1.image)\r\n## Flexibility\r\n\r\n-   可以设置子项的弹性：当容器有剩余空间时，会伸展；容器空间不够时，会收缩。\r\n-   flex-grow 有剩余空间时的伸展能力\r\n-   flex-shrink 容器空间不足时收缩的能力\r\n-   flex-basis 没有伸展或收缩时的基础长度\r\n## flex-grow\r\n## flex-shrink\r\n## flex\r\n\r\n| flex: 1         | flex-grow: 1                                    |\r\n| --------------- | ----------------------------------------------- |\r\n| flex: 100px     | flex-basis: 100px                               |\r\n| flex: 2 1       | flex-grow: 2; flex-shrink: 1                    |\r\n| flex: 1 100px   | flex-grow: 1; flex-basis: 100px                 |\r\n| flex: 2 0 100px | flex-grow: 2; flex-shrink: 0; flex-basis: 100px |\r\n| flex: auto      | flex: 1 1 auto                                  |\r\n| flex: none      | flex: 0 0 auto\r\n## Grid 布局？\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de9d22608fb46be873441f2f6bbd541~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4282e826ea549a09b67261996f22c97~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nFlex Box\r\n\r\nGrid\r\n## display: grid\r\n-   display: grid 使元素生成一个块级的 Grid 容器\r\n\r\n<!---->\r\n\r\n-   使用 grid-template 相关属性将容器划分为网格\r\n\r\n<!---->\r\n\r\n-   设置每一个子项占哪些行/列\r\n## 划分网格\r\n```html\r\ngrid-template-columns: 100px 100px 200px;\r\ngrid-template-rows: 100px 100px\r\n```\r\n## grid line 网格线\r\n## grid area 网格区域\r\n## float浮动\r\n## position属性\r\n\r\n|static  |默认值，非定位元素                |\r\n| -------| --------------------------------|\r\n|relative|相对自身原本位置偏移，不脱离文档流  |\r\n|absolute|绝对定位，相对非static祖先元素定位 |\r\n|fixed   |相对于视口绝对定位                |\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 21,
        "title": "深入学习CSS",
        "essay": "## 1.HTML\r\n\r\n#### :earth_asia:实体(转义字符)\r\n在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格\r\n在HTML中有些时候，我们不能直接书写一些特殊符号\r\n比如：多个连续的空格，比如字母两侧的大于和小于号\r\n如果我们需要在网页中书写这些特殊的符号，则需要使用html中的实体（转义字符）\r\n实体的语法：&实体的名字;\r\n- \\&nbsp; 空格\r\n\r\n- \\&gt; 大于号\r\n\r\n- \\&lt; 小于号\r\n\r\n- \\&copy; 版权符号\r\n\r\n#### :earth_asia:meta标签\r\nmeta主要用于设置网页中的一些元数据，元数据不是给用户看\r\n- charset 指定网页的字符集\r\n- name 指定的数据的名称\r\n- content 指定的数据的内容\r\n- keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\r\n```html\r\n<meta name=\"Keywords\" content=\"网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东\"/>\r\n<meta name=\"keywords\" content=\"网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon\">\r\n```\r\n- description 用于指定网站的描述\r\n```html\r\n<meta name=\"description\" content=\"京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!\"/>\r\n```\r\n网站的描述会显示在搜索引擎的搜索的结果中\r\n- title标签的内容会作为搜索结果的超链接上的文字显示    \r\n\r\n`<meta http-equiv=\"refresh\" content=\"3;url=https://www.mozilla.org\"> `\r\n 将页面重定向到另一个网站\r\n\r\n\r\n\r\n### 1.1语义化标签\r\n在网页中HTML专门用来负责网页的结构\r\n所以在使用html标签时，应该关注的是标签的语义，而不是它的样式\r\n在页面中独占一行的元素称为==块元素（block element）==\r\n在页面中不会独占一行的元素称为==行内元素（inline element）==\r\n\r\n\r\n- 标题标签：\r\n  h1 ~ h6 一共有六级标题\r\n  从h1~h6重要性递减，h1最重要，h6最不重要\r\n  一般情况下标题标签只会使用到h1~h3，h4~h6很少用\r\n  标题标签都是块元素\r\n- hgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup\r\n- p标签表示页面中的一个段落，p也是一个块元素\r\n- em标签用于表示语音语调的一个加重\r\n- strong表示强调，重要内容！\r\n- blockquote 表示一个长引用\r\n-  q表示一个短引用\r\n\r\n==块元素（block element）==\r\n\r\n-  在网页中一般通过块元素来对页面进行布局\r\n\r\n==行内元素（inline element）==\r\n\r\n-  行内元素主要用来包裹文字\r\n\r\n- 一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素\r\n- 块元素中基本上什么都能放\r\n- p元素中不能放任何的块元素\r\n\r\n浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正\r\n比如：\r\n标签写在了根元素的外部\r\np元素中嵌套了块元素\r\n根元素中出现了除head和body以外的子元素\r\n... ...\r\n\r\n\r\n\r\n- header 表示网页的头部\r\n- main 表示网页的主体部分(一个页面中只会有一个main)\r\n- footer 表示网页的底部\r\n- nav 表示网页中的导航\r\n- aside 和主体相关的其他内容（侧边栏）\r\n- article 表示一个独立的文章\r\n- section 表示一个独立的区块，上边的标签都不能表示时使用section\r\n\r\n- ==div== 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\r\n- ==span== 行内元素，没有任何的语义，一般用于在网页中选中文字\r\n\r\n### 1.2列表\r\n在html中也可以创建列表，html列表一共有三种：\r\n1、有序列表\r\n2、无序列表\r\n3、定义列表\r\n\r\n有序列表，使用ol标签来创建无序列表\r\n使用li表示列表项  \r\n        \r\n无序列表，使用ul标签来创建无序列表\r\n使用li表示列表项\r\n\r\n定义列表，使用dl标签来创建一个定义列表\r\n使用dt来表示定义的内容\r\n使用dd来对内容进行解释说明\r\n\r\n列表之间可以互相嵌套\r\n\r\n### 1.3超链接a\r\n超链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置\r\n\r\n使用 a 标签来定义超链接\r\n属性：\r\nhref 指定跳转的目标路径\r\n\r\n- 值可以是一个外部网站的地址\r\n- 也可以写一个内部页面的地址\r\n\r\ntarget属性，用来指定超链接打开的位置\r\n可选值：\r\n- \\_self 默认值 在当前页面中打开超链接\r\n- \\_blank 在一个新的页面中打开超链接\r\n\r\n超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素\r\n在开发中可以将#作为超链接的路径的展位符使用\r\n可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生 \r\n\r\n可以直接将超链接的href属性设置为#，这样点击超链接以后\r\n页面不会发生跳转，而是转到当前页面的顶部的位置\r\n可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值\r\n\r\nid属性（唯一不重复的）\r\n\r\n- 每一个标签都可以添加一个id属性\r\n- id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性 \r\n\r\n### 1.4图片标签\r\n图片标签用于向当前页面中引入一个外部图片\r\n使用img标签来引入外部图片，img标签是一个自结束标签\r\nimg这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）\r\n属性：\r\nsrc 属性指定的是外部图片的路径（路径规则和超链接是一样的）\r\n\r\nalt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示\r\n搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录\r\n\r\nwidth 图片的宽度 (单位是像素)\r\nheight 图片的高度    \r\n- 宽度和高度中如果只修改了一个，则另一个会等比例缩放\r\n\r\n注意：\r\n一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大\r\n但是在移动端，经常需要对图片进行缩放（大图缩小）\r\n\r\n\r\n图片的格式：\r\npeg(jpg)\r\n- 支持的颜色比较丰富，不支持透明效果，不支持动图\r\n- 一般用来显示照片\r\n\r\ngif\r\n- 支持的颜色比较少，支持简单透明，支持动图\r\n- 颜色单一的图片，动图\r\n\r\npng\r\n- 支持的颜色丰富，支持复杂透明，不支持动图\r\n- 颜色丰富，复杂透明图片（专为网页而生）\r\n\r\nwebp\r\n- 这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式\r\n- 它具备其他图片格式的所有优点，而且文件还特别的小\r\n- 缺点：兼容性不好\r\n\r\nbase64 \r\n- 将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片    \r\n- 一般都是一些需要和网页一起加载的图片才会使用base64\r\n\r\n效果一样，用小的\r\n效果不一样，用效果好的\r\n\r\n### 1.5内联框架与音视频\r\n内联框架，用于向当前页面中引入一个其他页面\r\nsrc 指定要引入的网页的路径\r\nframeborder 指定内联框架的边框\r\naudio 标签用来向页面中引入一个外部的音频文件的\r\n音视频文件引入时，默认情况下不允许用户自己控制播放停止\r\n\r\n属性：\r\ncontrols 是否允许用户控制播放\r\nautoplay 音频文件是否自动播放\r\n- 如果设置了autoplay 则音乐在打开页面时会自动播放，但是目前来讲大部分浏览器都不会自动对音乐进行播放 \r\n\r\nloop 音乐是否循环播放  \r\n\r\n\r\n\r\n使用video标签来向网页中引入一个视频\r\n\r\n- 使用方式和audio基本上是一样的\r\n\r\n\r\n\r\n## 2.CSS简介\r\n网页分成三个部分：\r\n结构(HTML)\r\n表现(CSS)\r\n行为(JavaScript)\r\n\r\nCSS\r\n- 层叠样式表\r\n- 网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式\r\n而最终我们能看到只是网页的最上边一层\r\n- 总之一句话，CSS用来设置网页中元素的样式 \r\n\r\n使用CSS来修改元素的样式\r\n1. 内联样式，行内样式\r\n- 在标签内部通过style属性来设置元素的样式\r\n- 问题：\r\n\t- 使用内联样式，样式只能对一个标签生效，\r\n\t- 如果希望影响到多个元素必须在每一个元素中都复制一遍\r\n\t- 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便\r\n\r\n- 注意：开发时绝对不要使用内联样式\r\n\r\n2. 内部样式表\r\n- 将样式编写到head中的style标签里\r\n然后通过CSS的选择器来选中元素并为其设置各种样式\r\n可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用\r\n- 内部样式表更加方便对样式进行复用\r\n- 问题：\r\n- 我们的内部样式表只能对一个网页起作用，\r\n- 它里边的样式不能跨页面进行复用\r\n\r\n3. 外部样式表（ 最佳实践）\r\n- 可以将CSS样式编写到一个外部的CSS文件中,\r\n然后通过link标签来引入外部的CSS文件\r\n- 外部样式表需要通过link标签进行引入，\r\n意味着只要想使用这些样式的网页都可以对其进行引用\r\n使样式可以在不同页面之间进行复用\r\n- 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，\r\n从而加快网页的加载速度，提高用户的体验。\r\n\r\n### 2.1CSS的基本语法\r\nCSS的基本语法:选择器 声明块\r\n\r\n选择器，通过选择器可以选中页面中的指定元素\r\n比如 p 的作用就是选中页面中所有的p元素\r\n\r\n声明块，通过声明块来指定要为元素设置的样式\r\n声明块由一个一个的声明组成\r\n声明是一个名值对结构\r\n一个样式名对应一个样式值，名和值之间以:连接，以;结尾  \r\n\r\n### 2.2选择器\r\n####1. 元素选择器\r\n作用：根据标签名来选中指定的元素\r\n语法：标签名{}\r\n例子：p{}  h1{}  div{}\r\n\r\n#### 2. id选择器\r\n作用：根据元素的id属性值选中一个元素\r\n语法：#id属性值{}\r\n例子：#box{} #red{}  \r\n\r\n#### 3. 类选择器\r\n作用：根据元素的class属性值选中一组元素\r\n语法：.class属性值\r\n\r\n#### 4. 通配选择器\r\n作用：选中页面中的所有元素\r\n语法: *\r\n\r\n#### 5. 交集选择器\r\n作用：选中同时符合多个条件的元素\r\n语法：选择器1选择器2选择器3选择器n{}\r\n注意点：\r\n交集选择器中如果有元素选择器，必须使用元素选择器开头\r\n\r\n#### 6. 选择器分组（并集选择器）\r\n作用：同时选择多个选择器对应的元素\r\n语法：选择器1,选择器2,选择器3,选择器n{}\r\n\\#b1,.p1,h1,span,div.red{}\r\n\r\n#### 7. 关系选择器\r\n\r\n子元素选择器\r\n作用：选中指定父元素的指定子元素\r\n语法：父元素 > 子元素\r\n后代元素选择器：\r\n作用：选中指定元素内的指定后代元素\r\n语法：祖先 后代\r\n选择下一个兄弟\r\n语法：前一个 + 下一个\r\n选择下边所有的兄弟\r\n语法：兄 ~ 弟\r\n\r\n#### 8. 属性选择器\r\n[属性名] 选择含有指定属性的元素\r\n[属性名=属性值] 选择含有指定属性和属性值的元素\r\n[属性名^=属性值] 选择属性值以指定值开头的元素\r\n[属性名$=属性值] 选择属性值以指定值结尾的元素\r\n[属性名\\*=属性值] 选择属性值中含有某值的元素的元素\r\n\r\n#### 9. 伪类选择器\r\n伪类（不存在的类，特殊的类）\r\n- 伪类用来描述一个元素的特殊状态\r\n比如：第一个子元素、被点击的元素、鼠标移入的元素...\r\n- 伪类一般情况下都是使用:开头\r\n\r\n:first-child 第一个子元素\r\n:last-child 最后一个子元素\r\n:nth-child() 选中第n个子元素\r\n特殊值：\r\nn 第n个 n的范围0到正无穷\r\n2n 或 even 表示选中偶数位的元素\r\n2n+1 或 odd 表示选中奇数位的元素\r\n\r\n- 以上这些伪类都是根据所有的子元素进行排序\r\n\r\n:first-of-type\r\n:last-of-type\r\n:nth-of-type()\r\n- 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\r\n\r\n:not() 否定伪类\r\n- 将符合条件的元素从选择器中去除\r\n\r\n:hover 用来表示鼠标移入的状态\r\n:active 用来表示鼠标点击\r\n\r\n##### a标签的伪类\r\n:link 用来表示没访问过的链接（正常的链接）\r\n:visited 用来表示访问过的链接\r\n由于隐私的原因，所以visited这个伪类只能修改链接的颜色\r\n\r\n\r\n#### 10. 伪元素选择器\r\n伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）\r\n伪元素使用 :: 开头\r\n\r\n::first-letter 表示第一个字母\r\n::first-line 表示第一行\r\n::selection 表示选中的内容\r\n::before 元素的开始 \r\n::after 元素的最后\r\n- before 和 after 必须结合content属性来使用\r\n\r\n### 3.样式的继承\r\n我们为一个元素设置的样式同时也会应用到它的后代元素上\r\n继承是发生在祖先后后代之间的\r\n继承的设计是为了方便我们的开发，\r\n利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，\r\n这样只需设置一次即可让所有的元素都具有该样式\r\n注意：并不是所有的样式都会被继承：\r\n比如 背景相关的，布局相关等的这些样式都不会被继承。\r\n\r\n\r\n### 4. 样式的权重\r\n样式的冲突\r\n- 当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。\r\n\r\n发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定\r\n\r\n选择器的权重\r\n内联样式         1000\r\nid选择器         100\r\n类和伪类选择器    10\r\n元素选择器        1\r\n通配选择器        0\r\n继承的样式       没有优先级\r\n\r\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）,\r\n选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器（不能跨数量级）\r\n如果优先级计算后相同，此时则优先使用靠下的样式\r\n\r\n可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，\r\n注意：在开发中这个玩意一定要慎用！\r\n\r\n\r\n\r\n### 5. 单位\r\n长度单位：\r\n像素\r\n- 屏幕（显示器）实际上是由一个一个的小点点构成的\r\n- 不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰\r\n- 所以同样的200px在不同的设备下显示效果不一样\r\n\r\n百分比\r\n- 也可以将属性值设置为相对于其父元素属性的百分比\r\n- 设置百分比可以使子元素跟随父元素的改变而改变\r\n\r\nem\r\n- em是相对于元素的字体大小来计算的\r\n- 1em = 1font-size\r\n- em会根据字体大小的改变而改变\r\n\r\nrem\r\n- rem是相对于根元素的字体大小来计算\r\n\r\n颜色单位：\r\n在CSS中可以直接使用颜色名来设置各种颜色\r\n比如：red、orange、yellow、blue、green ... ...\r\n但是在css中直接使用颜色名是非常的不方便\r\n\r\nRGB值：\r\n- RGB通过三种颜色的不同浓度来调配出不同的颜色\r\n- R red，G green ，B blue\r\n- 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\r\n- 语法：RGB(红色,绿色,蓝色)\r\n\r\nRGBA:\r\n- 就是在rgb的基础上增加了一个a表示不透明度\r\n- 需要四个值，前三个和rgb一样，第四个表示不透明度\r\n1表示完全不透明   0表示完全透明  .5半透明\r\n\r\n十六进制的RGB值：\r\n- 语法：#红色绿色蓝色\r\n- 颜色浓度通过 00-ff\r\n- 如果颜色两位两位重复可以进行简写  \r\n  \\#aabbcc --> #abc\r\n                    \r\n\r\nHSL值 HSLA值\r\nH 色相(0 - 360)\r\nS 饱和度，颜色的浓度 0% - 100%\r\nL 亮度，颜色的亮度 0% - 100%\r\n\r\n\r\n\r\n\r\n\r\n## 3.Layout\r\n\r\n### 1.文档流\r\n文档流（normal flow）\r\n- 网页是一个多层的结构，一层摞着一层\r\n- 通过CSS可以分别为每一层来设置样式\r\n- 作为用户来讲只能看到最顶上一层\r\n- 这些层中，最底下的一层称为文档流，文档流是网页的基础\r\n\r\n我们所创建的元素默认都是在文档流中进行排列\r\n- 对于我们来元素主要有两个状态\r\n在文档流中\r\n不在文档流中（脱离文档流）\r\n\r\n- 元素在文档流中有什么特点：\r\n\t- 块元素\r\n\t\t- 块元素会在页面中独占一行(自上向下垂直排列)\r\n\t\t- 默认宽度是父元素的全部（会把父元素撑满）\r\n\t\t- 默认高度是被内容撑开（子元素）\r\n\r\n\t- 行内元素\r\n\t\t- 行内元素不会独占页面的一行，只占自身的大小\r\n\t\t- 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素\r\n\t\t则元素会换到第二行继续自左向右排列（书写习惯一致）\r\n\t\t- 行内元素的默认宽度和高度都是被内容撑开\r\n\r\n### 2.盒模型\r\n盒模型、盒子模型、框模型（box model）\r\n- CSS将页面中的所有元素都设置为了一个矩形的盒子\r\n- 将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置\r\n- 每一个盒子都由一下几个部分组成：\r\n内容区（content）\r\n内边距（padding）\r\n边框（border）\r\n外边距（margin）\r\n\r\n内容区（content）\r\n- 元素中的所有的子元素和文本内容都在内容区中排列  \r\n- 内容区的大小由width 和 height两个属性来设置\r\n- width 设置内容区的宽度\r\n- height 设置内容区的高度    \r\n\r\n边框（border）\r\n- 边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部\r\n- 边框的大小会影响到整个盒子的大小\r\n- 要设置边框，需要至少设置三个样式：\r\n\t- 边框的宽度 border-width\r\n\t- 边框的颜色 border-color\r\n\t- 边框的样式 border-style\r\n\r\n- border-width: 10px; \r\n  默认值，一般都是 3个像素\r\n  border-width可以用来指定四个方向的边框的宽度\r\n  值的情况\r\n  四个值：上 右 下 左\r\n  三个值：上  左右  下\r\n  两个值：上下  左右\r\n  一个值：上下左右\r\n                    \r\n\r\n除了border-width还有一组 border-xxx-width\r\nxxx可以是 top right bottom left\r\n用来单独指定某一个边的宽度\r\n\r\n\r\n\r\n- border-style 指定边框的样式\r\n\r\n\t- solid 表示实线\r\n\t\r\n\t- dotted 点状虚线\r\n\t\r\n\t- dashed 虚线\r\n\t\r\n\t- double 双线\r\n\t\r\n\t- border-style的默认值是none 表示没有边框\r\n\t\r\n\t  \r\n\r\n- border简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求\r\n除了border以外还有四个 border-xxx\r\nborder-top、border-right、border-bottom、border-left\r\n\r\n内边距（padding）\r\n- 内容区和边框之间的距离是内边距\r\n\r\n- 一共有四个方向的内边距：\r\npadding-top/right/bottom/left\r\n\r\n- 内边距的设置会影响到盒子的大小\r\n\r\n- 背景颜色会延伸到内边距上\r\n\r\n- padding 内边距的简写属性，可以同时指定四个方向的内边距\r\n\r\n  规则和border-width 一样\r\n\r\n一共盒子的可见框的大小，由内容区 内边距 和 边框共同决定，\r\n所以在计算盒子大小时，需要将这三个区域加到一起计算\r\n\r\n\r\n\r\n外边距（margin）\r\n- 外边距不会影响盒子可见框的大小\r\n- 但是外边距会影响盒子的位置\r\n- 一共有四个方向的外边距：\r\nmargin-top\r\n- 上外边距，设置一个正值，元素会向下移动\r\n\r\nmargin-right\r\n- 默认情况下设置margin-right不会产生任何效果\r\n\r\nmargin-bottom\r\n- 下外边距，设置一个正值，其下边的元素会向下移动\r\n\r\nmargin-left\r\n- 左外边距，设置一个正值，元素会向右移动\r\n\r\nmargin也可以设置负值，如果是负值则元素会向相反的方向移动\r\n- 元素在页面中是按照自左向右的顺序排列的，\r\n所以默认情况下如果我们设置的左和上外边距则会移动元素自身\r\n而设置下和右外边距会移动其他元素\r\n- margin的简写属性\r\n  margin 可以同时设置四个方向的外边距 ，用法和padding一样\r\n- margin会影响到盒子实际占用空间\r\n\r\n\r\n\r\n### 3.水平布局\r\n七个值中有三个值可设置为auto：width、margin-left、 maring-right\r\n- 如果某个值为auto，则会自动调整为auto的那个值以使等式成立\r\n- 如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0\r\n- 如果将三个值都设置为auto，则外边距都是0，宽度最大\r\n- 如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值\r\n所以我们经常利用这个特点来使一个元素在其父元素中水平居中\r\n示例：\r\nwidth:xxxpx;\r\nmargin:0 auto;上下外边距为0，左右外边距为auto，即水平居中\r\n\r\n### 4.垂直布局\r\n子元素是在父元素的内容区中排列的，\r\n如果子元素的大小超过了父元素，则子元素会从父元素中溢出\r\n使用 overflow 属性来设置父元素如何处理溢出的子元素\r\n\r\n可选值：\r\nvisible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\r\nhidden 溢出内容将会被裁剪不会显示\r\nscroll 生成两个滚动条，通过滚动条来查看完整的内容\r\nauto 根据需要生成滚动条\r\n\r\noverflow-x: \r\noverflow-y:\r\n\r\n\r\n\r\n### 5. 垂直外边距的重叠（折叠）\r\n- 相邻的垂直方向外边距会发生重叠现象\r\n- 兄弟元素\r\n\t- 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值）\r\n\t- 特殊情况：\r\n\t如果相邻的外边距一正一负，则取两者的和\r\n\t如果相邻的外边距都是负值，则取两者中绝对值较大的\r\n\r\n\t- 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理\r\n\r\n\r\n- 父子元素,坑爹Hhhhhh\r\n\t- 父子元素间相邻外边距，子元素的会传递给父元素（上外边距）\r\n\t- 父子外边距的折叠会影响到页面的布局，必须要进行处理\r\n\t\r\n\t\r\n### 6.行内元素的盒模型\r\n- 行内元素不支持设置宽度和高度,内容的大小由内容决定\r\n- 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局\r\n- 行内元素可以设置border，垂直方向的border不会影响页面的布局\r\n- 行内元素可以设置margin，垂直方向的margin不会影响布局\r\n\r\ndisplay 用来设置元素显示的类型\r\n可选值：\r\ninline 将元素设置为行内元素\r\nblock 将元素设置为块元素\r\ninline-block 将元素设置为行内块元素 （行内块，既可以设置宽度和高度又不会独占一行）\r\ntable 将元素设置为一个表格\r\nnone 元素不在页面中显示\r\n\r\nvisibility 用来设置元素的显示状态\r\n可选值：\r\nvisible 默认值，元素在页面中正常显示\r\nhidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\r\n\r\n### 7.  盒子尺寸\r\n默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定\r\nbox-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）\r\n可选值：\r\ncontent-box \r\n- 默认值，宽度和高度用来设置内容区的大小\r\n\r\nborder-box \r\n- 宽度和高度用来设置整个盒子可见框的大小，width 和 height 指的是内容区 和 内边距 和 边框的总大小\r\n\r\n### 8.轮廓和圆角\r\nbox-shadow 用来设置元素的阴影效果，阴影不会影响页面布局 \r\n第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\r\n第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\r\n第三个值 阴影的模糊半径\r\n第四个值 阴影的颜色\r\nbox-shadow: 0px 0px 50px rgba(0, 0, 0, .3) ; \r\n\r\n- outline 用来设置元素的轮廓线，用法和border一模一样\r\n  轮廓和边框不同的点，就是轮廓不会影响到可见框的大小  \r\n\r\n  \r\n\r\nborder-radius: 用来设置圆角 圆角设置的圆的半径大小\r\n\r\nborder-top-left-radius: \r\nborder-top-right-radius \r\nborder-bottom-left-radius:\r\nborder-bottom-right-radius: \r\nborder-top-left-radius:50px 100px;  x方向半径 y方向半径\r\n\r\nborder-radius 可以分别指定四个角的圆角\r\n四个值 左上 右上 右下 左下\r\n三个值 左上 右上/左下 右下 \r\n两个个值 左上/右下 右上/左下  \r\n\r\nborder-radius: 20px / 40px;  设置四个方向都是椭圆形\r\n\r\n将元素设置为一个圆形：border-radius: 50%;\r\n\r\n\r\n\r\n\r\n\r\n## 4. float\r\n### 1.简介\r\n通过浮动可以使一个元素向其父元素的左侧或右侧移动\r\n使用 float 属性来设置于元素的浮动\r\n可选值：\r\n- none 默认值 ，元素不浮动\r\n- left 元素向左浮动\r\n- right 元素向右浮动\r\n\r\n注意，元素设置浮动以后，水平布局的等式便不需要强制成立\r\n元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，\r\n所以元素下边的还在文档流中的元素会自动向上移动\r\n\r\n\r\n### 2. 浮动的特点\r\n\r\n浮动的特点：\r\n1、浮动元素会完全脱离文档流，不再占据文档流中的位置\r\n2、设置浮动以后元素会向父元素的左侧或右侧移动，\r\n3、浮动元素默认不会从父元素中移出\r\n4、浮动元素向左或向右移动时，**不会超过它前边的其他浮动元素**\r\n5、==如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移==\r\n6、**浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高**\r\n\r\n简单总结：浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局  \r\n\r\n其他特点：\r\n- 浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，\r\n所以我们可以利用浮动来设置文字环绕图片的效果\r\n- 元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化\r\n\r\n脱离文档流的特点：\r\n块元素：\r\n1、块元素不再独占页面的一行\r\n2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\r\n\r\n行内元素：\r\n行内元素脱离文档流以后会变成块元素，特点和块元素一样\r\n\r\n脱离文档流以后，不需要再区分块和行内了\r\n\r\n### 3.高度塌陷\r\n高度塌陷的问题：\r\n在浮动布局中，父元素的高度默认是被子元素撑开的，\r\n当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离\r\n将会无法撑起父元素的高度，导致父元素的高度丢失\r\n\r\n父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱\r\n\r\n所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须要进行处理！\r\n\r\n### 4. BFC\r\nBFC(Block Formatting Context) 块级格式化环境\r\n- BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC\r\n开启BFC该元素会变成一个独立的布局区域\r\n- 元素开启BFC后的特点：\r\n1.开启BFC的元素不会被浮动元素所覆盖\r\n2.开启BFC的元素子元素和父元素外边距不会重叠\r\n3.开启BFC的元素可以包含浮动的子元素\r\n\r\n- 可以通过一些特殊方式来开启元素的BFC：\r\n\t1、设置元素的浮动（不推荐）\r\n\t2、将元素设置为行内块元素（不推荐）\r\n\t3、将元素的overflow设置为一个非visible的值\r\n\t-  常用的方式 为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素\r\n\r\n\r\n\r\n### 5.清除浮动\r\n由于box1的浮动，导致box3位置上移\r\n也就是box3收到了box1浮动的影响，位置发生了改变\r\n\r\n如果我们不希望某个元素因为其他元素浮动的影响而改变位置，\r\n可以通过clear属性来清除浮动元素对当前元素所产生的影响\r\n\r\nclear\r\n- 作用：清除浮动元素对当前元素所产生的影响\r\n- 可选值：\r\nleft 清除左侧浮动元素对当前元素的影响\r\nright 清除右侧浮动元素对当前元素的影响\r\nboth 清除两侧中最大影响的那侧\r\n\r\n原理：\r\n设置清除浮动以后，浏览器会自动为元素添加一个上外边距，\r\n以使其位置不受其他元素的影响\r\n\r\n### 6. clearfix类\r\n/\\* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 \\*/\r\n\r\n```css\r\n.clearfix::before,\r\n.clearfix::after {\r\n\tcontent: '';\r\n\tdisplay: table;\r\n\tclear: both;\r\n}\r\n```\r\n\r\n## 5.Position\r\n### 1.定位的简介\r\n定位（position）\r\n- 定位是一种更加高级的布局手段\r\n- 通过定位可以将元素摆放到页面的任意位置\r\n- 使用position属性来设置定位\r\n可选值：\r\nstatic 默认值，元素是静止的没有开启定位\r\nrelative 开启元素的相对定位\r\nabsolute 开启元素的绝对定位\r\nfixed 开启元素的固定定位\r\nsticky 开启元素的粘滞定位\r\n\r\n- 偏移量（offset）\r\n- 当元素开启了定位以后，可以通过偏移量来设置元素的位置\r\n\r\ntop\r\n- 定位元素和定位位置上边的距离\r\n\r\nbottom\r\n- 定位元素和定位位置下边的距离\r\n- 定位元素垂直方向的位置由top和bottom两个属性来控制\r\n通常情况下我们只会使用其中一\r\n\r\n- top值越大，定位元素越向下移动\r\n- bottom值越大，定位元素越向上移动\r\n\r\nleft\r\n- 定位元素和定位位置的左侧距离\r\n\r\nright\r\n- 定位元素和定位位置的右侧距离\r\n- 定位元素水平方向的位置由left和right两个属性控制\r\n\r\n通常情况下只会使用一个\r\n- left越大元素越靠右\r\n- right越大元素越靠左\r\n\r\n\r\n### 2.相对定位\r\n- 相对定位：相对与元素在文档流里原始的位置\r\n- 当元素的position属性值设置为relative时则开启了元素的相对定位\r\n- 相对定位的特点：\r\n1.元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\r\n2.相对定位是参照于元素在文档流中的位置进行定位的\r\n3.相对定位会提升元素的层级\r\n4.相对定位==不会使元素脱离文档流==\r\n5.相对定位==不会改变元素的性质==，块还是块，行内还是行内\r\n\r\n\r\n### 3.绝对定位\r\n绝对定位\r\n- 当元素的position属性值设置为absolute时，则开启了元素的绝对定位\r\n- 绝对定位的特点：\r\n1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\r\n2.开启绝对定位后，元素会==从文档流中脱离==\r\n3.绝对定位==会改变元素的性质==，行内变成块，块的宽高被内容撑开\r\n4.绝对定位会使元素提升一个层级\r\n5.绝对定位元素是==相对于其包含块进行定位的==\r\n\r\n包含块( containing block )\r\n- 正常情况下：\r\n包含块就是离当前元素最近的祖先块元素\r\n\r\n\r\n- 绝对定位的包含块:\r\n包含块就是离它最近的开启了定位的祖先元素，\r\n如果所有的祖先元素都没有开启定位则根元素就是它的包含块\r\n\r\n- html（根元素、初始包含块）\r\n\r\n### 4.固定定位\r\n固定定位：\r\n- 将元素的position属性设置为fixed则开启了元素的固定定位\r\n- 固定定位==也是一种绝对定位==，所以固定定位的大部分特点都和绝对定位一样\r\n唯一不同的是固定定位永远参照于浏览器的视口进行定位\r\n固定定位的元素不会随网页的滚动条滚动\r\n\r\n\r\n### 5.粘滞定位\r\n粘滞定位\r\n- 当元素的position属性设置为sticky时则开启了元素的粘滞定位\r\n-  粘滞定位和相对定位的特点基本一致，\r\n不同的是粘滞定位可以在元素到达某个位置时将其固定\r\n\r\n### 6. 元素居中的一个方法\r\n当我们开启了绝对定位后:\r\n布局等式就需要添加left 和 right 两个值\r\n此时规则和之前一样只是多添加了两个值：\r\n当发生过度约束：\r\n如果9个值中没有 auto 则自动调整right值以使等式满足\r\n如果有auto，则自动调整auto的值以使等式满足\r\n\r\n- 可设置auto的值\r\nmargin width left right\r\n\r\n- 因为left 和 right的值默认是auto，所以如果不指定left和right\r\n则等式不满足时，会自动调整这两个值\r\n\r\n这是==元素居中==的一个方法\r\n\r\n### 7.元素的层级\r\n对于开启了定位元素，可以通过z-index属性来指定元素的层级\r\nz-index需要一个整数作为参数，值越大元素的层级越高\r\n元素的层级越高越优先显示\r\n\r\n如果元素的层级一样，则优先显示靠下的元素\r\n\r\n祖先的元素的层级再高也不会盖住后代元素\r\n\r\n\r\n\r\n## 6.flex\r\n### 1.flex弹性盒的简介\r\n flex(弹性盒、伸缩盒)\r\n- 是CSS中的又一种布局手段，它主要用来代替浮动来完成页面的布局\r\n- flex可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变\r\n\r\n\r\n### 2.弹性容器\r\n- 弹性容器\r\n\t- 要使用弹性盒，必须先将一个元素设置为弹性容器\r\n\t- 我们通过 display 来设置弹性容器\r\n\tdisplay:flex  设置为块级弹性容器\r\n\tdisplay:inline-flex 设置为行内的弹性容器\r\n\r\nflex-direction 指定容器中弹性元素的排列方式\r\n可选值：\r\n- row 默认值，弹性元素在容器中水平排列（左向右）\r\n主轴 自左向右\r\n- row-reverse 弹性元素在容器中反向水平排列（右向左）\r\n主轴 自右向左\r\n- column 弹性元素纵向排列（自上向下）\r\n- column-reverse 弹性元素方向纵向排列（自下向上）\r\n\r\n主轴：弹性元素的排列方向称为主轴\r\n侧轴：与主轴垂直方向的称为侧轴\r\n\r\nflex-wrap: \r\n设置弹性元素是否在弹性容器中自动换行\r\n可选值：\r\nnowrap 默认值，元素不会自动换行\r\nwrap 元素沿着辅轴方向自动换行\r\nwrap-reverse 元素沿着辅轴反方向换行\r\n\r\njustify-content\r\n- 如何分配主轴上的空白空间（主轴上的元素如何排列）\r\n- 可选值：\r\nflex-start 元素沿着主轴起边排列\r\nflex-end 元素沿着主轴终边排列\r\ncenter 元素居中排列\r\nspace-around 空白分布到元素两侧\r\nspace-between 空白均匀分布到元素间\r\nspace-evenly 空白分布到元素的单侧\r\n\r\nalign-items: \r\n- 元素在辅轴上如何对齐\r\n- 元素间的关系\r\n- 可选值：\r\n\tstretch 默认值，将元素的长度设置为相同的值\r\n\tflex-start 元素不会拉伸，沿着辅轴起边对齐\r\n\tflex-end 沿着辅轴的终边对齐\r\n\tcenter 居中对齐\r\n\tbaseline 基线对齐\r\n\r\n### 3.弹性元素\r\n- 弹性元素\r\n\t- 弹性容器的子元素是弹性元素（弹性项）\r\n\t- 弹性元素可以同时是弹性容器\r\n\r\n弹性元素的属性：\r\n- flex-grow 指定弹性元素的伸展的系数\r\n当父元素有多余空间的时，子元素如何伸展\r\n父元素的剩余空间，会按照比例进行分配\r\n\r\n- flex-shrink 指定弹性元素的收缩系数\r\n当父元素中的空间不足以容纳所有的子元素时，如果对子元素进行收缩\r\n\r\n- flex-basis 指定的是元素在主轴上的基础长度\r\n如果主轴是 横向的 则 该值指定的就是元素的宽度\r\n如果主轴是 纵向的 则 该值指定的是就是元素的高度\r\n- 默认值是 auto，表示参考元素自身的高度或宽度\r\n- 如果传递了一个具体的数值，则以该值为准\r\n\r\nflex 可以设置弹性元素所有的三个样式\r\nflex ：增长 缩减 基础;\r\ninitial \"flex: 0 1 auto\".\r\nauto  \"flex: 1 1 auto\"\r\nnone \"flex: 0 0 auto\" 弹性元素没有弹性\r\n\r\norder 决定弹性元素的排列顺序\r\n\r\n\r\n## 7.font\r\n### 1.字体相关的样式 \r\ncolor 用来设置字体颜色\r\nfont-size 字体的大小\r\n和font-size相关的单位\r\nem 相当于当前元素的一个font-size\r\nrem 相对于根元素的一个font-size\r\n\r\nfont-family 字体族（字体的格式）\r\n可选值：\r\nserif  衬线字体\r\nsans-serif 非衬线字体\r\nmonospace 等宽字体\r\n指定字体的类别，浏览器会自动使用该类别下的字体\r\n\r\nfont-weight 字重 字体的加粗 \r\n可选值：\r\nnormal 默认值 不加粗\r\nbold 加粗\r\n100-900 九个级别（没什么用）\r\n\r\nfont-style 字体的风格\r\nnormal 正常的\r\nitalic 斜体\r\n\r\n- font-family 可以同时指定多个字体，多个字体间使用,隔开\r\n字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推\r\n\r\n\r\n### 2.图标字体\r\n图标字体（iconfont）\r\n- 在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大小本身比较大，并且非常的不灵活\r\n- 所以在使用图标时，我们还可以将图标直接设置为字体，\r\n然后通过font-face的形式来对字体进行引入\r\n- 这样我们就可以通过使用字体的形式来使用图标\r\n\r\nfontawesome 使用步骤\r\n1.下载 https://fontawesome.com/\r\n2.解压\r\n3.将css和webfonts移动到项目中\r\n4.将all.css引入到网页中\r\n5.使用图标字体\r\n- 直接通过类名来使用图标字体\r\nclass=\"fas fa-bell\"\r\nclass=\"fab fa-accessible-icon\"\r\n\r\n通过伪元素来设置图标字体\r\n1.找到要设置图标的元素通过before或after选中\r\n2.在content中设置字体的编码\r\n3.设置字体的样式\r\nfab\r\nfont-family: 'Font Awesome 5 Brands';\r\n\r\nfas\r\nfont-family: 'Font Awesome 5 Free';\r\nfont-weight: 900; \r\n\r\n### 3.行高\r\n行高（line height）\r\n- 行高指的是文字占有的实际高度\r\n- 可以通过line-height来设置行高\r\n行高可以直接指定一个大小（px em）\r\n也可以直接为行高设置一个整数\r\n如果是一个整数的话，行高将会是字体的指定的倍数\r\n- 行高经常还用来设置文字的行间距\r\n行间距 = 行高 - 字体大小\r\n\r\n字体框\r\n- 字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度\r\n\r\n行高会在字体框的上下平均分配\r\n\r\n==可以将行高设置为和高度一样的值，使单行文字在一个元素中**垂直居中**==\r\n\r\n\r\n\r\n\r\nfont 可以设置字体相关的所有属性\r\n语法：font: 字体大小/行高 字体族\r\n行高 可以省略不写 如果不写使用默认值\r\n\r\n### 4.文本的样式\r\ntext-align 文本的水平对齐\r\n可选值：\r\nleft 左侧对齐\r\nright 右对齐\r\ncenter 居中对齐\r\njustify 两端对齐\r\n\r\nvertical-align 设置元素垂直对齐的方式\r\n可选值：\r\nbaseline 默认值 基线对齐\r\ntop 顶部对齐\r\nbottom 底部对齐\r\nmiddle 居中对齐\r\n\r\ntext-decoration 设置文本修饰\r\n可选值：\r\nnone 什么都没有\r\nunderline 下划线\r\nline-through 删除线\r\noverline 上划线\r\n\r\nwhite-space 设置网页如何处理空白\r\n可选值：\r\nnormal 正常\r\nnowrap 不换行\r\npre 保留空白\r\n\r\n==设置多余文字用省略号显示==\r\n```css\r\nwhite-space: nowrap;\r\noverflow: hidden;\r\ntext-overflow: ellipsis;\r\n```\r\n\r\n\r\n## 8.background\r\n### 1.背景\r\nbackground-color 设置背景颜色\r\nbackground-color: #bfa;\r\n\r\nbackground-image 设置背景图片 \r\n- 可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色\r\n- 如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满\r\n- 如果背景的图片大于元素，将会一个部分背景无法完全显示\r\n- 如果背景图片和元素一样大，则会直接正常显示\r\n                    \r\n\r\nbackground-image: url(\"./img/1.png\");\r\n\r\nbackground-repeat 用来设置背景的重复方式\r\n可选值：\r\nrepeat 默认值 ， 背景会沿着x轴 y轴双方向重复\r\nrepeat-x 沿着x轴方向重复\r\nrepeat-y 沿着y轴方向重复\r\nno-repeat 背景图片不重复\r\n\r\nbackground-size 设置背景图片的大小\r\n第一个值表示宽度 \r\n第二个值表示高度\r\n- 如果只写一个，则第二个值默认是 auto\r\n\r\ncover 图片的比例不变，将元素铺满\r\ncontain 图片比例不变，将图片在元素中完整显示\r\n\r\nbackground-position 用来设置背景图片的位置\r\n设置方式：通过 top left right bottom center 几个表示方位的词来设置背景图片的位置\r\n使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center\r\n\r\n通过偏移量来指定背景图片的位置：水平方向的偏移量 垂直方向变量\r\n\r\n设置背景的范围 \r\nbackground-clip \r\n可选值：\r\nborder-box 默认值，背景会出现在边框的下边\r\npadding-box 背景不会出现在边框，只出现在内容区和内边距\r\ncontent-box 背景只会出现在内容区\r\n\r\nbackground-origin 背景图片的偏移量计算的原点\r\npadding-box 默认值，background-position从内边距处开始计算\r\ncontent-box 背景图片的偏移量从内容区处计算\r\nborder-box 背景图片的偏移量从边框处开始计算\r\n\r\nbackgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置\r\n并且该样式没有顺序要求，也没有哪个属性是必须写的\r\n\r\n注意：\r\nbackground-size必须写在background-position的后边，并且使用/隔开\r\nbackground-position/background-size\r\n\r\nbackground-origin background-clip 两个样式 ，orgin要在clip的前边\r\n\r\n###2.渐变\r\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果\r\n==渐变是图片，需要通过background-image来设置==\r\n\r\n线性渐变，颜色沿着一条直线发生变化\r\nlinear-gradient()\r\nlinear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域\r\n- 线性渐变的开头，我们可以指定一个渐变的方向\r\nto left\r\nto right\r\nto bottom\r\nto top\r\ndeg deg表示度数\r\nturn 表示圈  1turn=360deg  0.5turn=180deg\r\n\r\n- 渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，\r\n也可以手动指定渐变的分布情况\r\n\r\nrepeating-linear-gradient() 可以平铺的线性渐变\r\n\r\nbackground-image: repeating-linear-gradient(to right ,red, yellow 50px);\r\n\r\n\r\nradial-gradient() 径向渐变(放射性的效果) \r\n\r\n默认情况下径向渐变的形状根据元素的形状来计算的\r\n正方形 --> 圆形\r\n长方形 --> 椭圆形\r\n我们也可以手动指定径向渐变的大小\r\ncircle\r\nellipse\r\n\r\n- 也可以指定渐变的位置\r\n- 语法：\r\nradial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)\r\n大小：\r\n- circle 圆形\r\n- ellipse 椭圆\r\n- closest-side 近边\t\r\n- closest-corner 近角\r\n- farthest-side 远边\r\n- farthest-corner 远角\r\n\r\n位置：top right left center bottom\r\n                                \r\nbackground-image: radial-gradient(farthest-corner at 100px 100px, red , #bfa)\r\n\r\n\r\n## 9.animation\r\n\r\n\r\n## 10.table&form\r\n\r\n## 11.css语法补充\r\n\r\n### 1. 设置变量\r\ncss原生也支持变量的设置 \r\n```css\r\n/*设置变量*/\r\n--color: #ff0;\r\n--length: 200px;\r\n/*使用变量*/\r\nwidth: var(--length);\r\nheight: var(--length);\r\ncolor: var(--color);\r\n```\r\n\r\n### 2. 计算函数\r\ncalc()计算函数\r\n==数字与符号之间一定要加**空格**==\r\n```css\r\ncalc(200px * 2);\r\ncalc(100% - 50px)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 22,
        "title": "深入学习JavaScript",
        "essay": "\r\n# JavaScript基础\r\n\r\n前端验证，更多功能\r\n-ECMAJavascript\r\n-DOM\r\n-BOM\r\n\r\nJS的特点：\r\n\t-解释型语言\r\n\t-类似C与java\r\n\t-动态语言\r\n\t-基于原型的==面向对象==\r\n\r\n\r\n\r\n## Chapter1基本语法\r\n\r\n\r\n\r\n### 1.1基本规则\r\n\r\n1.JS 中严格区分大小写\r\n2.JS中每一条语句以分号结尾，\r\n\t如果不写分号，浏览器可能会自动添加，可能还会出错\r\n3.JS会忽略多个空格和换行\r\n\r\n\r\n\r\n### 1.2字面量和变量\r\n\r\n字面量（常量）：不可改变的值，可以直接使用，但一般不会直接使用\r\n变量：用于保存字面量的值，可以通过变量对字面量进行描述\r\n声明变量：\r\n\t\t在js中使用==var关键字==声明变量\r\n\t\tvar a;\r\n\t\ta = 123;\r\n标识符：在JS中所有可自主命名的都称为标识符\r\n\t\t如变量名，函数名，属性名\r\n\t\t命名一个标识符时要遵循以下规则：\r\n\t\t\t==1==.标识符可以含字母、数字、_ 、$\r\n\t\t\t==2==.不能以数字开头\r\n\t\t\t==3==.不能是ES中的关键字或保留字\r\n\t\t\t4.标识符一般采用==驼峰命名法==：首字母小写，每个单词开头字母大写\r\n\t\tJS底层保存标识符时，实际上采用的是Unicode编码。\r\n\r\n\r\n\r\n### 1.3数据类型\r\n\r\n#### 1.3.1  String字符串\r\n\r\n需要用引号引起来\r\n\teg: var str=\"hello\";\r\n\t使用单引号或双引号都可以，但不能混用\r\n\t不能嵌套使用，但可以单引号套双引号，双引号套单引号\r\n\t在字符串中可使用\\作为转义字符表示特殊字符\r\n\t\\n——换行\r\n\t\\t——tab\r\n\t\\\\\\——\\\r\n\t\\\\'——'\r\n\t\\\\\"——\"\r\n\r\n#### 1.3.2  Number数值\r\n\r\n包括整数和浮点数\r\n可以使用运算符==typeof==来检查变量的类型\r\n\t\t语法：typeof 变量（检查infinity和NaN也会返回number)\r\nNumber.MAX_VALUE表示最大值\r\nNumber.MIN_VALUE表示最小正值\r\nInfinity表示正无穷\r\nNaN 表示Not a Number\r\n整数的运算基本可保证准确，但如果进行==浮点数运算==可能得到一个不精确的结果\r\n\t\t因此不要使用JS进行精确度要求高的运算\r\n\r\n#### 1.3.3  Boolean布尔值\r\n\r\n布尔值只有两个：true false\r\n使用typeof检查时返回 boolean\r\n\r\n#### 1.3.4  Null空值\r\n\r\nNull类型的值只有一个: null\r\n专门用于表示一个为空的对象\r\n使用typeof检查时返回==object==\r\n\r\n#### 1.3.5  Undefined未定义值\r\n\r\nUndefined类型的值只有一个:undefined\r\n当声明一个变量但没有赋值时,它的值就是undefined\r\n使用typeof检查时返回undefined\r\n\r\n#### 1.3.6强制类型转换\r\n\r\n将一个数据类型转换成其他数据类型, 主要是转换成String Number Boolean\r\n\r\n\r\n1.转换成String\r\n```\r\n\t\t方式一:调用被转换数据类型的toString()方法\r\n\t\t\teg: var b = a.toString();\r\n\t\t\t该方法不会影响到原变量,即a仍是原数据类型,b才是字符串类型\r\n\t\t\tAttention:null和undefined没有toString()方法\r\n\t\t方式二:调用String()函数,并将被转换的数据作为参数传递\r\n\t\t\teg:a = String(a);\r\n\t\t\t使用String()函数做强制类型转换时\r\n\t\t\t\t对于Number和Boolean实际上就是调用tostring()方法\r\n\t\t\t\t对于null和undifined会直接将null转换为\"null\",将undifined转换为\"undifined\"\r\n```\r\n2.转换为Number\r\n```\r\n\t\t方式一: 使用Number() 函数\r\n\t\t\teg:a = Number(a);\r\n\t\t\t字符串-->数字:1.如果是纯数字,直接转换为数字\r\n\t\t\t\t\t\t2.如果字符串中有非数字,转换为NaN\r\n\t\t\t\t\t\t3.如果字符串是空串或全为空格,转换为0\r\n\t\t\t布尔型-->数字:true转换为1;false转换为0\r\n\t\t\tnull-->数字:0\r\n\t\t\tundifined-->数字:NaN\r\n\t\t方式二:使用parseInt()函数,将a转换为Number\r\n\t\t\teg:a = 1213px; a = parseInt(a); \r\n\t\t\t可以将一个字符串中有效的整数内容取出来,然后转换为Number\r\n\t\t\tparseFloat()函数与parseint()函数相同,但可以取出浮点数\r\n\t\t\t如果对非String使用会对其先转换为String然后再操作\r\n\t\t其他进制的数字:\r\n\t\t\t16进制:var a = 0x123;以0x开头\r\n\t\t\t8进制:var a = 070;以0开头\r\n\t\t\t2进制:var a = 0b10;以0b开头(兼容性不好)\r\n\t\t\ta = parseInt(a,10);指定转换为10进制\r\n```\r\n3.转换为Boolean\r\n```\r\n\t\t方式一:使用Boolean()函数\r\n\t\t\tnumber-->boolean:除了0和NaN,其余都是true\r\n\t\t\tstring-->boolean:除了空串,其余都是true\r\n\t\t\tnull,undifined-->boolean:false\r\n\t\t\tobject-->boolean:true\r\n\t\t方式二:a = !!a;\r\n```\r\n####1.3.7 Object对象\r\n除上述五种基本类型外,都是对象\r\n\r\n\r\n\r\n###1.4运算符\r\n\r\n\r\n- typeof  获得值的类型,以==字符串==类型返回\r\n\r\n####1.4.1算术运算符\r\n```\r\n\t+-*/ 对非Number运算会先转换为Number再运算\r\n\t\t任何值与NaN运算都得NaN\r\n\t\tString + String是将两个字符串连接起来\r\n\t\t任何值与String相加都会先转换为String\r\n\t\t可以通过加一个空串将类型转换为String(原理与String()函数相同)\r\n\t\t可以通过减0(乘除1)将类型转换为Number(原理于Number()函数相同)\r\n\t\t\r\n\t%取模运算(取余数)  9%4=1\r\n```\r\n####1.4.2一元运算符\r\n```\r\n\t+(正号) -(负号)\r\n\t\t对于非Number值会先转换为Number值再取负值\r\n\t\t可以对其他类型使用+转换为Number\r\n\t\teg:a=+a;\r\n\t\t\r\n\t++(自增) --(自减)\r\n\t\teg: var a = 1; a++;   a立刻变为2\r\n\t后自增(a++),前自增(++a)\r\n\t\ta++的值是1,++a的值是2,但a的值都是2\r\n```\r\n####1.4.3逻辑运算符\r\n```\r\n\t! 非  :  对布尔值进行取反,如果对非布尔值进行运算会先转换为布尔值\r\n\t\r\n\t&& 与  : 对符号两侧逻辑与运算,(短路式)如果第一个值为false则不再检查后面的值\r\n\t\r\n\t|| 或  : 对符号两侧逻辑或运算,(短路式)如果第一个值为true则不再检查后面的值\r\n\t\r\n\t对于非布尔值与或运算时会先将其转换为布尔值,然后再运算,并返回原值\r\n\t与运算:如果第一个值为true,则直接返回第二个值;如果第一个值为false,则直接返回第一个值\r\n\t或运算:如果第一个值为true,则直接返回第一个值;如果第一个值为false,则直接返回第二个值\r\n```\r\n####1.4.4赋值运算符\r\n```\r\n\t=  将右侧值赋给左侧\r\n\t+=  -=  *=  /=  %=\r\n```\r\n####1.4.5关系运算符\r\n```\r\n\t>大于号,<小于号,>=大于等于号,<=小于等于号   关系成立返回true,否则返回false\r\n\t对于非数值进行比较时，会转换为Number\r\n\t\t任何值和Null比较结果都是false\r\n\t\t如果符合两侧都是字符串时，不会将其转换为Number，而是比较其Unicode编码，一位一位依次比较\r\n\t\t\t比较中文没有意义\r\n\t\r\n\t在字符串中可以使用转义字符输入Unicode编码\r\n\t\t\\u四位编码\r\n\t在网页中使用Unicode编码\r\n\t\t&#编码（需要使用10进制编码）\r\n\t\t\r\n\t==    相等运算符    相等返回true,不等返回false\r\n\t\t若类型不同时，会自动进行类型转换（大部分情况都是转换为Number)\r\n\t\t\tundifined衍生自null，因此它们相等判断为true\r\n\t\t\tNaN不与任何值相等，包括它本身\r\n\t\t\t\t可以通过isNaN()函数来判断一个值是否为NaN,如果是NaN返回true\r\n\t!=    不等于\r\n\t\t也会对类型自动转换\r\n\t===   全等    用于判断两个值是否全相等，不会做类型转换\r\n\t!==   不全等   用于判断两个值是否不全等，与!=相似，但不会做类型转换\r\n```\r\n####1.4.6条件运算符（三元运算符）\r\n```\r\n\t条件表达式?语句1:语句2;\r\n\t\t条件表达式为true时执行语句1并返回执行结果，否则执行语句2并返回执行结果\r\n\t\t\teg: var max = a > b ? a: b;\r\n\t\t\teg: var max = a>b?(a>c?a:c):(b>c?b:c); 获取a b c中最大值（不推荐）\r\n\t\t如果条件表达式结果为非布尔值，会转换为布尔值\r\n```\r\n####1.4.7逗号运算符\r\n```\r\n\t,  可以使用逗号同时声明多个变量（并赋值）\r\n\t\teg: var a,b,c;\r\n\t\teg: var a=1,b=2,c=3;\r\n```\r\n####1.4.8运算符的优先级\r\n- 在运算符优先级表中越靠上，优先级越高，同一优先级从左往右运算\r\n- 可以通过（）使优先级变高\r\n\r\n\r\n\r\n###1.5代码块\r\n- 在JS中可以使用{}来为语句进行分组,一个{}中的语句我们也成为一个==代码块==\r\n- 代码块只具有分组的作用,没有其他的用途\r\n- 一个代码块中的语句,要么全部执行,要么全不执行\r\n- JS的程序是从上到下一行一行执行的,通过流程控制语句可以控制程序执行流程\r\n\r\n####1.5.1条件判断(if语句)\r\n```\r\n\t语法一:if(条件表达式){\r\n\t\t\t语句\r\n\t\t  }\r\n\t语法二:if(条件表达式){\r\n\t\t\t语句1\r\n\t\t  }else{\r\n\t\t    语句2\r\n\t\t  }\r\n\t语法三:if(条件表达式){\r\n\t\t\t语句1\r\n\t\t  }else if(条件表达式){\r\n\t\t    语句2\r\n\t\t  }else{\r\n\t\t    语句3\r\n\t\t  }\r\n```\r\n\r\n####1.5.2条件分支语句(switch语句)\r\n```\r\n\t语法:switch(条件表达式){\r\n\t\t\tcase 表达式 :语句1;break;\r\n\t\t\tcase 表达式 :语句2;break;\r\n\t\t\t......\r\n\t\t\tdefault :语句n;\r\n\t\t}\r\n\t条件表达式与case后表达式进行全等比较\r\n```\r\n####1.5.3循环语句\r\n#####1.5.3.1while循环\r\n```\r\n\t语法一:\r\n\t\twhile(条件表达式){\r\n\t\t\t语句...\r\n\t\t}\r\n\t当表达式为true时执行循环体,直至表达式为false\r\n\t\r\n\t语法二:\r\n\t\tdo{\r\n\t\t\t语句...\r\n\t\t}while(条件表达式)\r\n\t先执行循环体,再判断条件表达式,若为true重复循环体\r\n```\r\n#####1.5.3.2for循环\r\n```\r\n\t语法:\r\n\t\tfor(初始化表达式;条件表达式;更新表达式){\r\n\t\t\t语句...\r\n\t\t}\r\n\t三部分均可省略,也都可以写在外部\r\n```\r\n#####1.5.3.3break和continue\r\n```\r\n\tbreak:用于退出switch或循环语句(不能用于退出if语句)\r\n\tlabel:循环语句\r\n\t使用break语句时,可以在break后跟着一个label,这样break会结束指定的循环而非最近的循环\r\n\tcontinue:用于跳过当前次循环,同样默认只会对最近的循环起作用\r\n\t同样可以用label指定跳出的循环\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n##Chapter2对象\r\n\r\n###2.1对象的介绍\r\n####2.1.1对象的基本操作\r\n对象属于一种复合的数据类型,在对象中可以保存多个不同数据类型的属性\r\n对象的分类:\r\n\t1.内建对象\r\n\t\t- 由ES标准中定义的对象,在任何ES的实现中都可以使用\r\n\t\t- 如Math,String,Number,Boolean,Function,Object...\r\n\t2.宿主对象\r\n\t\t- 由JS的运行环境提供的对象,目前来讲主要时指由浏览器提供的对象\r\n\t\t- 如BOM DOM\r\n\t3.自定义对象\r\n\t\t- 由开发人员自己创建的对象\r\n\r\n\r\n创建对象\r\n\t使用==new==关键字(调用构造函数constructor--专门用来创建对象的函数)\r\n\teg : var obj = new Object();\r\n\t使用typeof检查时会返回object\r\n\t在对象中保存的值称为==属性==\r\n - 向对象添加属性\r\n\r\n      ​    对象.属性名 = 属性值;\r\n      ​\teg: obj.name = \"孙悟空\";\r\n\r\n - 读取对象中的属性\r\n         语法: 对象.属性名\r\n         如果读取对象中没有的属性,不会报错而是返回undefined\r\n\r\n  -  删除对象的属性\r\n        语法: delete  对象.属性名\r\n\r\n\r\n  -  属性名:对象的属性名不强制要求遵守标识符的规范,但仍建议按照规范命名\r\n           如果要使用特殊的属性名,不能采用.的方式来操作\r\n           需要采用  对象[\"属性名\"] = 属性值;\r\n           使用[]去操作属性值更加灵活,在[]中可以直接传递一个变量,变量值是多少就会读取哪个属性\r\n           eg: var n = '123'; obj[n] = 'hello'\r\n     . new [] 的优先级最高\r\n   \r\n  -  属性值:可以是任意的数据类型,甚至可以是一个对象\r\n\r\n- in运算符:检查一个对象中是否含有指定的属性,如果有返回true,如果没有返回false\r\n语法: \"属性名\" in 对象\r\n\r\n\r\n####2.1.2基本数据类型和引用数据类型\r\n基本数据类型: String Number Boolean Null Undefined\r\n引用数据类型: Object\r\n\r\nJS 中的变量都是保存在栈内存中的\r\n\r\n- 基本数据类型的值直接在栈内存存储,\r\n\t值与值之间独立存在,修改一个变量不会影响其他的变量\r\n- 对象是保存到堆内存中的,每创建一个新的对象,就会在堆内存中开辟一个新的空间,而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象引用,当一个提供变量修改属性时,另一个也会受到影响\r\n- 当一个变量的值修改为null,其他指向同一对象的变量不会受到影响\r\n- 两个对象属性全部相同,但他们也仍是两个对象,不会相等(双胞胎是两个人)\r\n  比较两个引用数据时,比较的是对象的内存地址\r\n  \r\n\r\n####2.1.3对象字面量\r\n使用对象字面量可以直接在创建对象时指定对象中的属性\r\n语法: {属性名:属性值,属性名:属性值,...}\r\n```js\r\nvar obj={\r\nname:\"猪八戒\",\r\nage:28,\r\ngender:\"男\"\r\n};\r\n```\r\n- 属性名可以加引号也可以不加,但如果使用特殊的属性名就需要加引号\r\n\r\n- 属性名和属性值是一组一组名值对结构,属性名与属性值之间用:连接,多个名值对之间用,隔开,最后一个名值对后不写逗号\r\n\r\n  \r\n\r\n###2.2函数\r\n####2.2.1函数的简介\r\n- 函数也是一个对象（*万物皆对象*）\r\n- 函数可以封装一些功能（代码），在需要时可以执行。\r\n\r\n创建一个函数对象\r\nvar fun  = new Function();\r\n- 可以将要封装的代码以字符串的形式传递给构造函数\r\n- 封装到函数中的代码不会立即执行，会在调用时执行\r\n\r\n调用函数语法： 函数对象()\r\n当调用时，函数中封装的代码会按照顺序执行\r\n\r\n使用==函数声明==来创建一个函数\r\n语法： function 函数名([形参1，形参2,...]){语句...}\r\n\t\r\n使用==函数表达式==来创建一个函数\r\n语法： var fun3=function([]){语句...}\r\n\r\n\r\n####2.2.2函数的参数与返回值\r\n```js\r\nfunction sum(a,b){\r\n\tconsole.log(a+b);\r\n\tvar d = a + b;\r\n\treturn d;\r\n}\r\nsum(1,2);\r\nvar result = sum(7,8);\r\n```\r\n实参会赋值给形参\r\n\r\n- 调用函数时，解析器不会检查实参的类型\r\n\r\n- 调用函数时，解析器不会检查实参的数量\r\n\t- 多余的实参不会被赋值\r\n\t- 如果形参的数量多余形参，没有对应实参的形参将是undefined\r\n\t\r\n- 函数中return以后的语句不会执行\r\n\r\n- 如果return后不跟任何值或函数中没有return语句，则会返回undefined\r\n\r\n- 实参可以是任何数据类型，也可以是对象，也可以是函数\r\n\r\n  \r\n\r\n- fun()   调用函数，相当于使用函数的返回值\r\n\r\n- fun 函数对象，相当于直接使用函数对象\r\n\r\n\r\n\r\n####2.2.3返回值的类型\r\n- ==使用return可以结束整个函数（相比于break和continue)==\r\n- 返回值可以是任意的数据类型，也可以是一个对象，也可是是一个函数\r\n\r\n匿名函数 function(){语句...}\r\n立即执行函数  (function(){语句...})();  ==往往只会执行一次==\r\n\r\n####2.2.4 方法\r\n- 对象的属性值可是是任何数据类型，==也可以是函数==\r\n- 如果一个函数作为一个对象的属性保存，那我称这个函数是这个对象的==方法==\r\n- 调用这个函数就叫做调用对象的方法\r\n- 但是这只是名称上的区别，没有本质的区别\r\n\r\n枚举对象中的属性\r\n语法：for (var 变量 in 对象）{语句...}\r\nfor ... in 语句：对象中有几个属性，循环体就会执行几次\r\n\t每次执行时，会将一个属性名赋值给变量\r\n```js\r\nfor( var n in obj){\r\n\t\tconsole.log(n);\r\n\t}\r\n```\r\n\r\n\r\n####2.2.5作用域\r\n\r\n- 作用域：变量作用的范围\r\n\r\n-  在JS中一共有两种作用域\r\n\t- 全局作用域：\r\n\t\t- 直接编写在script 标签中的JS代码都在全局作用域\r\n\t\t- 全局作用域在页面打开时创建，在页面关闭时销毁\r\n\t\t- 全局作用域中有一个全局对象window,代表一个浏览器的窗口，由浏览器创建，我们可以直接使用\r\n\t\t- 在全局作用域中：\r\n\t\t\t- 创建的变量都会作为window对象的属性保存\r\n\t\t\t- 创建的函数都会作为window对象的方法保存（因此方法与对象没有区别）\r\n\t\t\r\n\t- 函数作用域：\r\n\t\t- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁\r\n\t\t- 每调用一次函数就会创建一个新的函数作用域，它们之间==互相独立==\r\n\t\t- 在函数作用域中可以访问到全局变量\r\n\t\t\t而在全局作用域中无法访问到函数作用域的变量\r\n\t\t\t-当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用；如果没有则向上一级作用域中寻找\r\n\t\t\t-在函数中要访问全局变量可以使用window对象\r\n\t\t- 在函数作用域中也有声明提前：使用var关键字声明的会最先执行\r\n\t\t- 在函数中不使用var声明的变量，都会成为全局变量\r\n\t\t- 定义形参就相当于在函数中声明了一个变量\r\n\t\t\t\r\n\t\r\n- 变量声明提前：\r\n\t- 使用var关键字声明的变量，会在所有代码执行前被声明（但不会赋值）\r\n\t- 如果不使用var关键字，则变量不会被声明提前\r\n\t\r\n- 函数声明提前：\r\n\t- 使用==函数声明==创建的函数，==可以在创建前使用==（在所有代码创建前被创建）\r\n\t- 使用==函数表达式==创建的函数==不会被声明提前==，因此不能在声明前使用\r\n\r\n\r\n####2.2.6this\r\n- 解析器在调用函数时每次都会向函数内部传递进一个隐含的参数，这个参数就是this\r\n- this指向的是一个对象，这个对象我们称为函数执行的==上下文对象==\r\n- 根据函数调用方式的不同，this会指向不同的对象\r\n\t- 以==方法调用==时，this是调用方法的那个对象\r\n\t- 以==函数形式调用==时，this永远都是window\r\n\r\n\r\n####2.2.7使用工厂方法创建对象\r\n\r\n```javascript\r\n//创建一个可以创建对象的函数\r\nfunction createPerson(name,age,gender){\r\n\t//创建一个新的对象\r\n\tvar obj = new Object();\r\n\t//向对象中添加属性\r\n\tobj.name = name;\r\n\tobj.age = age;\r\n\tobj.gender = gender;\r\n\tobj.sayName = function(){\r\n\t\talert(this.name);\r\n\t}\r\n\t//将新建的对象返回\r\n\treturn obj;\r\n}\r\n//调用createPerson()函数创建对象\r\nvar obj1=createPerson(\"白骨精\",28,\"女\")；\r\n```\r\n\r\n\r\n####2.2.8构造函数\r\n- 构造函数就是一个普通的函数，创建方式与普通函数没有什么区别\r\n- 构造函数==函数名首字母一般大写==\r\n- 构造函数与普通函数的区别在于调用方式不同：\r\n\t- 普通函数直接调用，构造函数需要使用==new关键字==调用\r\n- 构造函数执行流程：\r\n\t1.立刻创建一个新建对象\r\n\t2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象\r\n\t3.逐行执行函数中的代码\r\n\t4.将新的对象作为返回值返回\r\n-  使用同一个构造函数创建的对象，称为一类对象，因此也将一个构造函数称为一个类\r\n-  通过一个构造函数创建的对象，称为该类的实例（per是Person类的实例）\r\n\r\n\r\n```js\r\nfunction Person(name,age,gender){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.gender = gender; \r\n\tthis.sayName = function(){\r\n\t\talert(this.name);\r\n\t}\r\n}\r\nvar per = new Person(\"玉兔\",16,\"女\");\r\n```\r\n\r\n- 使用instanceof可以检查一个对象是否是一个类的实例\r\n\t语法： \r\n\t对象 instanceof 构造函数\r\n\t如果是，则返回true，否则返回false\r\n\teg: console.log(per instanceof Person)  //true\r\n- 所有对象都是Object的后代，所以任何对象在instanceof检查时都会返回true\r\n- ==以构造函数的形式调用时，this就是新创建的对象==\r\n\r\n构造函数优化\r\n\r\n\r\n```javascript\r\nfunction Person(name,age,gender){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.gender = gender; \r\n\tthis.sayName = fun；\r\n\t}\r\n}\r\n//将sayName函数在全局中定义，大大节省了空间\r\n//但将函数定义在全局作用域，污染了全局作用域的命名空间，而且也不安全\r\nfunction fun(){\r\n\talert(this.name);\r\n}\r\nvar per = new Person(\"玉兔\",16,\"女\");\r\n```\r\n\r\n\r\n\r\n\r\n####2.2.9原型\r\n- 我们创建的每一个函数,解析器都会向函数中添加一个属性==prototype(显示原型)==\r\n\r\n- 这个属性对应着一个对象,就是原型对象(默认是**空对象**)\r\n\r\n- 如果函数作为普通函数调用,prototype没有任何作用\r\n\r\n- 如果函数作为构造函数调用时,它所创建的对象中都会有一个隐含的属性指向该构造函数的原型对象\r\n\t- 每个实例对象都有一个==\\_proto\\_(隐式原型)==属性\r\n\t- 对象的隐式原型即为其构造函数的显示原型即==per.\\_proto\\_ = = = Person.prototype==\r\n\t\r\n- 原型对象就相当于一个公共区域,同一个类的所有实例都可以访问到这个原型对象\r\n\t- 可以将对象中共有的内容同一设置到原型对象中\r\n\t- 当我们访问对象一个属性或方法时,会先在对象自身寻找,如果有则使用,没有则去原型中寻找\r\n\r\n- 原型对象中有一个constructor属性指向函数对象\r\n\t\r\n```\tjs\r\n\tfunction Person(name,age,gender){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.gender = gender; \r\n\t}\r\n\tPerson.prototype.sayName = function(){\r\n\t\talert(this.name);\r\n\t}\r\n\tvar per = new Person(\"玉兔\",16,\"女\");\r\n```\r\n\r\n因此创建构造函数时,可以将对象共有的属性和方法统一添加到构造函数的原型对象中,这样就不用分别为每个对象添加,也不会影响到全局作用域,就可以使每个对象都具有这些属性和方法\r\n\r\n- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true\r\n- 使用per.hasOwnProperty()检查对象自身中是否含有该属性\r\n- ==原型对象也是对象，它也有原型==\r\n- 自身中没有去原型中找，原型中没有去原型的原型找，==直到Object的原型==(也就是Object的原型没有原型)\r\n- 在Object的原型中仍没找到，则返回undefined\r\n\r\n\r\n\r\n\r\n- 直接在页面中打印一个对象时，实际上是==输出对象的toString()方法的返回值==\r\n- 如果不希望输出对象时输出[object Object]，可以为对象添加一个toSting()方法\r\n```javascript\r\nfunction Person(name,age){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n}\r\nvar per = new Person(\"Bob\",40);\r\nPerson.prototype.tostring = function(){\r\n\treturn \"Person[name=\"+this.name+\",age=\"+this.age]\";\r\n}\r\nconsole.log(per);\r\n```\r\n\r\n\r\n\r\n ==垃圾回收(GC)==\r\n- 处理程序运行过程中产生的垃圾\r\n- 当一个对象没有任何变量或属性对它进行引用，此时我们无法操作它，它就是一个垃圾\r\n- 垃圾过多会占用大量内存，导致程序运行过慢\r\n- 在JS中拥有自动垃圾回收机制，会自动从内存中销毁垃圾\r\n- 我们只需要==将不再使用的对象设置为null==\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n###2.3数组Array\r\n\r\n####2.3..1数组简介\r\n\r\n- 数组也是一个对象,和普通对象功能类似\r\n- 不同的是普通对象是使用字符串作为属性名，而数组使用数字作为索引(index)\r\n- 数组的存储性能更好\r\n- 使用typeof检查时会返回object\r\n- 数组中的元素可以是任意数据类型==包括对象==\r\n```javascript\r\n//创建数组对象\r\nvar arr = new array();\r\n//向数组中添加元素\r\n arr[0] = 10;\r\n //读取数组中的元素(如果读取不存在的索引，会返回undefined)\r\n console.log(arr[0]);\r\n//获取数组长度\r\nconsole.log(arr.length);\r\n//修改length\r\n//如果修改的length大于原长度，多余部分空出来；如果小于原长度，多余元素会被删除\r\narr.length=10;\r\nconsole.log(arr.length);\r\n//向数组的最后一个位置添加元素\r\narr[arr.length]=70;\r\n```\r\n####2.3.2数组字面量\r\n```js\r\n// 使用字面量创建数组\r\nvar arr = [1,2,3,4,5];\r\nconsole.log(arr[0]);\r\n//使用构造函数创建数组时，也可以同时添加元素\r\nvar arr2 = new Array(10,20,30);\r\n//创建一个只有元素10的数组\r\narr=[10];\r\n//创建一个长度为10的数组\r\narr2 = new Array(10);\r\n```\r\n####2.3.3数组的方法\r\n######push()\r\n- 向数组末尾添加一个或多个元素，并返回数组的新长度\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.push('Jack','lucy');\r\nconsole.log(arr);  //'alice','bob','cindy','jack','lucy'\r\nconsole.log(result);//5\r\n```\r\n######pop()\r\n- 删除数组的最后一个元素，并返回删除的元素\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.pop();\r\nconsole.log(arr);  //'alice','bob'\r\nconsole.log(result);//'cindy'\r\n```\r\n######unshift()\r\n-  向数组开头添加一个或多个元素，并返回新的数组长度\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.unshift('Jack','lucy');\r\nconsole.log(arr);  //'jack','lucy','alice','bob','cindy'\r\nconsole.log(result);//5\r\n```\r\n######shift()\r\n- 删除数组的第一个元素，并将被删除的元素返回\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.shift();\r\nconsole.log(arr);  //'bob','cindy'\r\nconsole.log(result);//'alice'\r\n```\r\n####2.3.4数组的遍历\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nfor(var i=0;i<arr.length;i++){\r\n\tconsole.log(arr[i]);\r\n}\r\n```\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.pop();\r\nconsole.log(arr);  //'alice','bob'\r\nconsole.log(result);//'cindy'\r\n```\r\n```js\r\nfunction Person(name,age,gender){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.sayName = function(){\r\n\t\talert(this.name);\r\n\t}\r\n}\r\nvar per1 = new Person(\"玉兔\",16);\r\nvar per2 = new Person(\"嫦娥\",26);\r\nvar per3 = new Person(\"二郎神\",36);\r\nvar per4 = new Person(\"猪八戒\",36);\r\nvar per5 = new Person(\"红孩儿\",6);\r\n\r\nvar perArr = [per1,per2,per3,per4,per5];\r\n```\r\n\r\n###### 回调函数：由我们创建不由我们调用的函数\r\n- forEach()方法需要一个函数作为参数\r\n- 数组中有几个元素就会执行几次，每次执行时浏览器会将遍历到的元素以实参形式传递进来，可以定义形参来读取这些内容\r\n- 浏览器在回调时会传递三个参数：第一个参数是当前正在遍历的元素；第二个参数是当前正在遍历的元素的索引；第三个参数就是正在遍历的数组\r\n\r\n```js\r\narr.forEach(function(){\r\n\tconsole.log(\"hello\");\r\n});\r\n```\r\n\r\n####2.3.5数组的其他方法\r\n\r\n######slice()\r\n\r\n- 从数据中提取指定元素\r\n- 该方法不会影响原数组，而是将截取的元素封装到一个新的数组中返回\r\n- 参数：\r\n\t1.截取开始的位置索引，包含开始索引\r\n\t2.截取结束的位置索引，不包含结束索引\r\n\t\t\t第二个参数可以不写，表示从开始位置截取到最后\r\n\t\t索引也可以传负值  -1是倒数第一个 -2是倒数第二个\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.slice(1,2);\r\nconsole.log(arr);  //'alice','bob','cindy'\r\nconsole.log(result);//'bob,cindy'\r\n```\r\n\r\n######splice()\r\n- 用于删除数组中的指定元素\r\n- 会影响原数组，返回被删除的元素\r\n- 参数：\r\n\t1.表示开始位置的索引\r\n\t2.表示删除的数量\r\n\t3.第三个参数及以后可以传递一些新的元素插入到开始索引的前面\r\n\r\n```js\r\nvar arr=['alice','Bob','cindy'];\r\nvar result = arr.splice(1,1);\r\nconsole.log(arr);  //'alice,cindy'\r\nconsole.log(result);//'bob'\r\n```\r\n\r\n###### concat()\r\n- 将两个或多个数组==连接==并将新的数组返回（**不会对原数组产生影响**）\r\n\r\n######join()\r\n- 将数组==转换为一个字符串==并返回（**不会对原数组产生影响**）\r\n- 可以指定一个字符串作为参数以指定元素间的连接符（默认为逗号）\r\n\r\n######reverse()\r\n-   ==反转数组（**会直接对原数组产生影响**）==\r\n\r\n######sort()\r\n- 对数组进行==排序==（**会直接对原数组产生影响**）\r\n- 默认按照Unicode编码排序（小的在前，大的在后）\r\n- 但是对于纯数字数组也会按照Unicode编码排序\r\n- 可以通过回调函数指定排序规则，浏览器会根据回调函数返回值来决定元素位置\r\n\t\t如果返回大于0的值，则交换两元素位置；否则，元素位置不变\r\n```js\r\narr = [5,4,3];\r\narr.sort(function(a,b){\r\n\t// 升序排列\r\n\treturn a-b;\r\n\t//降序排列\r\n\treturn b-a;\r\n})\r\n```\r\n######filter()\r\n- 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素\r\n```js\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result);\r\n```\r\n####2.3.6call()和apply()\r\n- 这两个都是函数对象的方法，需要通过函数对象来调用\r\n- 当对函数调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this\r\n- call()方法可以将实参在对象之后传递\r\n- apply()方法需要将实参封装到数组中统一传递\r\n\r\n####2.3.7arguments\r\n在调用函数时，浏览器每次都会传递进两个隐含的参数：\r\n\t1.函数的上下文对象this\r\n\t2.封装实参的对象arguments\r\n\t\t- arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度\r\n\t\t- 在调用函数时，我们传递的实参都会在arguments中保存\r\n\t\t- arguments.length可以用来获取实参的长度\r\n\t\t- 即使不定义形参也可以通过arguments来使用实参\r\n\t\t\t- arguments[0]表示第一个实参...\r\n\t\t- 它里面有一个属性叫做callee,对应一个函数对象，就是当前正在指向函数的对象\r\n\r\n###2.4其他对象\r\n####2.4.1Date对象\r\n- 在JS中使用Date对象来表示一个时间\r\n\r\n```js\r\n//如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间\r\nvar d = new Date();\r\n//创建一个指定的时间对象，需要在构造函数中传递一个表示时间的字符串作为参数\r\n//日期的格式： 月/日/年 时:分:秒\r\nvar d2 = new Date(\"03/13/2022 17:52:52\");\r\n//获取当前日期对象是几号\r\nvar date = d2.getDate();\r\n//获取当前日期对象是周几（周日返回0）\r\nvar day = d2.getDay();\r\n//获取当前月份（会返回0-11的值，11表示12月）\r\nvar month = d2.getMonth() + 1 ;\r\n//获取当前年份\r\nvar year = d2.getFullYear();\r\n//获取当前日期的时间戳（1970年1月1日0时0分0秒到现在的时间差，单位毫秒）\r\nvar time = d2.getTime();\r\n//获取当前的时间戳\r\ntime = Date.now();\r\n\r\nconsole.log(d);\r\n```\r\n\r\n####2.4.2Math对象\r\n- Math和其他对象不同，它不是一个构造函数\r\n- Math属于一个工具类，它封装了数学运算相关的属性和方法\r\n```\r\n//输出圆周率PI\r\nconsole.log(Math.PI);\r\n//绝对值Math.abs();\r\nconsole.log(Math.abs(-1));//1\r\n//向上取整Math.ceil();\r\nconsole.log(Math.ceil(1.111));//2\r\n//向下取整Math.floor();\r\n// 四舍五入取整Math.round()\r\n//生成一个0-1 的随机数（不包含0和1)\r\nvar a = Math.random();\r\n// 生成一个x-y之间的随机整数\r\nvar b = Math.round(Math.random()*(y-x)+x);\r\n//max(); min();获得多个数中最大/最小值\r\n//Math.pow(x,y);获得x^y\r\n//Math.sqrt();开方\r\n```\r\n\r\n####2.4.3包装类\r\n- 在JS中为我们提供了3个包装类，提供这三个包装类可以将基本数据类型的数据转换为对象\r\n- String()\r\n\t-  将基本数据类型转换为String对象\r\n- Number()\r\n\t- 将基本数据类型转换为Number对象\r\n- Boolean()\r\n\t- 将基本数据类型转换为 Boolean对象\r\n\r\n但实际上开发中并==不会使用==基本数据对象\r\n当我们对基本数据类型调用属性和方法时，浏览器会临时使用包装将其转换为对象，然后再调用\r\n\r\n####2.4.4String的方法\r\n- 在底层，字符串是以字符数组的形式保存的\r\n###### length\r\n- 获取字符串的长度\r\n###### charAt()\r\n- 返回字符串中指定位置的字符，arr.charAt(6)与arr[6]相同\r\n###### charCodeAt()\r\n- 获取指定位置字符的字符编码(Unicode编码)\r\n###### fromCharAt()\r\n- 根据字符编码获取字符\r\n```js\r\nresult = String.fromCharAt(20045);// 乍\r\n```\r\n###### concat()\r\n- 连接两个或多个字符串,作用和+一样\r\n```js\r\nresult = str.concat(\"hi\",\"bye\");\r\n```\r\n###### indexof()\r\n-  检索一个字符串中是否含有指定内容，如果有则返回其==第一次出现==的索引;没有则返回-1，可以指定第二个参数为开始查找的位置\r\n```js\r\nresult = str.indexof(\"p\");\r\nresult = str.indexof(\"p\",1);// 从str[1]开始检索\r\n```\r\n###### lastIndexof()\r\n- 与indexof()用法相同，优先返回最后出现的索引\r\n######slice()\r\n- 与数组用法完全相同\r\n######substring()\r\n- 与slice()基本相同，但参数不能传递负值（如果传负值默认为0），还会自动调整参数位置使小数在前大数在后\r\n######split()\r\n- 将字符串拆分为数组\r\n- 需要一个字符串作为参数,根据参数去拆分数组\r\n- 如果参数为空串，则会将字符串中每个字符作为一个元素\r\n```js\r\nstr='abc,bcd,efgh';\r\nresult = str.split(\",\");\r\nconsole.log(result[0]);//'abc'\r\n```\r\n######toUpperCase()\r\n- 将字符串全部转换为大写并返回(不会影响原字符串)\r\n######toLowerCase()\r\n- 将字符串全部转换为小写并返回(不会影响原字符串)\r\n\r\n\r\n####2.4.5正则表达式\r\n- 用于定义一些字符串的规则\r\n- 计算机可以根据正则表达式来检查一个字符串是否符合规则或者将符合规则的字符串提取出来\r\n- 使用typeof检查正则对象，会返回object\r\n\r\n创建正则表达式的对象\r\n语法： var 变量 = new RegExp(\"正则表达式\"，\"匹配模式\")；\r\n正则表达式的方法： test() 如果符合返回true，否则返回false\r\n匹配模式：\r\n\t- i:忽略大小写\r\n\t- g:全局匹配模式\r\n\r\n```\r\n//检查字符串是否包含某字符串（严格区分大小写）\r\nvar reg = new RegExp('a');\r\nconsole.log(reg.test('abc'));//true\r\n```\r\n\r\n使用字面量创建正则表达式：==var 变量 =  /正则表达式/匹配模式；==\r\n- 使用字面量创建更加简单，使用构造函数创建更加灵活\r\n```\r\n//检查字符串是否包含a或b\r\nvar reg = /a|b/i;\r\nconsole.log(reg.test('abc'));//true\r\n//检查字符串是否包含字母\r\n//[]里也是或的关系  [a-z]表示任意小写字母；[A-Z]表示任意大写字母\r\nreg = /[A-z]/;\r\n//检查字符串是否包含abc或adc或aec\r\nreg = /a[bde]c/;\r\n//[^ab] 检查字符串是否包含除了ab以外的其他字符\r\n```\r\n\r\n####2.4.6String和正则表达式相关的方法\r\n######split()\r\n- 可以传递一个正则表达式作为参数，这样会根据正则表达式去拆分字符串\r\n- 默认全局匹配\r\n```js\r\nstr='abc,bcd,efgh';\r\nresult = str.split(/[A-z]/);\r\nconsole.log(result[0]);//','\r\n```\r\n######search()\r\n- 搜索字符串中是否含有指定内容\r\n- 如果搜索到指定内容会返回第一次出现的索引，否则返回-1\r\n- 可以接受一个正则表达式作为参数\r\n- 不能设置全局匹配，只会查找第一个\r\n```js\r\nstr='abc,bcd,efgh';\r\nresult = str.search(/a[bde]c/);\r\nconsole.log(result[0]);//0\r\n```\r\n######match()\r\n- 可以根据正则表达式从一个字符串中将符合条件的内容提取出来\r\n- 默认情况下只会找到第一个符合要求的内容，找到以后就停止检索，但可以设置为全局匹配模式，就会匹配到所有内容\r\n- 可以为一个正则表达式设置多个匹配模式，且顺序无所谓\r\n- match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果\r\n```js\r\nstr='1a2vg34jkhjw';\r\n//找到字符串中的字母\r\nresult = str.match(/[a-z]/gi);\r\nconsole.log(result);//'a,v,g,j,k,h,j,w'\r\n```\r\n######replace()\r\n- 可以将字符串中指定内容替换为新的内容\r\n- 参数：\r\n\t1.被替换的内容，可以接受一个正则表达式\r\n\t2.新的内容\r\n- 默认只替换第一个，可设置全局匹配模式\r\n```js\r\nstr='1a2vg34jkhjw';\r\n//找到字符串中的字母\r\nresult = str.replace(/[a-z]/gi,'*');\r\nconsole.log(result);//'1*2**34*****'\r\n```\r\n\r\n####2.4.7正则表达式的语法\r\n- 通过量词可以设置一个内容出现的次数\r\n```js\r\nvar reg = /a{n}/;  //连续n个a\r\nreg = /(ab)(3) /;  //ababab\r\nreg = / ab{3}c/;  //abbbc\r\nreg = /ab{1,3}c/;// abc|abbc|abbbc   {m,n} m-n次 {m,}至少m次\r\nreg = /ab+c/;  //b+相当于b{1,}\r\nreg = /ab*c/;  //b* 有没有b 都行，相当于b{0，}\r\nreg = /ab?c/;  //b?相当于b{0,1}\r\n//检查一个字符串是否以a开头\r\nreg = /^a/;  //^表示开头,匹配开头a；$表示结尾\r\nreg = /a$/;  // 表示以a结尾   /^a$/只能是一个a\r\nreg = /^a|a$/;  //表示以a开头或结尾 \r\n```\r\n```js\r\n//检查是否为手机号码\r\nvar str = \"19171172391\";\r\nvar reg = /^1 [3-9] [0-9]{9}$/;\r\nconsole.log(reg.test(str));\r\n```\r\n-  · 表示任意字符，因此要表示单纯的 · 需要使用转义字符\\\r\n```js\r\n//检查是否含有·\r\nvar str = \"abc.c\";\r\nvar reg = /\\./;\r\nconsole.log(reg.test(str));//true\r\nreg = /\\\\/;  //  需要使用\\表达反斜杠时要用\\\\\r\n```\r\n==attention:用构造函数创建正则表达式时由于正则表达式是字符串，需要用\\\\作为转义字符==\r\n\r\n- \\w：任意字母数字和下划线  [A-z0-9\\_]\r\n- \\W：除\\w\r\n- \\d：任意数字\r\n- \\D：除了\\d\r\n- \\s：空格\r\n- \\S：除了\\s\r\n- \\b：单词边界,如\\b child\\b检测是否含有独立单词child\r\n- \\B：除了\\b\r\n- /^\\s*|\\s*&/g   匹配开头或结尾的空格\r\n\r\n######邮件的正则表达式\r\n任意字母数字下划线   .任意字母数字下划线(可有可无) @ 任意字母数字 . 任意字母（2-5位）.任意字母（2-5位)\r\n/^\\\\w{3,} (\\\\.\\\\w+)* @ [A-z0-9]+(\\\\\\.[A-z]{2,5}){1,2}$/;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n##Chapter3DOM\r\n\r\n###3.1DOM的简介\r\n- Document Object Model==文档对象模型==\r\n\r\n- 使我们可以通过js操作网页\r\n\r\n- 文档：HTML网页文档\r\n\r\n- 对象：将网页中每一个部分转换为一个对象\r\n\r\n- 模型：使用模型表示对象之间的关系，方便我们获取对象\r\n\r\n- 节点Node：构成网页的最基组成部分，每一个部分都是一个节点\r\n\t- 文档节点：整个html文档\r\n\t\r\n\t- 元素节点：html文档中的html标签\r\n\t\r\n\t- 属性节点：元素的属性\r\n\t\r\n\t- 文本节点：html标签中的文本内容\r\n\t\r\n\r\n| 节点的属性 | nodeName  | nodeType | nodeValue |\r\n| :--------: | :-------: | :------: | :-------: |\r\n|  文档节点  | #document |    9     |   null    |\r\n|  元素节点  |  标签名   |    1     |   null    |\r\n|  属性节点  |  属性名   |    2     |  属性值   |\r\n|  文本节点  |   #text   |    3     | ※文本内容 |\r\n\r\n\r\n- 浏览器已经为我们提供了文档节点对象，这个对象是window属性\r\n    可以在页面中直接使用，文档节点代表的是整个网页\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n\t<button id=\"btn\"></button>\r\n\t<script type=\"text/javascript\">\r\n    \tvar btn = document.getElementById(\"btn\");\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n###3.2事件\r\n- 事件就是用户和浏览器之间的交互行为，如点击按钮，鼠标移动，关闭窗口等\r\n- 我们可以在时间的属性中设置一些js代码，当时间执行时代码就会执行\r\n- 可以为按钮的对应事件绑定处理函数来响应事件\r\n```js\r\nvar btn = document.getElementById(\"btn\");\r\nbtn.onclick = function(){\r\n\talert(\"别点我！\");\r\n};\r\n```\r\n- 浏览器在加载时自上向下加载，读取一行就运行一行\r\n- onload事件会在整个页面加载之后执行\r\n- 因此要将js代码统一写到window.onload = function(){}内\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\">\r\n    \twindow.onload = function(){\r\n    \t\tvar btn = document.getElementById(\"btn\");\r\n    \t\tbtn.onclick = function(){\r\n    \t\t\talert(\"别点我!\");\r\n    \t\t};\r\n    \t};\t\r\n    </script>\r\n</head>\r\n<body>\r\n\t<button id=\"btn\"></button>\r\n</body>\r\n</html>\r\n```\r\n\r\n###3.3DOM查询\r\n####3.3.1获取元素节点\r\n- 通过document对象调用\r\n1.getElementById() : 通过id属性获取一个元素节点对象\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\">\r\n        window.onload = function(){\r\n            var btn = document.getElementById(\"btn\");\r\n            btn.onclick = function () \r\n            {\r\n                var bj = document.getElementById(\"bj\");\r\n                // innerHTML 通过这个属性可以获取到元素内部的html代码\r\n                //innerHTML 不能获取自结束标签的内部（空）\r\n                alert(bj.innerHTML);\r\n            };\r\n        };\r\n    </script>\r\n</head>\r\n<body>\r\n    <button id=\"btn\">按钮</button>  \r\n</body>\r\n</html>\r\n```\r\n\r\n2.getElementsByTagName() : 通过标签名获取一组元素节点对象\r\n-  以数组形式返回\r\n\r\n3.getElementsByName() : 通过name属性获取一组元素节点对象\r\n- 以数组形式返回\r\n\r\n- 如果需要读取元素节点属性，直接使用元素.属性名读取，但class属性需要使用==.className==\r\n\r\n\r\n####3.3.2获取元素节点的子节点\r\n- 通过具体的元素节点调用\r\n1.getElementByTagName()\r\n2.childNodes : 获取包括文本节点在内的所有节点（**包含空白**）\r\n3.children : 获取当前元素的子元素\r\n4.fisrtChild : 获取当前节点的第一个子节点（**包含空白**）\r\n5.firstElementChild :  获取当前元素的第一个子元素\r\n6.lastChild\r\n7.parentNode : 获取当前元素的父节点\r\n8.previousSibling : 当前元素的前一个兄弟节点（**可能是空白**）\r\n9.previousElementSibling : 当前元素的前一个兄弟元素\r\n10.nextSibling\r\n\r\n####3.3.3绑定单击响应函数\r\n- 定义一个函数，专门用于为指定元素绑定单击响应函数\r\n- 参数：idStr 要绑定的对象的id\r\n\r\n==myClick(idStr,function(){});==\r\n\r\n- innerText : 元素内部的文本内容，与innerHTML类似，但它会自动将html标签去除\r\n\r\n\r\n####3.3.4DOM查询的其他方法\r\n- 在document中有一个属性body,保存的就是body的引用\r\n- document.documentElement保存的是html根标签\r\n- document.all保存的是页面里所有元素\r\n- 根据元素class属性值查询一组元素节点对象\r\n- document.querySelector()  以一个选择器字符串为参数，查询符合选择器的元素\r\n\t- 使用此方法只会返回一个元素，如果满足条件的元素有多个，只会返回第一个\r\n-  document.querySelectorAll() 可以返回满足条件的所有元素（**封装到数组中返回**）\r\n```js\r\nvar body = document.body;\r\nvar heml = document.documentElement;\r\nvar all = document.all;\r\nvar all1 = document.getElementsByName(\"*\");\r\n//获取class为box1的元素组\r\nvar box1 = document.getElementsByClassName(\"box1\");\r\n//获取box1中的所有div元素\r\nvar div = document.querySelector(\".box1 div\");\r\n```\r\n\r\n####3.3.5dom的增删改\r\n######appendChild()\r\n- 向一个父节点中添加一个子节点，用法： 父节点.appendChild(子节点);\r\n######removeChild()\r\n- 删除子节点， 用法： 父节点.removeChild(子节点)；\r\n######replaceChild()\r\n- 替换子节点， 用法： 父节点.replaceChild(新节点，旧节点)；\r\n######insertBefore()\r\n- 在指定子节点之前插入新的子节点， 用法： 父节点 .insertBefore(新节点,旧节点);\r\n######createElement()\r\n- 创建元素节点对象，需要标签名作为参数，将会根据标签名创建对象，并将创建好的对象返回\r\n######createTextNode()\r\n- 创建文本节点对象，需要文本内容作为参数，将会根据文本内容创建对象并将建好的节点返回\r\n```js\r\nvar li = document.createElement(\"li\");\r\nvar gzText = document.createTextNode(\"广州\");\r\nli.appendChild(gzText);\r\nvar city = document.getElementbyId(\"city\");\r\ncity.appendChild(li);\r\n//子节点.parentNode.removeChild(子节点);\r\nbj.parentNode.removeChilde(bj);\r\n//可以用修改innerHTML的内容实现增删改（**两种方式结合使用**）\r\ncity.innerHTML += <li>广州</li> ;\r\n```\r\n\r\n####3.3.6操作内联样式\r\n- 语法： ==元素.style.样式名 = 样式值==  （**样式值要为字符串**）\r\n\r\n- 样式名如果含 - ,修改为**驼峰式命名**（如background-color修改为backgroundColor)\r\n\r\n- 通过style属性设置的样式都是内联样式，内联样式的优先级很高但**不如 ! importent**\r\n\r\n- 读取样式 \r\n\t- 语法： 元素.style.样式名\r\n\t- 通过style属性**读取的也是内联样式，而非样式表中样式**\r\n\r\n####3.3.7获取元素的样式\r\n- 语法： getComputerStyle(box1，null);\r\n- window的对象，可以直接使用\r\n- 需要两个参数： \r\n\t\t1.要获取样式的元素\r\n\t\t2.传递一个伪元素，一般为null\r\n- 返回一个对象，对象封装了当前元素对应的样式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #box1 {\r\n            width: 100px;\r\n            height: 100px;\r\n            background-color: aqua;\r\n        }\r\n    </style>\r\n    <script>\r\n        window.onload = function(){\r\n            var box1 = document.getElementById(\"box1\");\r\n            var btn1 = document.getElementById(\"btn1\");\r\n            btn1.onclick = function () {\r\n                var obj = getComputedStyle(box1, null);\r\n                alert(obj.backgroundColor);     //rgb(0,255,255)\r\n                alert(obj.width);               //100px\r\n            };\r\n        };\r\n    </script>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"box1\"></div>\r\n    <button id=\"btn1\">click</button>\r\n</body>\r\n\r\n</html>\r\n```\r\n####3.3.8其他样式的相关属性\r\n######client\r\n- clientWidth\r\n- clientHeight\r\n\t- 获取元素的可见宽度或高度\r\n\t- 获取的属性值不带px，返回的是数值，可以直接进行计算\r\n\t- 宽度和高度包括内容区和内边距\r\n\t- 属性只可读，不可修改\r\n```js\r\nwindow.onload = function () {\r\n    var box1 = document.getElementById(\"box1\");\r\n    var btn1 = document.getElementById(\"btn1\");\r\n    btn1.onclick = function () {\r\n    var cw = box1.clientWidth;\r\n    var ch = box1.clientHeight;\r\n    alert(cw);            //100\r\n    alert(ch);            //200\r\n    };\r\n};\r\n```\r\n######offset\r\n- offsetWidth\r\n- offsetHeight\r\n\t- 获取元素的整个宽度或高度，包括内容区，内边距和边框\r\n- offsetParent\r\n\t- 获取当前元素的**定位父元素**\r\n\t- 获取离他最近的开启定位的祖先元素，若所有祖先元素都未开启，则返回body\r\n- offsetLeft\r\n\t- 当前元素相对于其**定位父元素**的水平偏移量\r\n- offsetTop\r\n\t- 当前元素相对于其**定位父元素**的垂直偏移量\r\n\r\n######scroll\r\n- scrollHeight\r\n- scrollWidth\r\n\t- 获取整个滚动区域的高度宽度\r\n- scrollLeft\r\n- scrollTop\r\n\t- 当前滚动条距上端距离\r\n\t当滚动到底时，满足scrollHeight - scrollTop == clientHeight\r\n- onscroll\r\n\t- 该事件会在元素的滚动条滚动时触发\r\n\t\r\n\t\r\n\r\n###3.4事件对象\r\n- 当事件的响应函数被触发时，浏览器每次都会将一个==事件对象作为实参传递进响应函数==\r\n- 在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘哪个值被按下，鼠标滚轮滚动的方向等\r\n- onmousemove : 在鼠标移动时触发\r\n- clientX  可以获取鼠标指针的水平坐标(**在当前可见窗口的坐标**)\r\n- clientY  可以获取鼠标指针的垂直坐标(**在当前可见窗口的坐标**)\r\n- pageX  可以获取鼠标相对于当前页面的坐标\r\n- pageY\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #areaDiv{\r\n            width: 400px;\r\n            height: 300px;\r\n            border: 1px black solid;\r\n        }\r\n    </style>\r\n    <script>\r\n        window.onload = function(){\r\n            var area = document.getElementById(\"areaDiv\");\r\n            area.onmousemove = function (event) {\r\n            var x = event.clientX;\r\n            var y = event.clientY;\r\n            show.innerHTML = \"x=\" + x + \",y=\" + y;\r\n            };\r\n        };\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"areaDiv\"></div>\r\n    <div id=\"show\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n###3.5事件的冒泡(Bubble)\r\n- 当后代元素事件被触发时，祖先元素的相同事件也会被触发（**事件的向上传导**）\r\n- 在开发中大部分冒泡是有益的，如果不希望事件发生冒泡，可以通过事件对象来取消冒泡\r\n- 语法 ：event.cancelBubble = true;\r\n\r\n###3.6事件的委派\r\n- 将事件的响应函数统一绑定给共同的祖先元素，当后代元素的事件触发时，会一直冒泡到祖先元素，从而通过祖先的响应函数处理事件\r\n- 事件的委派利用了冒泡，通过委派可以减少事件绑定次数，提高程序性能\r\n- 响应函数中的this是响应函数的绑定对象\r\n- 响应函数事件对象的target属性是触发事件的对象（谁触发，target就是谁）\r\n\r\n###3.7事件的绑定\r\n- 对象.事件 = function(){} 只能同时为一个对象的一个事件绑定一个响应函数\r\n- 若要为事件同时绑定多个响应函数，则需使用addEventListener()\r\n- 当使用addEventListener()绑定多个函数时，会按照绑定顺序依次触发\r\n- addEventListener()中的this是绑定事件的对象\r\n- 参数：\r\n\t1.事件的字符串（**不要on**）\r\n\t2.回调函数，当事件触发时该函数会被调用\r\n\t3.是否在捕获阶段触发事件，（**布尔值**），一般传**false**\r\n```js\r\nwindow.onload = function(){\r\n\tvar btn =document.getElementById(\"btn1\");\r\n\tbtn.addEventListener(\"click\",function(){\r\n\t\talert(1);\r\n\t},false);\r\n\tbtn.addEventListener(\"click\",function(){\r\n\t\talert(2);\r\n\t},false);\r\n\tbtn.addEventListener(\"click\",function(){\r\n\t\talert(3);\r\n\t},false);\r\n};\r\n```\r\n###3.8事件的传播\r\n1.捕获阶段\r\n2.目标阶段\r\n3.冒泡阶段\r\n- 如果希望在捕获阶段执行响应函数，可以将addEventListener()的第三个参数设为true\r\n\r\n  \r\n\r\n###3.9鼠标滚轮事件\r\n```js\r\nwindow.onload = function () {\r\n\tvar box1 = document.getElementById(\"box1\");\r\n\tbox1.onmousewheel = function (event) {\r\n\tif (event.wheelDelta > 0) {\r\n\t\tbox1.style.height = box1.clientHeight - 10 + \"px\";\r\n\t}  //获取滚轮方向，不看大小只看正负\r\n\telse {\r\n\t\tbox1.style.height = box1.clientHeight + 10 + \"px\";\r\n\t}\r\n\treturn false;\r\n\t//当滚轮滚动时，如果浏览器有滚动条，也会随之滚动，如果不希望发生，可以取消\r\n\t};\r\n};\r\n```\r\n\r\n###3.10键盘事件\r\n```js\r\nwindow.onload = function () {\r\n//键盘事件一般都会绑给可以获取焦点的对象或是document\r\n//键盘事件：   onkeydown按键按下 , 如果按着按键不松手会一直触发\r\n//onkeyup 按键松起\r\ndocument.onkeydown = function (event) {\r\n\tconsole.log(\"down\");\r\n\t//可以通过keyCode获得按键的编码\r\n\tif (event.keyCode == 89) {\r\n\t\tconsole.log(\"y\");\r\n\t}\r\n};\r\n//altKey  alt是否被按下，若按下返回true\r\n//ctrlKey\r\n//shiftKey\r\ndocument.onkeyup = function () {\r\n\tconsole.log(\"up\");\r\n};\r\nvar input = document.getElementsByTagName(\"input\")[0];\r\ninput.onkeydown = function (event) {\r\n\tconsole.log(\"down\");\r\n\t// return false;\r\n\t//取消默认行为，输入内容不会在文本框中显示\r\n\t//不能键入数字\r\n\tif(event.keyCode >=48 &&event.keyCode<=57){\r\n\t\treturn false;\r\n\t}\r\n};\r\n};\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n##Chapter4BOM\r\n###4.1BOM的简介\r\n- Browser Object Model==浏览器对象模型==\r\n- BOM可以使我们通过JS操作浏览器\r\n- 在BOM中为我们提供了一组对象，用于完成对浏览器的操作\r\n- BOM对象\r\n\t- Window\r\n\t\t- 代表整个浏览器的窗口，同时window也是网页中的全局对象\r\n\t- Navigator\r\n\t\t- 代表当前浏览器的信息，通过该对象可以识别不同的浏览器\r\n\t- Location\r\n\t\t- 代表当前浏览器的地址栏信息，通过该对象可以获取地址栏信息，或操作浏览器跳转页面\r\n\t- History\r\n\t\t- 代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录\r\n\t\t- 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页\r\n\t\t- 该操作只在当此访问有效\r\n\t- Screen\r\n\t\t-  代表用户屏幕的信息，可以获取到显示器相关信息\r\n\t- 这些对象在浏览器中都是作为window对象的属性保存的，可以通过window对象使用，也可以直接使用\r\n\r\n\r\n###4.2Navigator\r\n- 代表当前浏览器的信息，通过该对象可以识别不同的浏览器\r\n- 由于历史原因，Navigator对象中大部分属性已不能帮助我们识别浏览器了\r\n- appName : 返回浏览器的名称（**已失效**）\r\n- 一般只会使用**ueserAgent**来判断浏览器信息\r\n\t- ueserAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容\r\n\t- 不同浏览器会有不同的userAgent\r\n- 如果通过userAgent仍不能判断，可以通过一些浏览器特有的对象来判断\r\n\r\n###4.3History\r\n- 代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录\r\n- 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页\r\n- 该操作只在当前访问有效\r\n- length属性 ： 获取到当前页面的链接数量\r\n- back() : 回退到上一个页面（与浏览器的回退按钮作用相同）\r\n- forward() : 跳转到下一个页面（作用与浏览器的前进按钮相同）\r\n- go() : 跳转到指定页面，**需要一个整数作为参数**\t\t如：history.go(-1)；  与back()相同\r\n\r\n###4.4Location\r\n- 代表当前浏览器的地址栏信息，通过该对象可以获取地址栏信息，或操作浏览器跳转页面\r\n- 如果直接打印location可获取地址栏的信息（当前页面的完整路径）\r\n- 如果直接将location修改为一个完整的路径（或相对路径），则页面会跳转至该路径，并会生成相应历史记录\r\n- assign() : 用于跳转到其他页面，作用和直接修改location相同\r\n- reload() : 重新加载当前页面（与刷新按钮功能相同）\r\n\t- 如果传递true作为参数，刷新时会强制清空缓存\r\n- replace() : 可以使用一个新的页面替换当前页面，调用完毕也会跳转，但**不会生成历史记录**\r\n\r\n###4.5定时器\r\n- JS程序执行速度非常快\r\n- 如果希望一段程序每间隔一段时间执行一次，可以使用定时调用\r\n- setInterval()\r\n\t- 定时调用\r\n\t- 可以将一个函数每隔一段时间调用一次\r\n\t- 参数：\r\n\t\t1.回调函数，该函数会每隔一段时间被调用一次\r\n\t\t2.每次调用间隔的时间，单位是毫秒\r\n\t- 返回值：返回一个Number类型的数据，这个数字作为定时器的唯一标识\r\n- clearInterval()\r\n\t- 关闭定时器\r\n\t- 需要一个定时器的标识作为参数\r\n\t- 可以接受任意参数，如果参数是一个有效的标识则会停止对应函数；否则会什么也不做\r\n\t- ==开启每个定时器之前都要关闭上一次的定时器，以避免多次点击开启多个定时器（**妙蛙**）==\r\n- setTimeout()\r\n\t- 延时调用,延时调用一个函数不马上执行,而是隔一段时间以后再执行,**只执行一次**\r\n- clearTimeout()\r\n\t- 关闭延时调用\r\n\r\n\r\n###4.6类的操作\r\n- 通过修改元素的class属性来间接修改样式\r\n- 这样可以只修改一次就能同时修改多个样式，浏览器只需要渲染一次性能更好\r\n- 使表现和行为进一步分离\r\n```js\r\n//box.className += \" box2\";\r\nfunction hasClass(obj,cn){\r\n\tvar reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\");\r\n\treturn reg.test(obj.className);\r\n}\r\n//构造一个类添加函数\r\nfunction addClass(obj,cn){\r\n\tif(!hasClass(obj,cn)){\r\n\t\tobj.className += \" \"+cn;\r\n\t}\r\n}\r\naddClass(box,\"box2\");\r\n//构造删除函数\r\nfunction removeClass(obj,cn){\r\n\tvar reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\");\r\n\tobj.className = obj.className.replace(reg,\"\");\r\n}\r\n//toggleClass函数：如果有则删除，如果无则添加\r\nfunction toggleClass(obj,cn){\r\n\tif(hasClass(obj,cn)){\r\n\t\tremoveClass(obj,cn);\r\n\t}else{\r\n\t\taddClass(obj,cn);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n###4.7 JSON\r\n- JS中的对象，只有JS认识，其他语言都不认识\r\n- JSON就是一个特殊格式字符串，这个字符串可以被任何语言所识别并可以转换为任意语言中的对象\r\n- JSON在开发中主要用于数据的交互\r\n- ==JavaScript Object Notation  JS对象表示法==\r\n- JSON和JS对象格式一样，只不过JSON字符串中属性名必须加双引号，其他和JS语法一致\r\n- JSON的分类：\r\n\t\t1.对象{}\r\n\t\t2.数组[]\r\n- JSON中允许的值：字符串，数组，布尔值，null，对象，数组\r\n\r\n- 在JS中为我们提供了一个工具类，就叫JSON\r\n- 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON\r\n\t- JSON --> JS对象：\r\n\t\t==JSON.parse()==\r\n\t\t需要JSON字符串为参数，返回JS对象\r\n\t- JS对象 --> JSON：\r\n\t\t==JSON.stringify()==\r\n\t\t需要JS对象作为参数，返回JSON字符串\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#JS进阶\r\n\r\n\r\n##Chapter1 基础总结深入\r\n###1.1数据类型\r\n- 基本(值)类型\r\n\t- String\r\n\t- Number\r\n\t- Boolean\r\n\t- Null  定义并赋值，只是值为null；初始赋值为null表明将要赋值为对象；最后赋值为null释放内存（让对象成为垃圾对象被回收）\r\n\t- Undefined  定义未赋值\r\n- 对象(引用)类型\r\n\t- Object : 任意对象\r\n\t- Function : 一种特别的对象(可以执行)\r\n\t- Array : 一种特别的对象(数值下标)\r\n- typeof  用于判断数据类型,返回字符串  ==不能判断null与object  array与object==\r\n- instanceof  判断对象是否是某类的实例，返回布尔值\r\n- ===   可用于判断null和undefined类型\r\n- 变量类型和数据类型：变量类型是指变量保存的值的数据类型，变量类型常说引用类型，数据类型常说对象类型\r\n\r\n###1.2数据，内存和变量\r\n- 数据：存储在内存中代表特点信息的东西，本质上是010101...\r\n- 内存：内存条通电后产生的可存储数据的空间（临时的）\r\n\t- 一块内存产生两个数据：地址和存储的数据\r\n\t- 内存分类：\r\n\t\t- 栈：全局变量/局部变量\r\n\t\t- 堆：对象\r\n- 变量：可变化的量，由变量名和变量值组成；每个变量对应一块内存，变量名用于查找对应的内存；变量值就是对应内存中保存的数据\r\n\r\n三者之间的关系\r\n>内存是用来存储数据的空间，变量是内存的标识\r\n\r\n- 将变量的内容赋值给另一个变量，会将该变量在栈中的内容赋值给新变量\r\n- 两个变量指向同一个对象，修改其中一个的内容，另一个也随之改变\r\n- 两个变量指向同一个对象，一个指向新的对象，另一个不受影响\r\n- 函数以对象为参数时，可以理解为将对象的地址传递过去\r\n```js\r\nvar obj1={name:\"tom\",age:12}\r\nvar obj2 = obj1\r\nobj2.age = 12\r\nconsole.log(obj1.age)  //12\r\nfunction fn1(obj){\r\n\tobj.name = \"Alice\"\r\n}\r\nfn1(obj1)\r\nconsole.log(obj2.name)  //A\r\nfunction fn2(obj){\r\n\tobj = {age:18}  //obj指向了新的对象\r\n}\r\nfn2(obj1) //形参obj指向了新的对象，但实参obj1并没有\r\nconsole.log(obj1.age)  //12\r\n```\r\n- 需要使用['属性名']的情况：\r\n\t1. 当对象的属性名包含特殊字符（空格或分隔线）时\r\n\t2. 属性名不确定时\r\n```js\r\nvar p ={}\r\np['content-ypr'] = 'text/json'  //属性名包含特殊字符\r\nvar proName = 'myAge'  //属性名不确定\r\np[proName] = 18\r\n```\r\n\r\n\r\n###1.3函数\r\n1.什么是函数？\r\n>实现特点功能的语句的封装体\r\n\r\n2.为什么要用函数？\r\n>提高代码复用，便于阅读交流\r\n\r\n3.如何定义函数？\r\n>函数声明\r\n>表达式\r\n\r\n4.如何调用函数？\r\n>直接调用\r\n>通过对象调用\r\n>new调用\r\n>call/apply()调用  fn.call(obj)  可以让一个函数为指定对象调用（临时让fn函数成为 obj的方法）\r\n\r\n###1.4回调函数\r\n1.什么是回调函数？\r\n>1)你定义的 2) 你未调用 3) 最终执行了\r\n\r\n2.常见的回调函数？\r\n>dom事件回调函数，定时器回调函数，ajax请求回调函数，生命周期回调函数\r\n\r\n\r\n###1.5IIFE\r\n- ==Immediately-Invoked Function Expreesion立即执行函数表达式==\r\n- 作用：\r\n\t1.隐藏实现\r\n\t2.不会污染外部(全局)命名空间\r\n```js\r\n(function(){  //匿名函数自调用\r\n\tvar a;\r\n\tconsole.log(a);\r\n})();\r\n```\r\n\r\n###1.6this\r\n1.this是什么？\r\n>所有函数内部都有一个变量this，它的值是调用函数的当前对象\r\n\r\n2.如何确定this的值？\r\n>test()  : window\r\n>p.test() :  p \r\n>new test() : 新建的对象\r\n>p.test().call(obj) : obj\r\n\r\n###1.7分号问题\r\n1.可以不加分号\r\n2.以下情况下不加分号会出问题：小括号开头的前一条语句，中方括号开头的前一条语句\r\n3.解决方法：在行首加分号\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n##Chapter2 函数高级\r\n###2.1原型与原型链\r\n####2.1.1原型\r\n- 我们创建的每一个函数,解析器都会向函数中添加一个属性==prototype(显示原型)==\r\n- 这个属性对应着一个对象,就是原型对象(默认是**空Object对象**)\r\n- 原型对象中有一个constructor属性指向函数对象\r\n- 如果函数作为普通函数调用,prototype没有任何作用\r\n- 如果函数作为构造函数调用时,它所创建的对象中都会有一个隐含的属性指向该构造函数的原型对象\r\n\t- 每个实例对象都有一个==\\_\\_proto\\_\\_(隐式原型)==属性\r\n\t- 对象的隐式原型即为其构造函数的显示原型即==per.\\_\\_proto\\_\\_ = = = Person.prototype==\r\n\r\n```\tjs\r\n\tfunction Person(name,age,gender){\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.gender = gender; \r\n\t}\r\n\tPerson.prototype.sayName = function(){\r\n\t\talert(this.name);\r\n\t}\r\n\tvar per = new Person(\"玉兔\",16,\"女\");\r\n```\r\n\r\n####2.1.2※原型链\r\n- 原型对象就相当于一个公共区域,同一个类的所有实例都可以访问到这个原型对象\r\n\t- 可以将对象中共有的内容统一设置到原型对象中\r\n- ==自身中没有去原型中找，原型中没有沿着**\\_\\_proto\\_\\_**找，直到Object的原型对象(Object的原型对象的\\_proto\\_为null)==\r\n- 所有函数都有两个原型属性，一个隐式原型一个显式原型\r\n- 函数的显式原型指向它的原型对象，原型对象一般默认是**空的Object实例对象**\r\n\t- ==但Object自己的原型对象不是Object的实例，也不是空的==\r\n\t- ==所有函数都是Fuction的实例，包括它本身==\r\n\t- Object的原型对象是==原型链尽头==\r\n- ==所有函数的原型对象都是Object的实例(Object除外)==\r\n- ==Function()函数是由自己创建的，因此它的隐式原型与显式原型指向同一个原型对象==\r\n- ==所有函数的隐式原型都指向Function()的原型对象==\r\n- ==原型对象也是对象，它也有原型==\r\n- 在Object的原型中仍没找到，则返回undefined\r\n\r\n\r\n\r\n1.读取对象的属性值时，会沿着原型链查找\r\n\r\n2.设置对象的属性值时，**不会查找原型链，如果当前对象中没有此属性，直接添加此属性并且设置其值**\r\n\r\n3.**方法一般定义在原型中，属性一般通过构造函数定义在对象本身**\r\n\r\n\r\n\r\n####2.1.3instanceof\r\n1.instanceof是如何判断的？\r\n> A instanceof B\r\n> 如果B函数的显式原型对象在A对象的原型链上，就说明A是B的实例，则返回true，否则返回false\r\n> Object instanceof Function //True\r\n> Object instanceof Object  //True\r\n> Fuction instanceof Function  //True\r\n> Function instanceof Object  //True\r\n\r\n\r\n\r\n\r\n\r\n- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true\r\n- 使用per.hasOwnProperty()检查对象自身中是否含有该属性\r\n\r\n###2.2执行上下文与执行上下文栈\r\n\r\n####2.2.1变量提升与函数提升\r\n1.变量提升：\r\n\r\n- 使用**var关键字声明的变量，会在所有代码执行前被声明（但不会赋值）**\r\n- 如果不使用var关键字，则变量不会被声明提前\r\n\r\n2.函数提升：\r\n\r\n- 使用**函数声明**创建的函数，**可以在创建前使用**（在所有代码创建前被创建）\r\n- 使用**函数表达式**创建的函数**会被变量提升而非函数提升**，因此不能在声明前使用\r\n\r\n\r\n####2.2.2执行上下文\r\n- 代码可分为全局代码和局部代码(即函数代码)\r\n\r\n- 全局执行上下文\r\n\t- 在执行全局代码前将window确定为全局执行上下文\r\n\t- 对全局数据进行预处理\r\n\t\t- var 定义的全局变量  ==>undefined,添加为window的属性\r\n\t\t- function定义的全局函数 ==>赋值(fun)，添加为window的方法\r\n\t\t- this ==>赋值(window)\r\n\t- 开始执行全局代码\r\n\t\r\n- 函数执行上下文\r\n\t- 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象\r\n\t- 对局部数据进行预处理\r\n\t\t- 形参变量==>赋值(实参)==>添加为执行上下文的属性\r\n\t\t- arguments==>赋值 (实参列表),添加为执行上下文的属性\r\n\t\t- var 定义的局部变量==>undefined,添加为执行上下文的属性\r\n\t\t- function声明的函数==>赋值(fun),添加为执行上下文的方法\r\n\t\t- this ==>赋值(调用函数的对象)\r\n\t- 开始执行函数体代码\r\n\r\n####2.2.3执行上下文栈\r\n1.在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象\r\n2.在执行全局上下文window确定后，将其添加到栈中（压栈）\r\n3.在函数执行上下文创建后，将其添加到栈中（压栈）\r\n4.在当前函数执行完后，将栈顶的对象移除（出栈）\r\n5.当所有的代码执行完后，栈中只���下window\r\n\r\n\r\n```js\r\nconsole.log(\"global begin:\"+i)\r\nvar i = 1\r\nfoo(1)\r\nfunction foo(i){\r\n\tif(i == 4){\r\n\t\treturn;\r\n\t}\r\n\tconsole.log('foo() begin:'+ i);\r\n\tfoo(i+1);  //递归调用\r\n\tconsole.log('foo() end:'+ i);\r\n}\r\nconsole.log('global end:'+ i);\r\n```\r\n1. 依次输出什么？\r\n> gb:undefined\r\n> fb:1\r\n> fb:2\r\n> fb:3\r\n> fe:3\r\n> fe:2\r\n> fe:1\r\n> ge:1\r\n\r\n2.整个过程产生了几次执行上下文？\r\n>5次，共调用4次函数，一次window\r\n\r\n\r\n```js\r\nfunction a(){}\r\nvar a\r\nconsole.log(typeof a)  //'function'\r\n```\r\n>先执行变量提升，再执行函数提升\r\n\r\n```js\r\nif(!(b in window)){\r\n\tvar b = 1\r\n}\r\nconsole.log(b)  //undefined\r\n```\r\n>变量提升，b在window里面\r\n\r\n\r\n```js\r\nvar c = 1\r\nfunction c(c){\r\n\tconsole.log(c)\r\n}\r\nc(2) //报错\r\n```\r\n>先变量提升再函数提升，因此最后将c赋值为1，c不是函数无法调用\r\n\r\n###2.3作用域与作用域链\r\n\r\n####2.3.1作用域\r\n- 作用域：（**n+1**)\r\n\t- 变量作用的范围（一个代码块所在的区域）\r\n\t- 静态的（相对于上下文执行对象），在编写代码时就确定了\r\n\r\n- 分类\r\n\t- 全局作用域\r\n\t- 函数作用域（定义几个函数就有几个函数作用域）\r\n- 作用：隔离变量，不同作用域下同名变量不会有冲突\r\n- 在函数中要访问全局变量可以使用window对象\r\n- 在函数中不使用var声明的变量，都会成为全局变量\r\n- 定义形参就相当于在函数中声明了一个变量\r\n####2.3.2作用域与执行上下文\r\n1.区别：\r\n- 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而非函数调用时\r\n- 全局执行上下文环境时全局作用域确定之后，js代码马上执行之前创建\r\n- 函数执行上下文是在调用函数时，函数体代码执行之前创建\r\n- 作用域是静态的，只要函数定义好了就一直存在且不会变化\r\n- 执行上下文环境是动态的，调用函数时创建，函数调用结束时执行上下文环境就会被释放\r\n\r\n2.联系：\r\n- 执行上下文环境是从属于所在的作用域\r\n- 全局执行上下文环境 ==>全局作用域\r\n- 函数执行上下文环境 ==>对应的函数作用域\r\n\r\n####2.3.3作用域链\r\n- 多个上下级关系的作用域形成的链，方向是从下向上（从内到外）\r\n- 查找变量时沿着作用域链查找\r\n- 先在当前作用域查找，若找不到则去上一级作用域，直到全局作用域\r\n```js\r\nvar x = 10\r\nfunction fn(){\r\n\tconsole.log(x)\r\n}\r\nfunction show(f){\r\n\tvar x = 20\r\n\tf()\r\n}\r\nshow(fn)  //10\r\n```\r\n>在fn的作用域中找x，找不到则去全局作用域中找，而不会去show的作用域中找\r\n```js\r\nvar fn = function(){\r\n\tconsole.log(fn)\r\n}\r\nfn()  //f{}\r\nvar obj = {\r\n\tfn2:function(){\r\n\t\tconsole.log(fn2)\r\n\t}\r\n}\r\nobj.fn2()  //报错\r\n```\r\n>在作用域中无法找到fn2，在全局里也无法找到，因此报错，若输出this.fn2才能找到\r\n\r\n###2.4闭包Closure\r\n####2.4.1理解闭包\r\n1.如何产生闭包？\r\n>当一个嵌套的内部函数引用了嵌套的外部函数的变量时，就产生了闭包\r\n\r\n2.闭包到底是什么？\r\n>使用chrome调试查看\r\n>理解一：闭包是嵌套的内部函数\r\n>理解二：闭包是被引用变量的对象\r\n\r\n3.产生闭包的条件？\r\n>1.函数嵌套\r\n>2.内部函数引用了外部的数据\r\n>3.外部函数被执行(执行内部函数定义，不用调用内部函数)\r\n\r\n####2.4.2常见的闭包\r\n1.将函数作为另一个函数的返回值\r\n```js\r\nfunction fn1(){\r\n\tvar a = 2\r\n\tfunction fn2 (){\r\n\t\ta++\r\n\t\tconsole.log(a)\r\n\t}\r\n\treturn fn2\r\n}\r\nvar f = fn2\r\nf()  //3\r\nf()  //4\r\n```\r\n整个过程只产生了一个闭包（只调用一次fn1，产生一次fn2的定义）\r\n\r\n2.将函数作为实参传递给另一个函数调用\r\n```js\r\nfunction showDelay(msg,time){\r\n\tsetTimeout(function(){\r\n\t\talert(msg)  //内部函数引用了外部的变量msg\r\n\t},time)\r\n}\r\nshowDelay('atjlu',2000)  //调用外部函数，因此产生了闭包\r\n```\r\n####2.4.3闭包的作用\r\n```js\r\nfunction fn1(){\r\n\tvar a = 2\r\n\tfunction fn2 (){\r\n\t\ta++\r\n\t\tconsole.log(a)\r\n\t}\r\n\treturn fn2\r\n}\r\nvar f = fn2\r\nf()  //3\r\nf()  //4\r\n```\r\n1.使用函数内部的变量在函数执行完后，仍然存活在内存中（**延长了局部变量的生命周期**）\r\n2.让函数外部可以操作（读写）到函数内部的数据（变量/函数）\r\n\r\n1.函数执行完毕后，函数内部声明的局部变量是否还存在？\r\n>内部函数本身不存在了，但闭包里的变量还存在\r\n\r\n2.在函数外部能否直接访问函数内部的局部变量？\r\n>不能，但是可以通过闭包让外部操作它\r\n\r\n####2.4.4闭包的生命周期\r\n产生：在嵌套内部函数定义执行完时就产生了（**而非调用时**）\r\n死亡：在嵌套内部函数成为垃圾对象时\r\n```js\r\nfunction fn1(){\r\n\t//此时闭包就已产生（函数提升）\r\n\tvar a = 2\r\n\tfunction fn2 (){\r\n\t\ta++\r\n\t\tconsole.log(a)\r\n\t}\r\n\treturn fn2\r\n}\r\nvar f = fn2\r\nf()  //3\r\nf()  //4\r\nf = null  //闭包死亡（包含闭包的函数对象成为垃圾对象  \r\n```\r\n####2.4.5闭包的应用：自定义JS模块\r\nJS模块：\r\n- 具有特定功能的js文件\r\n- 将所有数据和功能封装到一个函数内部\r\n- 只向外暴露一个包含n个方法的对象或函数\r\n- 模块的使用者只需要通过模块暴露的对象调用方法来实现对应功能\r\n\r\n```js\r\nfunction myModule(){\r\n\tvar msg = 'jlu'  //私有数据\r\n\t//操作数据的函数\r\n\tfunction doSth(){\r\n\t\tconsole.log('doSth()'+ msg.toUppercase())\r\n\t}\r\n\tfunction doOtherthing(){\r\n\t\tconsole.log('doOtherthing()'+msg.toLowerCase())\r\n\t}\r\n\t//向外暴露对象\r\n\treturn {\r\n\t\tdoSth:doSth,\r\n\t\tdoOtherthing:doOtherthing\r\n\t}\r\n}\r\nvar module = myModule()\r\nmodule.doSth()\r\nmodule.doOtherthing()\r\n```\r\n\r\n```js\r\n(function (){\r\n\tvar msg = 'jlu'  //私有数据\r\n\t//操作数据的函数\r\n\tfunction doSth(){\r\n\t\tconsole.log('doSth()'+ msg.toUppercase())\r\n\t}\r\n\tfunction doOtherthing(){\r\n\t\tconsole.log('doOtherthing()'+msg.toLowerCase())\r\n\t}\r\n\t//向外暴露对象(给外部使用的方法)\r\n\twindow.myModule2 = {\r\n\t\tdoSth:doSth,\r\n\t\tdoOtherthing:doOtherthing\r\n\t}\r\n})()\r\nmyModule2.doSth()\r\nmyModule2.doOtherthing()\r\n```\r\n\r\n####2.4.6闭包的缺点及解决\r\n缺点：\r\n\t1.函数执行完后，函数内的局部变量没有释放，占用内存时间会变长\r\n\t2.容易造成内存泄漏\r\n解决：\r\n\t1.能不用闭包就不用闭包\r\n\t2.及时释放\r\n\r\n内存溢出:\r\n- 一种程序运行出现的错误\r\n- 当程序运行需要的内存超过了剩余的内存时,就出现内存溢出的错误\r\n\r\n内存泄漏:\r\n- 占用的内存没有及时释放\r\n- 内存泄漏积累多了就容易导致内存溢出\r\n- 常见的内存泄露:\r\n\t- 意外的全局变量\r\n\t- 没有及时清理的计时器或回调函数\r\n\t- 闭包\r\n\r\n```js\r\nvar name = 'The Window'\r\nvar object = {\r\n\tname : 'My Object',\r\n\tgetNameFunc : function(){\r\n\t\treturn function(){\r\n\t\t\treturn this.name\r\n\t\t}\r\n\t}\r\n}\r\nalert(object.getNameFunc()())  //  The window  (即输出this.name)\r\n```\r\nobject.getNameFunc( )是一个函数(最内层的函数),这里是window直接调用它,因此this是window\r\n```js\r\nvar name = 'The Window'\r\nvar object = {\r\n\tname : 'My Object',\r\n\tgetNameFunc : function(){\r\n\t\tvar that = this\r\n\t\treturn function(){\r\n\t\t\treturn that.name\r\n\t\t}\r\n\t}\r\n}\r\nalert(object.getNameFunc()())  //  My Object   (that处的this是什么?)\r\n```\r\nthat保存的是调用外层函数时的this, 而外层函数是由object调用的,因此此处的this是object\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n##Chapter3 面向对象高级\r\n\r\n###3.1面向对象编程介绍\r\n- 面向过程编程POP(Process-oriented progranmming): 分析出解决问题所需的步骤，然后按照步骤一步一步实现\r\n- 面向对象编程OOP(Object Oriented Programming) : 把事务分解成一个个对象，然后由对象之间分工与合作\r\n- 面向对象的特性：\r\n\t1.封装性\r\n\t2.继承性\r\n\t3.多态性\r\n\r\n###3.2对象创建模式\r\n\r\n方式一：Object构造函数模式\r\n\r\n- 适用于一开始不确定对象属性的时候\r\n- 缺点：语句太多\r\n```js\r\nvar p = new Object()\r\np.name = 'Tom'\r\np.age = 12\r\n```\r\n方式二：对象字面量模式\r\n- 使用{}创建对象，同时指定属性和方法\r\n- 适用于起始时内部数据确定\r\n- 缺点：创建多个对象时代码有重复\r\n```js\r\nvar p = {\r\n\tname : 'Tom',\r\n\tage : 12,\r\n\tsetName : function(name){\r\n\t\tthis.name = name\r\n\t}\r\n}\r\n```\r\n方式三：工厂模式（**基础2.2.7**）\r\n- 通过工厂函数动态创建对象并返回\r\n- 适用于需要创建多个对象的场景\r\n- 缺点：不同类型无法得以体现\r\n\r\n```js\r\nfunction createPerson(name,age){\r\n\tvar obj = {\r\n\t\tname : name,\r\n\t\tage : age,\r\n\t\tsetName : function (name){\r\n\t\t\tthis.name = name\r\n\t\t}\r\n\t}\r\n    return obj\r\n}\r\nvar p1 = createPerson('Tom',12)\r\n```\r\n方式四：自定义构造函数模式（**基础2.2.8**）\r\n- 自定义构造函数，通过new创建对象\r\n- 适用于需要创建多个类型确定的对象\r\n- 缺点：每个对象都有相同的数据，浪费内存\r\n```js\r\nfunction Person(name,age){\r\n\tthis.name = name\r\n\tthis.age = age\r\n\tthis.setName = function(name){\r\n\t\tthis.name = name\r\n\t}\r\n}\r\nvar per = new Person('Jack',16)\r\n```\r\n方式五：**构造函数+原型的组合模式**\r\n```js\r\nfunction Person(name,age){  //在构造函数中只初始化属性\r\n\tthis.name = name\r\n\tthis.age = age\r\n}\r\nPerson.prototype.setName = function(name){  //类的方法保存在原型里\r\n\tthis.name = name\r\n}\r\nvar per = new Person('Jack',16)\r\n```\r\n\r\n###3.3继承模式\r\n####3.3.1原型链继承\r\n1. 定义父类型构造函数\r\n2. 给父类型的原型添加方法\r\n3. 定义子类型的构造函数\r\n4. 创建父类型的对象赋值给子类型的原型\r\n5. 将子类型原型的构造属性设置为子类型\r\n6. 给子类型原型添加方法\r\n7. 创建子类型的对象：可以调用父类型的方法\r\n- **子类型的原型为父类型的一个实例对象**\r\n\r\n```js\r\n//父类型\r\nfunction Supper(){  //Step1\r\n\tthis.supProp = 'Supper property'\r\n}\r\nSupper.prototype.showSupperProp = function(){  //Step2\r\n\tconsole.log(this.supProp)\r\n}\r\n//子类型\r\nfunction Sub(){  //Step3\r\n\tthis.subProp = 'Sub property'\r\n}\r\nSub.prototype = new Supper()  //Step4子类型的原型为父类型的一个实例对象\r\nSub.prototype.constructor = Sub  //Step5,若没有这一步，对象sub的构造函数为Supper()\r\nSub.prototype.showSubProp = function(){  //Step6\r\n\tconsole.log(this.subProp)  \r\n}\r\n\r\nvar sub = new Sub()  //Step7\r\nsub.showSupperProp()  //Supper property\r\nconsole.log(sub.constructor)  //Sub() \r\n```\r\n####3.3.2借用构造函数继承（假）\r\n1. 定义父类型构造函数\r\n2. 定义子类型构造函数\r\n3. 在子类型构造函数中调用父类型构造函数\r\n- **在子类型构造函数中通过call()调用父类型构造函数**\r\n- ==用于继承父类型的属性==\r\n```js\r\nfunction Person(name,age){  \r\n\tthis.name = name\r\n\tthis .age = age\r\n}\r\nfunction Student(name,age,grade){\r\n\tPerson.call(this,name,age)//相当于this.Person(name,age)\r\n\tthis.grade = grade\r\n}\r\nvar s = new Student('Tom',20,9)\r\nconsole.log(s.name,s.age,s.grade)  //Tom 20 9\r\n```\r\n\r\n####3.3.3组合继承\r\n==原型链+借用构造函数的组合继承==\r\n1. 利用原型链实现对父类型对象的方法继承\r\n2. 利用call()借用父类型构造函数初始化相同属性\r\n\r\n\r\n\r\n##Chapter4 线程机制与事件机制\r\n###4.1进程与线程\r\n######进程process\r\n程序的一次执行，它占有一片独有的内存空间，可以通过windows任务管理器查看进程\r\n######线程thread\r\n是进程内一个独立执行单元，是程序执行的一个完整流程，是CPU最小的调度单元\r\n\r\n- 应用程序必须运行在某个进程的某个线程上\r\n- 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建\r\n- 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的\r\n- 一个进程内的数据可以提供其中的多个线程直接共享\r\n- 多个进程之间数据不能直接共享\r\n- 线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复利用\r\n\r\n何为多进程和多线程？\r\n>多进程运行：一应用程序可以同时启动多个实例运行\r\n>多线程：在一个进程内，同时有多个线程运行\r\n\r\n比较单线程与多线程？\r\n>多线程：优点：能有效提高CPU利用率；缺点：创建多线程开销，线程间切换开销，死锁与状态同步问题\r\n>单线程：优点：顺序编程简单易懂；缺点：效率低\r\n\r\nJS是单线程还是多线程？\r\n>js是单线程运行的，但使用H5中的Web Workers可以多线程运行\r\n\r\n浏览器运行是单线程还是多线程？\r\n>都是多线程运行的\r\n\r\n浏览器运行是单进程还是多进程？\r\n>有单进程的也有多进程的(chrome)\r\n\r\n###4.2浏览器内核\r\n- 支撑浏览器运行的最核心的程序\r\n- 不同浏览器可能不太一样：webkit(Chrome,Safari), Gecko(firefox), Trident, Trident+webkit\r\n- 内核由很多模块组成：\r\n\t主线程\r\n\t- js引擎模块：负责js程序的编译与运行\r\n\t- html,css文档解析模块：负责页面文本的解析\r\n\t- DOM/CSS模块：负责dom/css在内存中的相关处理\r\n\t- 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）\r\n\t- .......\r\n\t分线程\r\n\t- 定时器模块：负责定时器的管理\r\n\t- 事件响应模块：负责事件的管理\r\n\t- 网络请求模块：负责ajax请求\r\n\t###4.3定时器引发的思考\r\n1. 定时器真的是定时执行的吗?\r\n>定时器并不能保证真正定时执行\r\n>一般会延迟一点点（可接受），也有可能延迟很久（不可接受）\r\n\r\n2. 定时器回调函数是在分线程执行的吗？\r\n>在主线程执行的，（JS是单线程的）\r\n\r\n3. 定时器如何实现？\r\n>事件循环模型\r\n\r\n\r\n###4.4JS是单线程执行的\r\n- alert会暂停当前主线程的执行，同时也会暂停定时器的计时，直到点击确定后才会恢复程序执行和计时（2022不暂停计时了）\r\n\r\n代码分类：初始化代码，回调代码\r\njs引擎执行代码的基本流程：先执行初始化代码，设置监听器，绑定事件监听，发生 ajax请求，后面才会执行回调代码\r\n\r\n###4.5浏览器的事件循环模型\r\n1. 所有代码分类\r\n- 初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码\r\n- 回调执行代码（异步代码）：处理回调逻辑\r\n2. js引擎执行代码的基本流程\r\n- 初始化代码===> 回调代码\r\n3. 模型的2个重要组成部分\r\n- 事件管理模块\r\n- 回调队列\r\n4. 模型的运转流程\r\n- 执行初始化代码，将事件回调函数交给对应模块管理\r\n- 当事件发生时，管理模块会将回调函数及其数据添加到回调列队中\r\n- 只有当初始化代码执行完毕后（可能要一定时间），开会遍历读取回调队列中的回调函数执行\r\n\r\n###4.6 H5 Web Woekers(多线程)\r\n1. H5规范提供了js分线程的实现，取名Web Workers\r\n2. 相关API ：\r\n- Worker : 构造函数，加载分线程执行的js文件\r\n- Woker.prototype.onmessage : 用于接收另一个线程的回调函数\r\n- Woker.prototype.postMessage : 向另一个线程发送消息\r\n3. 不足；\r\n- worker内代码不能操作DOM（更新UI）\r\n- 不能跨域加载JS\r\n- 不是每个浏览器都支持这个新特性\r\n```js\r\nvar number = new Worker('worker.js')\r\nworker.onmessage = function(event){\r\n\tconsole.log('主线程接收分线程返回的数据：'+event.data)\r\n\talert(event.data)\r\n}\r\nworker.postMessage(number)\r\nconsole.log('主线程向分线程发送数据：'+number)\r\n```\r\n\r\n\r\n```js\r\nvar onmessage = function(event){\r\n\tvar number = event.data\r\n\tconsole.log('分线程接收到主线程的数据：'+number)\r\n\tvar result = fibonacci(number)\r\n\tpostMessage(result)\r\n\tconsole.log('分线程向主线程返回数据：'+result)\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# ES6+\r\n\r\nECAM(European Computer Manafacturers Association)欧洲计算机制造商协会（ECMA国际）\r\nES（ECMAScript)：ECMA国际制作的脚本程序设计语言\r\n\r\n## Chapter1ES6\r\n\r\n### 1.1 let关键字\r\n\r\n```js\r\nlet a\r\nlet b,c\r\nlet star\r\nlet star //报错\r\n{\r\n\tlet girl = 'Alice'\r\n}\r\nconsole.log(girl)  //报错\r\nconsole.log(song)  //报错\r\nlet song = 'faded'\r\n{\r\n\tlet school\r\n\tfunction(){\r\n\t\tconsole.log(school)\r\n\t}\r\n}\r\n\r\n```\r\n对比var 关键字\r\n- let声明变量不能重复声明\r\n- let具有块级作用域\r\n- 不存在变量提升\r\n- 不影响作用域链\r\n\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        .item {\r\n            height: 100px;\r\n            width: 200px;\r\n            border: 2px skyblue solid;\r\n            float: left;\r\n            margin: 20px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <h2>点击切换颜色</h2>\r\n    <div class=\"item\"></div>\r\n    <div class=\"item\"></div>\r\n    <div class=\"item\"></div>\r\n    <script>\r\n        let items = document.getElementsByClassName(\"item\")\r\n        for(var i = 0;i<items.length;i++){\r\n            items[i].onclick = function(){\r\n                this.style.background = 'pink'\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n-  如果for循环中使用var关键字声明i，代码会先执行整个循环，因此点击函数响应时i已经为3；而使用let关键字每一次循环的i互不影响，因此每次i都是当前值\r\n\r\n\r\n\r\n### 1.2 const关键字\r\n\r\n```js\r\n//声明常量\r\nconst SCHOOL = 'jlu'\r\n{\r\n\tconst A = 100\r\n}\r\nconsole.log(A)  //报错\r\nconst TEAM = ['uzi','mlxg','lapi']\r\nTEAM.push('lapi')  //不会报错\r\nTEAM = 100 //会报错\r\n\r\n```\r\n1. 一定要赋初值\r\n2. 一般常量用大写\r\n3. 常量的值不能修改\r\n4. 也是块级作用域\r\n5. 对于数组和对象的元素修改，不算做对常量做修改，不会报错\r\n\r\n###1.3变量的解构赋值\r\nES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为结构赋值\r\n1. 数组的解构\r\n```js\r\nconst F4=['拉皮','辣皮','啦皮','辣啤']\r\nlet [a,b,c,d] = F4\r\nconsole.log(a) //拉皮\r\nconsole.log(d) //辣啤\r\n```\r\n2. 对象的解构\r\n```js\r\nconst zhao = {\r\n\tname: '赵本山',\r\n\tage: 60,\r\n\txiaopin: function () {\r\n\t\tconsole.log(\"我可以演小品\")\r\n \t}\r\n}\r\nlet { name, age, xiaopin } = zhao\r\nconsole.log(name)\r\nconsole.log(xiaopin)\r\nxiaopin()\r\n```\r\n\r\n### 1.4模板字符串\r\n\r\nES6引入了新的声明字符串方式   \\` \\`        '  '  \"  \"\r\n\r\n```js\r\n//声明\r\nlet str = `我也是一个字符串哦！`\r\nconsole.log(str,typeof str) //我也是一个字符串哦!  string\r\n//内容中可以直接出现换行符，而'',\"\"均不可出现换行符\r\nlet str1 = `<ul>\r\n\t\t\t<li>沈腾\r\n\t\t\t</li>\r\n\t\t\t</ul>`\r\n//变量拼接\r\nlet lovest = '贾玲'\r\nlet out =`${lovest}是我最喜欢的喜剧演员`\r\nconsole.log(out)  //贾玲是我最喜欢的喜剧演员\r\n```\r\n\r\n### 1.5对象的简化写法\r\n\r\nES6允许在大括号里，直接写入变量和函数作为对象的属性和方法\r\n\r\n```js\r\nlet name ='lapi'\r\nlet change = function(){\r\n\tconbsole.log('我们可以改变')\r\n}\r\nconst school = {\r\n\tname,\r\n\tchange,\r\n\timprove(){\r\n\t\tconsole.log('我们可以提高')\r\n\t}\r\n}\r\nconsole.log(school)\r\n```\r\n\r\n### 1.6箭头函数\r\n\r\n```js\r\nlet fn = function(a,b){\r\n\treturn a+b\r\n}\r\nlet fn1 = (a,b) => {\r\n\treturn a+b\r\n}\r\n\r\n//1. this 是静态的，始终指向函数声明时所在作用域下的this的值\r\nfunction getName(){\r\n\tconsole.log(this.name)\r\n}\r\nlet getName2 = () =>{\r\n\tconsole.log(this.name)\r\n}\r\n//设置window对象的name属性\r\nwindow.name = 'sgg'\r\nconst SCHOOL = {\r\n\tname:'jlu'\r\n}\r\n//直接调用\r\ngetName() //sgg\r\ngetname2() //sgg\r\n//call方法调用\r\ngetName.call(SCHOOL)//jlu\r\ngetName2.call(SCHOOL)//sgg\r\n\r\n//2.不能作为构造函数实例化对象\r\nlet Person = (name,age) =>{\r\n\tthis.name = name\r\n\tthis.age = age\r\n}\r\nlet me = Person('lapi',20) //报错\r\n\r\n//3. 不能使用arguments变量\r\nlet fn2 = () =>{\r\n    console.log(arguments)\r\n}\r\nfn2(1,2,3)  //报错\r\n\r\n//4. 箭头函数的简写\r\n//(1)当形参有且仅有一个时可以省略小括号\r\n//(2)当代码体只有一条语句时省略大括号，此时return必须省略，语句执行的结果就是返回值\r\nlet add = n =>{\r\n\treturn n+n\r\n}\r\nlet pow = n => n*n\r\nconsole.log(pow(8))  //64\r\n```\r\n\r\n箭头函数实践\r\n- this是静态的\r\n```js\r\nlet ad = document.getElementById(\"box\")\r\nad.onclick = function(){\r\n\t//let  self = this\r\n\tsetTimeout(() => {\r\n\t\t//self.style.background='pink'\r\n\t\tthis.style.background='pink'\r\n\t},2000)\r\n}\r\nconst arr = [1,6,9,20,15]\r\nconst result = arr.filter(item => item%2===0)\r\nconsole.log(result)\r\n```\r\n- 箭头函数适合与this无关的回调，定时器，数组的方法回调\r\n- 箭头函数不适合与this 有关的回调，事件回调，对象的方法\r\n\r\n### 1.7函数参数的默认值设置\r\n\r\n- ES6允许给函数参数赋值初始值\r\n1. 形参初始值(具有默认值的参数一般位置要靠后)\r\n2. 与解构赋值结合\r\n```js\r\nfunction add(a,b,c=10){\r\n\treturn a+b+c\r\n}\r\nlet result = add(1,2)\r\nconsole.log(result)\r\n\r\nfunction connect({host='127.0.0.1',username,password,post}){\r\n\tconsole.log(host)\r\n\tconsole.log(username)\r\n\tconsole.log(password)\r\n\tconsole.log(post)\r\n}\r\nconnect({\r\n\tusername:'root',\r\n\tpassword:'root',\r\n\tpost:3306\r\n})\r\n```\r\n\r\n### 1.8rest参数   \r\n\r\nES6引入 rest参数，用于获取函数的实参，用来代替arguments\r\n\r\n```js\r\n//ES5获取实参的方式\r\nfunction date(){\r\n\tconcole.log(arguments)  //返回对象\r\n}\r\ndate('海绵宝宝','派大星','痞老板')\r\n//rest\r\nfunction date(...args) {\r\n\tconsole.log(args)  //返回数组\r\n}\r\ndate('海绵宝宝', '派大星', '痞老板')\r\n\r\n//rest参数必须要放到参数最后\r\nfunction fn(a,b,...args){\r\n\tconsole.log(a)\r\n\tconsole.log(b)\r\n\tconsole.log(args)\r\n}\r\nfn(1,2,3,4,5,6)\r\n```\r\n\r\n### 1.9扩展运算符及应用\r\n\r\n... 扩展运算符能将数组转换为逗号分隔的参数序列\r\n\r\n```js\r\nconst hs = ['Dh','Durid','Huter']\r\nfunction battle(){\r\n\tconsole.log(arguments)\r\n}\r\nbattle(...hs)\r\n//1. 数组的合并\r\nconst kz = ['wtl','xy']\r\nconst fh = ['lh','zy']\r\n// const two = kz.concat(fh)\r\nconst two = [...kz,...fh]\r\nconsole.log(two)\r\n//2. 数组的克隆\r\nconst she = ['s','h','e']\r\nconst she2 = [...she]\r\nconsole.log(she2)\r\n//3. 将伪数组转换为真正的数组\r\nconst divs = document.querySelectorAll('div')\r\nconst divArr = [...div]\r\nconsole.log(divArr)\r\n```\r\n\r\n### 1.10 Symbol\r\n\r\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。是一种类似于字符串的数据类型\r\n\r\n1.  Symbol值唯一，用于解决命名冲突的问题\r\n2. Symbol值不能与其他数据进行运算\r\n3. Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名\r\n```js\r\n//创建Symbol\r\nlet s = Symbol()\r\nconsole.log(s, typeof s)\r\nlet s2 = Symbol('lapi')//传入字符串是描述字符串\r\nlet s3 = Symbol('lapi')\r\nconsole.log(s2 === s3)\r\n//Symbol.for创建\r\nlet s4 = Symbol.for('lapi')\r\nconsole.log(s4, typeof s4)\r\nlet s5 = Symbol.for('lapi')\r\nconsole.log(s4 === s5)\r\n```\r\n\r\n\r\nSymbol.hasInstanceof\r\n\r\n当使用instanceof时会自动调用函数，并将o的值传递给 pp\r\n\r\n```js\r\nclass Person{\r\n\tstatic [Symbol.hasInstance](pp){\r\n\t\tconsole.log(pp)\r\n\t\tconsole.log('检测类型ing')\r\n\t}\r\n}\r\nlet o ={}\r\nconsole.log(o instanceof Person)  //false\r\n```\r\nSymbol.isConcatSpreadable控制对象是否可展开，是一个布尔值\r\n```js\r\nconst arr1 = [1,2,3]\r\nconst arr2 = [4,5,6]\r\narr2[Symbol.isConcatSpreadable] = false //设置为不可展开\r\nconsole.log(arr1.concat(arr2))  //1,2,3,Array(3)\r\n```\r\n\r\n### 1.11迭代器Iterator\r\n\r\n迭代器是一种接口，为各种不同的数据结构提供统一的访问机制\r\n任何数据只要部署Iterator接口，就可以完成遍历操作\r\n\r\n1. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费\r\n2. 原生具备Iterator接口的数据（可用for...of遍历）\r\n- Array\r\n- Arguments\r\n- Set\r\n- Map\r\n- String\r\n- TypeArray\r\n- NodeList\r\n```js\r\nconst xy = ['唐僧','孙悟空','猪八戒','沙和尚']\r\nfor(let v of xy){\r\n\tconsole.log(v)  //将数组内的元素遍历,若是for...in，v则是0123\r\n}\r\n```\r\n工作原理：\r\n1. 创建一个指针对象，指向当前数据结构的起始位置\r\n2. 第一次调用对象的next方法，指针自动指向数据结构的第一个成员\r\n3. 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员\r\n4. 每调用next方法返回一个包含value和done属性的对象\r\n\r\n```js\r\nconst banji = {\r\n\tname:'终极一班',\r\n\tstus:['xm','xn','xt','knight'],\r\n\t[Symbol.iterator](){\r\n\t\tlet index = 0\r\n\t\treturn {\r\n\t\t\tnext:() => {\r\n\t\t\t\tif(index<this.stus.length){\r\n\t\t\t\t\tconst result =  { value: this.stus[index], done: false }\r\n\t\t\t\t\tindex++\r\n\t\t\t\t\treturn result\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn {value:undefined,done:true}\r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nfor(let v of banji){\r\n\tconsole.log(v)\r\n}\r\n```\r\n\r\n#### 生成器函数\r\n\r\n```js\r\nfunction* gen(args) {\r\n\tconsole.log(args)\r\n\tconsole.log(yield 111)\r\n\tyield 222\r\n\tyield 333\r\n}\r\nlet iterator = gen('AAA')\r\nconsole.log(iterator.next())\r\n//next方法可以传入实参,参数将作为上一次yield语句整体的返回结果\r\nconsole.log(iterator.next('BBB'))\r\n```\r\n\r\n```js\r\n// setTimeout(() => {\r\n//     console.log(111)\r\n//     setTimeout(() => {\r\n//         console.log(222)\r\n//         setTimeout(() => {\r\n//             console.log(333)\r\n//         }, 3000)\r\n//     }, 2000)\r\n// }, 1000)\r\nfunction one(){\r\n\tsetTimeout(()=>{\r\n\t\tconsole.log(111)\r\n\t\titerator.next()\r\n\t},1000)\r\n}\r\nfunction two() {\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(222)\r\n\t\titerator.next()\r\n\t}, 2000)\r\n}\r\nfunction three() {\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(333)\r\n\t\titerator.next()\r\n\t}, 3000)\r\n}\r\nfunction * gen(){\r\n\tyield one()\r\n\tyield two()\r\n\tyield three()\r\n}\r\nlet iterator = gen()\r\niterator.next()\r\n```\r\n\r\n### 1.12 Promise\r\n\r\n#### 概述\r\n\r\nPromise是ES6引入的异步编程的新解决方案，语法上是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果\r\n\r\n1. Promise 构造函数: Promise (excutor) {}；\r\n\r\n```js\r\nconst p = new Promise(function(resolve,reject){\r\n\tsetTimeout(function(){\r\n\t\t// let data = '数据'\r\n\t\t// resolve(data)\r\n\t\tlet err = '失败'\r\n\t\treject(err)\r\n\t},1000)\r\n})\r\n//调用promise的then方法\r\np.then(function(value){\r\n\tconsole.log(value)\r\n},function(reason){\r\n\tconsole.error(reason)\r\n})\r\n```\r\nPromise封装读取文件\r\n```js\r\n// 1、引入 fs 模块\r\nconst fs = require(\"fs\");\r\n// 2、调用方法，读取文件\r\n// fs.readFile(\"resources/text.txt\",(err,data)=>{\r\n// // 如果失败则抛出错误\r\n// if(err) throw err;\r\n// // 如果没有出错，则输出内容\r\n// console.log(data.toString());\r\n// });\r\n// 3、使用Promise封装\r\nconst p = new Promise(function(resolve,data){\r\n\tfs.readFile(\"resources/text.txt\",(err,data)=>{\r\n\t\t// 判断如果失败\r\n\t\tif(err) reject(err);\r\n\t\t// 如果成功\r\n\t\tresolve(data);\r\n\t});\r\n});\r\np.then(function(value){\r\n\tconsole.log(value.toString());\r\n},function(reason){\r\n\tconsole.log(reason); // 读取失败\r\n})\r\n```\r\n\r\n\r\n2. Promise.prototype.then 方法；\r\n如果promise执行成功，执行第一个回调函数；如果失败执行第二个回调函数\r\nthen方法地返回结果是promise对象，对象状态由回调函数地执行结果决定\r\n如果回调函数中返回的是非promise类型的属性，状态为成功，返回值为对象的成功的值\r\n如果回调函数中返回的是promise对象，内部promise成功外部则为成功，内部失败外部则失败，返回值与内部返回值相同\r\n```js\r\nconst p = new Promise((resolve,reject)=>{\r\n\tsetTimeout(()=>{\r\n\t\tresolve('用户数据')\r\n\t\treject('出错啦')\r\n\t}，1000)\r\n})\r\n\r\nconst result = p.then(value=>{\r\n\tconsole.log(value)\r\n\treturn 'bjxshb'\r\n},reason=>{\r\n\tconsole.warn(reason)\r\n})\r\n\r\nconsole.log(result)\r\n```\r\n\r\n链式调用\r\n```js\r\np.then(value=>{}).then(value=>{})\r\n```\r\n\r\n\r\n\r\n\r\n3. Promise.prototype.catch 方法；\r\n用于指定失败回调函数\r\n```js\r\nconst p = new Promise((resovle,reject)=>{\r\n\tsetTimeout(()=>{\r\n\t\t//设置p对象的状态为失败，并设置失败的值\r\n\t\treject('出错啦')\r\n\t},1000)\r\n})\r\n//p.then(function(value){},function(reason){\r\n\t//console.error(reason)\r\n//}) //出错啦\r\np.catch(function(reason){\r\n\tconsole.warn(reason)\r\n})//出错啦\r\n```\r\n\r\n### 1.13 Set集合\r\n\r\n- ES6提供了新的数据结构Set（集合）\r\n- 它类似于数组，但成员的值都是唯一的\r\n- 集合实现了iterator接口，所以可以使用**扩展运算符**和**for...of...**进行遍历\r\n- 向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值\r\n- Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身\r\n- 两个对象总是不相等的\r\n\r\n#### 集合的声明与初始化：\r\n\r\nnew Set()\r\nnew Set([数组])\r\nSet函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化\r\n\r\n#### 集合的属性和方法：\r\n\r\n1. size ：返回集合的元素个数\r\n2. add(value)  ： 增加元素\r\n3. delete(value) ： 删除元素\r\n4. has(value) ： 判断集合是否包含某元素\r\n5. clear() : 清除集合\r\n6. 使用for...of...遍历\r\n7. Array.from方法可以将 Set 结构转为数组。\r\n```js\r\nlet s = new Set([1，2，3，4，4])\r\nconsole.log(s)  //1，2，3，4\r\nconsole.log(s.size)  //4\r\ns.add(5)  //增加元素\r\ns.delete(1)  //删除元素\r\nconsole.log(s.has(6))  //false\r\nfor (let v of s) {\r\n\tconsole.log(v)\r\n}\r\n```\r\n```js\r\nconst items = new Set([1, 2, 3, 4, 5]);\r\nconst array = Array.from(items);\r\n```\r\n\r\n#### 集合的遍历\r\n\r\n- Set.prototype.keys()：返回键名的遍历器\r\n- Set.prototype.values()：返回键值的遍历器\r\n- Set.prototype.entries()：返回键值对的遍历器\r\n- Set.prototype.forEach()：使用回调函数遍历每个成员\r\n\r\n由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\r\n可以省略values方法，直接用for...of循环遍历 Set。\r\n\r\n```js\r\nlet set = new Set(['red', 'green', 'blue']);\r\n\r\nfor (let item of set.keys()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.values()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.entries()) {\r\n  console.log(item);\r\n}\r\n// [\"red\", \"red\"]\r\n// [\"green\", \"green\"]\r\n// [\"blue\", \"blue\"]\r\n\r\nfor (let x of set) {\r\n  console.log(x);\r\n}\r\n// red\r\n// green\r\n// blue\r\n```\r\n\r\n##### forEach()\r\n\r\nSet 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\r\n```js\r\nlet set = new Set([1, 4, 9]);\r\nset.forEach((value, key) => console.log(key + ' : ' + value))\r\n// 1 : 1\r\n// 4 : 4\r\n// 9 : 9\r\n```\r\n上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\r\n\r\n另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。\r\n\r\n####集合遍历的应用：\r\n```js\r\n//数组去重\r\nlet arr = [1,2,3,3,2,5,6]\r\nlet result = [...new Set(arr)] //创建一个内容为arr的数组，然后扩展并转换为数组\r\n\r\nlet a = new Set([1, 2, 3]);\r\nlet b = new Set([4, 3, 2]);\r\n\r\n// 并集\r\nlet union = new Set([...a, ...b]);\r\n// Set {1, 2, 3, 4}\r\n\r\n// 交集\r\nlet intersect = new Set([...a].filter(x => b.has(x)));\r\n// set {2, 3}\r\n\r\n// （a 相对于 b 的）差集\r\nlet difference = new Set([...a].filter(x => !b.has(x)));\r\n// Set {1}\r\n```\r\n\r\n### 1.14 Map\r\n\r\n- ES6提供了Map数据结构\r\n- 它类似于对象，也是键值对的集合\r\n- Map键的类型不局限于字符串，可以是各种类型\r\n- 实现了 iterator接口，所以可以使用**扩展运算符**和**for...of...**进行遍历\r\n\r\n#### Map的属性和方法\r\n\r\n```js\r\nconst map = new Map();\r\nmap.set('foo', true);\r\nmap.set('bar', false);\r\nconsole.log(map.size) // 2\r\n\r\nconst m = new Map();\r\nconst o = {p: 'Hello World'};\r\n//set()方法，添加元素\r\nm.set('name','lapi')  //键(name)值(lapi)对\r\nm.set(o, 'content')   //键(对象o)值(content)对\r\n//get()方法，获取元素\r\nm.get(o) // \"content\"\r\n//has()方法，判断是否包含某元素\r\nm.has(o) // true\r\n//delete()方法，删除元素\r\nm.delete(o) // true\r\nm.has(o) // false\r\nconsole.log(m.get('name'))  //lapi\r\n//clear方法清除所有成员，没有返回值\r\nm.clear()\r\n```\r\n- set方法返回的是当前的Map对象，因此可以采用链式写法\r\n```js\r\nlet map = new Map().set(1, 'a').set(2, 'b').set(3, 'c')\r\nconsole.log(map)//Map(3) {size:3,1=>a,2=>b,3=>c}\r\n```\r\n- 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组\r\n```js\r\nconst map = new Map([\r\n  ['name', '张三'],\r\n  ['title', 'Author']\r\n]);\r\n\r\nmap.size // 2\r\nmap.has('name') // true\r\nmap.get('name') // \"张三\"\r\nmap.has('title') // true\r\nmap.get('title') // \"Author\"\r\n```\r\n上面代码在新建 Map 实例时，就指定了两个键name和title\r\n\r\nSet和Map都可以用来生成新的 Map。\r\n```js\r\nconst set = new Set([\r\n  ['foo', 1],\r\n  ['bar', 2]\r\n]);\r\nconst m1 = new Map(set);\r\nm1.get('foo') // 1\r\n\r\nconst m2 = new Map([['baz', 3]]);\r\nconst m3 = new Map(m2);\r\nm3.get('baz') // 3\r\n```\r\n上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象\r\n\r\n- 如果对同一个键多次赋值，后面的值将覆盖前面的值\r\n\r\n==只有对同一个对象的引用，Map 结构才将其视为同一个键==\r\n```js\r\nconst map = new Map();\r\n\r\nmap.set(['a'], 555);\r\nmap.get(['a']) // undefined\r\n```\r\n- 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined\r\n- 因此，同样的值的两个实例，在 Map 结构中被视为两个键\r\n- 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键\r\n- 另外，undefined和null也是两个不同的键\r\n- 虽然NaN不严格相等于自身，但 Map 将其视为同一个键\r\n\r\n#### Map的遍历\r\n\r\nMap 结构原生提供三个遍历器生成函数和一个遍历方法\r\n\r\n- Map.prototype.keys()：返回键名的遍历器\r\n- Map.prototype.values()：返回键值的遍历器\r\n- Map.prototype.entries()：返回所有成员的遍历器\r\n- Map.prototype.forEach()：遍历 Map 的所有成员\r\n需要特别注意的是，Map 的遍历顺序就是插入顺序\r\n\r\n```js\r\nconst map = new Map([\r\n  ['F', 'no'],\r\n  ['T',  'yes'],\r\n]);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n// \"F\"\r\n// \"T\"\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n// \"no\"\r\n// \"yes\"\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\n// \"F\" \"no\"\r\n// \"T\" \"yes\"\r\n\r\n// 或者\r\nfor (let [key, value] of map.entries()) {\r\n  console.log(key, value);\r\n}\r\n// \"F\" \"no\"\r\n// \"T\" \"yes\"\r\n\r\n// 等同于使用map.entries()\r\nfor (let [key, value] of map) {\r\n  console.log(key, value);\r\n}\r\n// \"F\" \"no\"\r\n// \"T\" \"yes\"\r\n```\r\n\r\n- Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历\r\n```js\r\nmap.forEach(function(value, key, map) {\r\n  console.log(\"Key: %s, Value: %s\", key, value);\r\n});\r\n\r\n//forEach方法还可以接受第二个参数，用来绑定this。\r\nconst reporter = {\r\n  report: function(key, value) {\r\n    console.log(\"Key: %s, Value: %s\", key, value);\r\n  }\r\n};\r\nmap.forEach(function(value, key, map) {\r\n  this.report(key, value);\r\n}, reporter);\r\n//上面代码中，forEach方法的回调函数的this，就指向reporter\r\n```\r\n\r\n#### 类型互换\r\n\r\n1. Map 转为数组\r\nMap 转为数组最方便的方法，就是使用扩展运算符（...）\r\n```js\r\nconst myMap = new Map()\r\n  .set(true, 7)\r\n  .set({foo: 3}, ['abc']);\r\n[...myMap]\r\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\r\n```\r\n2. 数组 转为 Map\r\n将数组传入 Map 构造函数，就可以转为 Map\r\n```js\r\nnew Map([\r\n  [true, 7],\r\n  [{foo: 3}, ['abc']]\r\n])\r\n// Map {\r\n//   true => 7,\r\n//   Object {foo: 3} => ['abc']\r\n// }\r\n```\r\n3. Map 转为对象\r\n如果所有 Map 的键都是字符串，它可以无损地转为对象\r\n```js\r\nfunction strMapToObj(strMap) {\r\n  let obj = Object.create(null);\r\n  for (let [k,v] of strMap) {\r\n    obj[k] = v;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst myMap = new Map()\r\n  .set('yes', true)\r\n  .set('no', false);\r\nstrMapToObj(myMap)\r\n// { yes: true, no: false }\r\n```\r\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名\r\n\r\n4. 对象转为 Map\r\n对象转为 Map 可以通过Object.entries()\r\n```js\r\nlet obj = {\"a\":1, \"b\":2};\r\nlet map = new Map(Object.entries(obj));\r\n//也可以自己实现一个转换函数。\r\n\r\nfunction objToStrMap(obj) {\r\n  let strMap = new Map();\r\n  for (let k of Object.keys(obj)) {\r\n    strMap.set(k, obj[k]);\r\n  }\r\n  return strMap;\r\n}\r\n\r\nobjToStrMap({yes: true, no: false})\r\n// Map {\"yes\" => true, \"no\" => false}\r\n```\r\n5. Map 转为 JSON\r\n    Map 转为 JSON 要区分两种情况\r\n\r\n  一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON\r\n```js\r\nfunction strMapToJson(strMap) {\r\n  return JSON.stringify(strMapToObj(strMap));\r\n}\r\n\r\nlet myMap = new Map().set('yes', true).set('no', false);\r\nstrMapToJson(myMap)\r\n// '{\"yes\":true,\"no\":false}'\r\n```\r\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON\r\n```js\r\nfunction mapToArrayJson(map) {\r\n  return JSON.stringify([...map]);\r\n}\r\n\r\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\r\nmapToArrayJson(myMap)\r\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\r\n```\r\n6. JSON 转为 Map\r\nJSON 转为 Map，正常情况下，所有键名都是字符串\r\n```js\r\nfunction jsonToStrMap(jsonStr) {\r\n  return objToStrMap(JSON.parse(jsonStr));\r\n}\r\n\r\njsonToStrMap('{\"yes\": true, \"no\": false}')\r\n// Map {'yes' => true, 'no' => false}\r\n//但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\r\n\r\nfunction jsonToMap(jsonStr) {\r\n  return new Map(JSON.parse(jsonStr));\r\n}\r\n\r\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\r\n// Map {true => 7, Object {foo: 3} => ['abc']}\r\n```\r\n\r\n### 1.15 Class类\r\n\r\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板\r\n通过class关键字，可以定义类\r\n\r\n基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已\r\n```js\r\nclass Point {\r\n\tconstructor(x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\ttoString() {\r\n\t\treturn '(' + this.x + ', ' + this.y + ')';\r\n\t}\r\n}\r\n```\r\n- 上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象\r\n- Point类除了构造方法，还定义了一个toString()方法\r\n- 定义toString()方法的时候，前面==不需要加上function这个关键字==，直接把函数定义放进去了就可以了\r\n- ==方法与方法之间不需要逗号分隔，加了会报错==\r\n- ES6 的类，完全可以看作构造函数的另一种写法\r\n```js\r\nclass Point {\r\n  // ...\r\n}\r\n\r\ntypeof Point // \"function\"\r\nPoint === Point.prototype.constructor // true\r\n```\r\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数\r\n\r\n使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\r\n```js\r\nclass Bar {\r\n  doStuff() {\r\n    console.log('stuff');\r\n  }\r\n}\r\nconst b = new Bar();\r\nb.doStuff() // \"stuff\"\r\n```\r\n- ==类的所有方法都定义在类的prototype属性上面==\r\n- 因此，在类的实例上面调用方法，其实就是调用原型上的方法\r\n```js\r\nclass B {}\r\nconst b = new B();\r\nb.constructor === B.prototype.constructor // true\r\n```\r\n上面代码中，b是B类的实例，它的constructor()方法就是B类原型的constructor()方法\r\n\r\n由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面\r\n- Object.assign()方法可以很方便地一次向类添加多个方法\r\n```js\r\nclass Point {\r\n  constructor(){\r\n    // ...\r\n  }\r\n}\r\n\r\nObject.assign(Point.prototype, {\r\n  toString(){},\r\n  toValue(){}\r\n});\r\n```\r\n==prototype对象的constructor()属性，直接指向“类”的本身==，这与 ES5 的行为是一致的\r\n```js\r\nPoint.prototype.constructor === Point // true\r\n```\r\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable)\r\n\r\n##### 静态方法\r\n\r\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承\r\n- 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”\r\n```js\r\nclass Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nFoo.classMethod() // 'hello'\r\n\r\nvar foo = new Foo();\r\nfoo.classMethod()\r\n// TypeError: foo.classMethod is not a function\r\n```\r\n==如果静态方法包含this关键字，这个this指的是类，而不是实例==\r\n\r\n#### Class的继承\r\n\r\nClass 可以通过extends关键字实现继承，让子类继承父类的属性和方法\r\n\r\n```js\r\nclass Point { /* ... */ }\r\n\r\nclass ColorPoint extends Point {\r\n\tconstructor(x, y, color) {\r\n\t\tsuper(x, y); // 调用父类的constructor(x, y)\r\n\t\tthis.color = color;\r\n\t}\r\n\ttoString() {\r\n\t\treturn this.color + ' ' + super.toString(); // 调用父类toString()\r\n\t}\r\n}\r\n```\r\n上面示例中，constructor()方法和toString()方法内部，都出现了super关键字\r\n- super在这里表示父类的构造函数，用来新建一个父类的实例对象\r\n- ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错\r\n- 因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法\r\n- 如果不调用super()方法，子类就得不到自己的this对象\r\n- ==在子类的构造函数中，只有调用super()之后，才可以使用this关键字==,否则会报错(这是因为子类实例的构建，必须先完成父类的继承，只有super()方法才能让子类实例继承父类)\r\n\r\n#### get()和set()\r\n\r\n```js\r\nclass Phone{\r\n\tget price(){\r\n\t\tconsole.log('价格属性被读取了')\r\n\t\treturn 'here'\r\n\t}\r\n\tset price(newVal){\r\n\t\tconsole.log('价格属性被修改了')\r\n\t}\r\n}\r\nlet s = new Phone()\r\nconsole.log(s.price)  //价格属性被读取了    here\r\ns.price = 'free'  //价格属性被修改了\r\n```\r\n- 利用get()方法创建类里的某属性，当读取实例的该属性时会自动执行get()方法，get()方法的返回值就是该属性的值\r\n- 利用set()方法可以设置属性修改时的执行代码，当属性值被设置时会执行set()方法，注意set()方法需要有形参\r\n\r\n\r\n\r\n### 1.16数值扩展\r\n\r\n#### 1.Number.EPSION\r\nNumber.EPSION是JS表示的最小精度\r\n```js\r\nfunction equal(a,b){\r\n\tif(Math.abs(a-b)<Number.EPSILON){\r\n\t\treturn true\r\n\t}else{\r\n\t\treturn false\r\n\t}\r\n}\r\nconsole.log(equal(0.1+0.2,0.3))  //true\r\nconsole.log(0.1+0.2 === 0.3)  //false\r\n```\r\n#### 2.二进制和八进制\r\nES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示\r\n```js\r\n0b111110111 === 503 // true\r\n0o767 === 503 // true\r\n```\r\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示\r\n```js\r\n// 非严格模式\r\n(function(){\r\n  console.log(0o11 === 011);\r\n})() // true\r\n\r\n// 严格模式\r\n(function(){\r\n\t'use strict';\r\n\tconsole.log(0o11 === 011);\r\n})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.\r\n```\r\n如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法\r\n```js\r\nNumber('0b111')  // 7\r\nNumber('0o10')  // 8\r\n```\r\n\r\n#### 3.Number,isFinite\r\n检测一个数是否为有限数\r\n```js\r\nconsole.log(Number.isFinite(100))  //true\r\nconsole.log(Number.isFinite(100/0)) //false\r\nconsole.log(Number.isFinite(Infinity))  //false\r\n```\r\n\r\n#### 4.Number.isNaN\r\n检测一个数是否为NaN\r\n```js\r\nNumber.isNaN(NaN) // true\r\nNumber.isNaN(15) // false\r\nNumber.isNaN('15') // false\r\nNumber.isNaN(true) // false\r\nNumber.isNaN(9/NaN) // true\r\nNumber.isNaN('true' / 0) // true\r\nNumber.isNaN('true' / 'true') // true\r\n```\r\nNumber.isFinite()对于非数值一律返回false\r\nNumber.isNaN()只有对于NaN才返回true，非NaN一律返回false\r\n\r\n#### 5.Number.parseInt  Number.parseFloat\r\n字符串转整数/字符串转浮点数\r\n```js\r\nconsole.log(Number.parseInt('523143asg'))  //523143\r\nconsole.log(Number.parseFloat('3.1415926535后面还有')) //3.1415926535\r\n```\r\n\r\n#### 6.Number.isInteger\r\n判断一个数是否为整数\r\n```js\r\nconsole.log(Number.isInteger(5.13))  //false\r\n```\r\n\r\n#### 7.Math.trunc\r\n将小数部分抹掉\r\n```js\r\nconsole.log(Math.trunc(5.13))  //5\r\n```\r\n\r\n#### 8.Math.sign\r\n判断一个数为正数负数还是0\r\n```js\r\nconsole.log(Math.sign(100))  //1\r\nconsole.log(Math.sign(0))  //0\r\nconsole.log(Math.sign(-100))  //-1\r\n```\r\n\r\n### 1.17对象方法扩展\r\n\r\n#### 1.Object.is()\r\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题\r\nObject.is就是部署这个算法的新方法\r\n它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\r\n不同之处只有两个：一是+0不等于-0，二是NaN等于自身\r\n```js\r\nObject.is('foo', 'foo') // true\r\nObject.is({}, {})  // false\r\nobject.is(NaN,NaN)  //true\r\nconsole,log(NaN===NaN)  //false\r\nObject.is(+0,-0)  //false\r\nconsole,log(+0===-0)  //true\r\n```\r\n\r\n#### 2.Object.assign()\r\n基本用法\r\nObject.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）\r\n```js\r\nconst target = { a: 1 };\r\n\r\nconst source1 = { b: 2 };\r\nconst source2 = { c: 3 };\r\n\r\nObject.assign(target, source1, source2);\r\ntarget // {a:1, b:2, c:3}\r\n```\r\nObject.assign()方法的第一个参数是目标对象，后面的参数都是源对象\r\n**如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性**\r\n```js\r\nconst target = { a: 1, b: 1 };\r\nconst source1 = { b: 2, c: 2 };\r\nconst source2 = { c: 3 };\r\nObject.assign(target, source1, source2);\r\ntarget // {a:1, b:2, c:3}\r\n```\r\n如果只有一个参数，Object.assign()会直接返回该参数。\r\n```js\r\nconst obj = {a: 1};\r\nObject.assign(obj) === obj // true\r\n```\r\n如果该参数不是对象，则会先转成对象，然后返回\r\n由于undefined和null无法转成对象，所以如果它们作为参数，就会报错\r\n```js\r\ntypeof Object.assign(2) // \"object\"\r\nObject.assign(undefined) // 报错\r\nObject.assign(null) // 报错\r\n```\r\n如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错\r\n\r\nObject.assign()拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）\r\n```js\r\nObject.assign({b: 'c'},\r\n  Object.defineProperty({}, 'invisible', {\r\n    enumerable: false,\r\n    value: 'hello'\r\n  })\r\n)\r\n// { b: 'c' }\r\n```\r\n上面代码中，Object.assign()要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去\r\n\r\n属性名为 Symbol 值的属性，也会被Object.assign()拷贝\r\n```js\r\nObject.assign({ a: 'b' }, { [Symbol('c')]: 'd' })\r\n// { a: 'b', Symbol(c): 'd' }\r\n```\r\n\r\n#### 3.__proto__属性\r\nJavaScript 语言的对象继承是通过原型链实现的\r\nES6 提供了更多原型对象的操作方法\r\n\r\n__proto__属性\r\n__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）\r\n实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下\r\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型\r\n\r\n######Object.setPrototypeOf()\r\n用来设置一个对象的原型对象（prototype），返回参数对象本身( ES6 正式推荐的设置原型对象的方法)\r\n\r\n```js\r\n// 格式\r\nObject.setPrototypeOf(object, prototype)\r\n\r\n// 用法\r\nconst o = Object.setPrototypeOf({}, null);\r\n```\r\n该方法等同于下面的函数\r\n```js\r\nfunction setPrototypeOf(obj, proto) {\r\n  obj.__proto__ = proto;\r\n  return obj;\r\n}\r\n```\r\n下面是一个例子\r\n```js\r\nlet proto = {};\r\nlet obj = { x: 10 };\r\nObject.setPrototypeOf(obj, proto);\r\nproto.y = 20;\r\nproto.z = 40;\r\nobj.x // 10\r\nobj.y // 20\r\nobj.z // 40\r\n```\r\n上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性\r\n\r\n如果第一个参数不是对象，会自动转为对象,但是由于返回的还是第一个参数，所以这个操作不会产生任何效果\r\n```js\r\nObject.setPrototypeOf(1, {}) === 1 // true\r\nObject.setPrototypeOf('foo', {}) === 'foo' // true\r\nObject.setPrototypeOf(true, {}) === true // true\r\n```\r\n由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错\r\n\r\n######Object.getPrototypeOf()\r\n该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象\r\nObject.getPrototypeOf(obj);\r\n下面是一个例子\r\n```js\r\nfunction Rectangle() {\r\n  // ...\r\n}\r\n\r\nconst rec = new Rectangle();\r\n\r\nObject.getPrototypeOf(rec) === Rectangle.prototype\r\n// true\r\n\r\nObject.setPrototypeOf(rec, Object.prototype);\r\nObject.getPrototypeOf(rec) === Rectangle.prototype\r\n// false\r\n```\r\n如果参数不是对象，会被自动转为对象\r\n如果参数是undefined或null，它们无法转为对象，所以会报错\r\n\r\n\r\n\r\n###1.18模块化\r\n将一个大的程序文件拆分成许多小的文件，然后将小文件组合起来\r\n####模块化的好处\r\n1. 防止命名冲突\r\n2. 代码复用\r\n3. 高维护性\r\n####模块化规范产品\r\n1. CommondJS => NodeJS、Browserify\r\n2. AMD => requireJS\r\n3. CMD =>seaJS\r\n####ES6模块化语法\r\n模块功能主要由两个命令组成：export和import\r\n- export命令用于规定模块的对外接口\r\n- import命令用于输入其他模块提供的功能\r\n######export\r\n一个模块就是一个独立的文件\r\n该文件内部的所有变量，外部无法获取\r\n如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量\r\n下面是一个 JS 文件，里面使用export命令输出变量。\r\n```js\r\n// profile.js\r\nexport var firstName = 'Michael';\r\nexport var lastName = 'Jackson';\r\nexport var year = 1958;\r\n```\r\n上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\r\n\r\nexport的写法，除了像上面这样，还有另外一种。\r\n```js\r\n// profile.js\r\nvar firstName = 'Michael';\r\nvar lastName = 'Jackson';\r\nvar year = 1958;\r\n\r\nexport { firstName, lastName, year };\r\n```\r\n上面代码在export命令后面，使用大括号指定所要输出的一组变量\r\n它与前一种写法是等价的，但是**应该优先考虑使用这种写法**\r\n因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量\r\n\r\nexport命令除了输出变量，还可以输出函数或类（class）\r\n```js\r\nexport function multiply(x, y) {\r\n  return x * y;\r\n};\r\n```\r\n上面代码对外输出一个函数multiply\r\n\r\n通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名\r\n```js\r\nfunction v1() { ... }\r\nfunction v2() { ... }\r\n\r\nexport {\r\n  v1 as streamV1,\r\n  v2 as streamV2,\r\n  v2 as streamLatestVersion\r\n};\r\n```\r\n上面代码使用as关键字，重命名了函数v1和v2的对外接口\r\n重命名后，v2可以用不同的名字输出两次\r\n\r\n==export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系==\r\n```js\r\n// 报错\r\nexport 1;\r\n\r\n// 报错\r\nvar m = 1;\r\nexport m;\r\n```\r\n上面两种写法都会报错，因为没有提供对外的接口\r\n第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1\r\n1只是一个值，不是接口\r\n正确的写法是下面这样:\r\n```js\r\n// 写法一\r\nexport var m = 1;\r\n\r\n// 写法二\r\nvar m = 1;\r\nexport {m};\r\n\r\n// 写法三\r\nvar n = 1;\r\nexport {n as m};\r\n```\r\n上面三种写法都是正确的，规定了对外的接口m\r\n其他脚本可以通过这个接口，取到值1\r\n它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系\r\n\r\n同样的，function和class的输出，也必须遵守这样的写法\r\n```js\r\n// 报错\r\nfunction f() {}\r\nexport f;\r\n\r\n// 正确\r\nexport function f() {};\r\n\r\n// 正确\r\nfunction f() {}\r\nexport {f};\r\n```\r\n另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值\r\n```js\r\nexport var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\r\n```\r\n上面代码输出变量foo，值为bar，500 毫秒之后变成baz\r\nexport命令可以出现在模块的任何位置，只要处于模块顶层就可以\r\n如果处于块级作用域内，就会报错，import命令也是如此\r\n这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷\r\n```js\r\nfunction foo() {\r\n  export default 'bar' // SyntaxError\r\n}\r\nfoo()\r\n```\r\n上面代码中，export语句放在函数之中，结果报错\r\n\r\n######import 命令\r\n使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块\r\n```js\r\n// main.js\r\nimport { firstName, lastName, year } from './profile.js';\r\n\r\nfunction setName(element) {\r\n  element.textContent = firstName + ' ' + lastName;\r\n}\r\n```\r\n上面代码的import命令，用于加载profile.js文件，并从中输入变量\r\nimport命令接受一对大括号，里面指定要从其他模块导入的变量名\r\n大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同\r\n\r\n如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名\r\n```js\r\nimport { lastName as surname } from './profile.js';\r\n```\r\nimport命令输入的变量都是只读的，因为它的本质是输入接口\r\n也就是说，**不允许在加载模块的脚本里面，改写接口**\r\n```js\r\nimport {a} from './xxx.js'\r\n\r\na = {}; // Syntax Error : 'a' is read-only;\r\n```\r\n上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口\r\n但是，**如果a是一个对象，改写a的属性是允许的**\r\n```js\r\nimport {a} from './xxx.js'\r\n\r\na.foo = 'hello'; // 合法操作\r\n```\r\n上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值\r\n不过，这种写法很难查错，**建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性**\r\n\r\nimport后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径\r\n如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置\r\n```js\r\nimport { myMethod } from 'util';\r\n```\r\n上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块\r\n\r\n注意，import命令具有提升效果，会提升到整个模块的头部，首先执行\r\n```js\r\nfoo();\r\n\r\nimport { foo } from 'my_module';\r\n```\r\n上面的代码不会报错，因为import的执行早于foo的调用\r\n这种行为的本质是，import命令是编译阶段执行的，在代码运行之前\r\n\r\n由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构\r\n```js\r\n// 报错\r\nimport { 'f' + 'oo' } from 'my_module';\r\n\r\n// 报错\r\nlet module = 'my_module';\r\nimport { foo } from module;\r\n\r\n// 报错\r\nif (x === 1) {\r\n  import { foo } from 'module1';\r\n} else {\r\n  import { foo } from 'module2';\r\n}\r\n```\r\n上面三种写法都会报错，因为它们用到了表达式、变量和if结构\r\n在静态分析阶段，这些语法都是没法得到值的\r\n\r\n最后，import语句会执行所加载的模块，因此可以有下面的写法\r\n```js\r\nimport 'lodash';\r\n```\r\n上面代码仅仅执行lodash模块，但是不输入任何值\r\n\r\n如果多次重复执行同一句import语句，那么**只会执行一次，而不会执行多次**\r\n```js\r\nimport 'lodash';\r\nimport 'lodash';\r\n```\r\n上面代码加载了两次lodash，但是只会执行一次\r\n```js\r\nimport { foo } from 'my_module';\r\nimport { bar } from 'my_module';\r\n\r\n// 等同于\r\nimport { foo, bar } from 'my_module';\r\n```\r\n上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module模块\r\n\r\n\r\n######模块的整体加载\r\n除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面\r\n\r\n下面是一个circle.js文件，它输出两个方法area和circumference\r\n```js\r\n// circle.js\r\n\r\nexport function area(radius) {\r\n  return Math.PI * radius * radius;\r\n}\r\n\r\nexport function circumference(radius) {\r\n  return 2 * Math.PI * radius;\r\n}\r\n```\r\n现在，加载这个模块\r\n```js\r\n// main.js\r\n\r\nimport { area, circumference } from './circle';\r\n\r\nconsole.log('圆面积：' + area(4));\r\nconsole.log('圆周长：' + circumference(14));\r\n```\r\n上面写法是逐一指定要加载的方法，整体加载的写法如下\r\n```js\r\nimport * as circle from './circle';\r\n\r\nconsole.log('圆面积：' + circle.area(4));\r\nconsole.log('圆周长：' + circle.circumference(14));\r\n```\r\n注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变\r\n下面的写法都是不允许的\r\n```js\r\nimport * as circle from './circle';\r\n\r\n// 下面两行都是不允许的\r\ncircle.foo = 'hello';\r\ncircle.area = function () {};\r\n```\r\n\r\n###1.19 Babel\r\n\r\n\r\n\r\n\r\n\r\n##Chapter2 ES7\r\n###2.1Array.prototypr.includes\r\nincludes方法用于检测数组中是否包含某个元素，返回布尔值\r\n```js\r\nconst arr = [1,2,3,4]\r\nconsole.log(arr.includes(1))//true\r\nconsole.log(arr.includes(5))//false\r\n```\r\n###2.2指数操作符\r\n指数运算符\\*\\*,用于实现幂运算，功能与Math.pow相同\r\n```js\r\nconsole.log(2**10)//1024\r\n```\r\n\r\n\r\n##Chapter3 ES8\r\n###3.1 async与await\r\n######async函数\r\nES8标准引入了 async 函数，使得异步操作变得更加方便\r\nasync 函数是什么？\r\n>一句话，它就是 Generator 函数的语法糖\r\n\r\n1. async函数的返回值是promise对象\r\n2. promise对象的结果由async函数的返回值决定\r\n```js\r\n//async函数\r\nasync function fn(){\r\n\t//只要返回的不是一个Promise对象，则函数返回结果为成功的Promise\r\n\t//return 'lapi'\r\n\t//return\r\n\t//抛出错误\r\n\t//throw new Error('出错啦')  //返回一个失败的Promise\r\n\t//返回的是一个Promise对象,返回的结果与Promise的结果相同\r\n\treturn new Promise((resovle,reject)=>{\r\n\t\t//resovle('成功的数据')\r\n\t\treject(\"失败\")\r\n\t})\r\n}\r\nconst result = fn()\r\nconsole.log(result)\r\n```\r\n\r\n\r\n######await函数\r\n1. await必须写在async函数中\r\n2. await右侧的表达式一般为promise对象\r\n3. await返回的值是promise成功的值\r\n4. await 的promise失败了，就会抛出异常，需要通过try...catch捕获处理\r\n\r\n```js\r\n//创建一个promise对象\r\nconst p = new Promise((resolve,reject)=>{\r\n//resolve('won!')\r\nreject(\"No!\")\r\n})\r\n//await\r\nasync function main(){\r\n\ttry{\r\n\t\tlet result = await p\r\n\t\tconsole.log(result)\r\n\t} catch (e){\r\n\t\tconsole.log(e)\r\n\t}\r\n}\r\nmain()\r\n```\r\n\r\n###3.2 对象方法扩展\r\n######Object.values()和Object.entries()\r\n1. Object.values()方法返回一个给定对象的所有可枚举属性值的数组\r\n2. Object.entries()方法返回一个给定对象自身可遍历属性[key,value]的数组\r\n返回的是数组，数组的每一个元素也是一个数组，内容是键值对\r\n\r\n```js\r\nconst school = {\r\n\tname: 'jlu',\r\n\tcities: ['北京', '上海', '长春'],\r\n\tcourse: ['微店', '电工', '电信', '电科']\r\n}\r\nlet a = Object.keys(school)//获取对象所有的键  'name','cities','course'\r\nlet b = Object.values(school)//获取对象所有的值 'jlu',Array(3),Array(4)\r\nlet c = Object.entries(school)//获取对象所有的键值对  Array(2),Array(2),Array(2)  每个数组内容均是键值对\r\nconsole.log(c)\r\nconst m = new Map(c)\r\nconsole.log(m)\r\nlet city = m.get('cities')\r\nconsole.log(city)  //'北京','上海','长春'\r\n```\r\n\r\n######Object.getOwnPropertyDescriptors\r\n该方法返回指定对象所有自身属性的描述对象\r\n\r\n\r\n\r\n##Chapter4 ES9\r\n###4.1扩展运算符和rest参数\r\n\r\n###4.2正则扩展\r\n####4.2.1命名捕获分组\r\n```js\r\nlet str = '<a href=\"vxsgu\">你好</a>'\r\nlet reg = /<a href=\"(?<url>.*)\">(?<text>.*)<\\/a>/\r\nconst result = reg.exec(str)\r\nconsole.log(result) //groups{url:vxsgu,text:你好}\r\n```\r\n####4.2.2反向断言\r\n```js\r\nlet str = 'JS5211314uknow555lalala'\r\n//正向断言\r\n// const reg = /\\d+(?=l)/\r\n// const result = reg.exec(str)\r\n//反向断言\r\nconst reg = /(?<=w)\\d+/\r\nconst result = reg.exec(str)\r\nconsole.log(result);\r\n```\r\n\r\n####4.2.3dotAll模式\r\n```js\r\nlet str = `\r\n        <ul>\r\n            <li>\r\n                <a>肖申克的救赎</a>\r\n                <p>上映日期：1994-09-10</p>\r\n            </li>\r\n            <li>\r\n                <a>阿甘正传</a>\r\n                <p>上映日期：1994-07-06</p>\r\n            </li>\r\n        </ul>`\r\n// const reg = /<li>\\s+<a>(.*?)<\\/a>\\s+<p>(.*?)<\\/p>/\r\nconst reg = /<li>.*?<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/s\r\nconst result = reg.exec(str)\r\nconsole.log(result);\r\n```\r\n##Chapter5 ES10\r\n###5.1对象扩展方法Object.fromEntries()\r\n将二维数组或Map转换为对象\r\n```js\r\n//二维数组\r\nconst result = Object.fromEntries([\r\n\t['name','lapi'],\r\n\t['age','20']\r\n])\r\n\r\n//Map\r\nconst m = new Map()\r\nm.set('name','lapi')\r\n\r\nconst result2 = Object.fromEntries(m)\r\nconsole.log(result);\r\nconsole.log(result2);\r\n```\r\n###5.2字符串扩展方法trimStart与trimEnd\r\n```js\r\n//trim用于清除字符串两侧空白\r\nlet str = '            lapi   '\r\nconsole.log(str);              //            lapi   .\r\nconsole.log(str.trimStart());  //lapi   .\r\nconsole.log(str.trimEnd());    //            lapi.\r\n```\r\n###5.3数组方法扩展flat与flatMap\r\n```js\r\n//flat将多维数组转化为低维数组\r\nconst arr = [[1,2],[3,4],[5,6]]\r\nconsole.log(arr.flat());   //[1,2,3,4,5,6]\r\nconst arr1 = [[1, 2,[11,22]], [3, 4], [5, 6]]\r\nconsole.log(arr1.flat());   //[1,2,Array(2),3,4,5,6]\r\n//可以传递参数表示降低的深度，默认为1\r\nconsole.log(arr1.flat(2))   //[1,2,11,22,3,4,5,6]\r\n```\r\n\r\nflatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法\r\n该方法返回一个新数组，不改变原数组\r\n```js\r\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\r\n[2, 3, 4].flatMap((x) => [x, x * 2])\r\n// [2, 4, 3, 6, 4, 8]\r\n```\r\nflatMap()只能展开一层数组。\r\n###5.4Symbol.prototype.description\r\n用于获取Symbol的字符串描述\r\n```js\r\nlet s = Symbol('lapi')\r\nconsole.log(s.description)   //lapi\r\n```\r\n\r\n##Chapter6 ES11\r\n###6.1私有属性\r\n私有属性只能在类的内部进行操作，不能在外部操作\r\n```js\r\nclass Person{\r\n\t//公有属性\r\n\tname\r\n\t//私有属性\r\n\t#age\r\n\t#weight\r\n\tconstructor(name,age,weight){\r\n\t\tthis.name = name\r\n\t\tthis.#age = age\r\n\t\tthis.#weight = weight\r\n\t}\r\n}\r\nconst one = new Person('lapi',18,'45kg')\r\nconsole.log(one.name);\r\nconsole.log(one.#age);  //报错\r\n```\r\n\r\n###6.2Promise.allSettled方法\r\n```js\r\nconst p1 = new Promise((resolve,reject)=>{\r\n\tsetTimeout(()=>{\r\n\t\tresolve('number - 1')\r\n\t},1000)\r\n})\r\nconst p2 = new Promise((resovle,reject)=>{\r\n\tsetTimeout(()=>{\r\n\t\treject('No!')\r\n\t},1000)\r\n})\r\n\r\n//调用allSettled方法\r\nconst result = Promise.allSettled([p1,p2])\r\n//console.log(result)\r\n//返回的值始终是成功的，成功的值是每一个Promise对象的结果\r\nconst res = Promise.all([p1,p2])\r\nconsole.log(res)\r\n//只有每一个promise都成功返回值才是成功，若失败失败的值就是里面失败的promise的值，若成功值与上相同\r\n```\r\n\r\n###6.3String.prototypr.macthAll方法\r\n```js\r\nlet str = `\r\n        <ul>\r\n            <li>\r\n                <a>肖申克的救赎</a>\r\n                <p>上映日期：1994-09-10</p>\r\n            </li>\r\n            <li>\r\n                <a>阿甘正传</a>\r\n                <p>上映日期：1994-07-06</p>\r\n            </li>\r\n        </ul>`\r\n//声明正则\r\nconst reg = /<li>.*?<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/sg\r\n//调用方法\r\nconst result = str.matchAll(reg)\r\nconsole.log(result)\r\n// for(let v of result){\r\n//     console.log(v)\r\n// }\r\nconst arr = [...result]\r\nconsole.log(arr)\r\n```\r\n\r\n\r\n###6.4可选链操作符\r\n\r\n###6.5动态import\r\n```js\r\n//按需加载\r\nconst btn = document.getElementById('btn')\r\nbtn.onclick = function(){\r\n\timport('./hello.js').then(module=>{\r\n\t\tmoudle.hello()\r\n\t})\r\n}\r\n```\r\n```js\r\nexport function hello(){\r\n\talert('hello')\r\n}\r\n```\r\n\r\n###6.6BigInt类型\r\n```js\r\n//大整形\r\nlet n = 521n\r\nconsole.log(n,typeof n)\r\n\r\n//函数\r\nlet nn = 123\r\nconsole.log(BigInt(nn))\r\n\r\n//大数值运算\r\nlet max = Number.MAX_SAFE_INTEGER\r\nconsole.log(max)     //9007199254740991\r\nconsole.log(max+1)   //9007199254740992\r\nconsole.log(max+2)   //9007199254740992\r\n\r\nconsole.log(BigInt(max)+BigInt(3))  //9007199254740994n\r\n\r\n```\r\n\r\n###6.7绝对全局对象globalThis\r\n始终指向全局对象",
        "timemini": ""
    },
    {
        "index": 23,
        "title": "移动端",
        "essay": "**这是我参与「第四届青训营 」笔记创作活动的第9天**\r\n\r\n## 1. 移动端基础\r\n\r\n### 1.1 浏览器\r\n\r\n兼容移动端浏览器，处理Webkit内核浏览器\r\n\r\n### 1.2 手机屏幕\r\n\r\n常用尺寸单位px\r\n\r\n### 1.3 常见移动端屏幕尺寸\r\n\r\n前端开发，不建议纠结dp,dpi,pt,ppi等单位\r\n\r\n### 1.4 移动端调试方法\r\n\r\n1.  Chorme DevTools（谷歌浏览器）的模拟手机测试\r\n1.  搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器\r\n1.  使用外网服务器，直接IP或域名访问\r\n\r\n## 2.视口\r\n\r\n浏览器显示页面内容的屏幕区域。可分为布局视口、视觉视口和理想视口。\r\n\r\n（视觉视口指用户能看到的网络区域）\r\n\r\nmeta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，也就是设备多宽，理想视口多宽。\r\n\r\n### meta视口标签\r\n\r\n```\r\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df84806768014a8c9e642420f8660b9e~tplv-k3u1fbpfcp-zoom-1.image)![](<> \"点击并拖拽以移动\")​编辑\r\n\r\n## 3.二倍图\r\n\r\n### 3.1 物理像素&物理像素比\r\n\r\n-   物理像素是我们所说的分辨率。\r\n-   物理像素比是一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比\r\n-   在iPhone8中，1px开发像素=2个物理像素\r\n\r\n### 3.2 多倍图\r\n\r\n插入图片\r\n\r\n```\r\n/* 在iphone8下面 */\r\nimg {\r\n    /* 原始图片100*100px */\r\n    width: 50px;\r\n    height: 50px;\r\n}\r\n.box {\r\n    /* 原始图片100*100px */\r\n    background-size: 50px 50px;\r\n}\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n**背景缩放**    **background-size: 背景图片宽度 背景图片高度；**\r\n\r\n-   单位：长度|百分比|cover|contain\r\n-   cover等比例把背景图片扩展至足够大，使背景图像完全覆盖背景区域，可能会部分背景图片显示不全\r\n-   contain等比例把图像扩展至最大尺寸，使其宽度和高度完全适应内容区域，当宽度或高度铺满盒子就不再拉伸了，可能有部分空白区域\r\n\r\n## 4.移动端开发选择\r\n\r\n**1.单独制作移动端页面（主流）** ：通常，网址域名前加 m(mobile) 可以打开移动端。\r\n\r\n通过判断设备，如果是移动设备打开，则跳到移动端页面。\r\n\r\n**2.响应式页面兼容PC移动端**\r\n\r\n## **5.移动端技术解决方案**\r\n\r\n### CSS初始化 normalize.css\r\n\r\n官网： https://necolas.github.io/normalize.css/\r\n\r\n### **C3盒子模型 box-sizing: border-box;**\r\n\r\n加上这行代码后，padding和border不会撑大盒子。\r\n\r\n传统盒子模型 box-sizing: content-box;\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fceb0a22149494a86746b2ba7c6fa90~tplv-k3u1fbpfcp-zoom-1.image)![](<> \"点击并拖拽以移动\")​编辑\r\n\r\n##  6.移动端常见布局\r\n\r\n###  6.1 流式布局（百分比布局）\r\n\r\n可设置最大值max-width max-height ， 最小值min-width min-height\r\n\r\n\\\r\n**常用初始化样式**\r\n\r\n```\r\nbody {\r\n    margin: 0 auto;\r\n    min-width: 320px;\r\n    max-width: 640px;\r\n    background: #fff;\r\n    font-size: 14px;\r\n    font-family: -apple-system,Helvetica,sans-serif;\r\n    line-height: 1.5;\r\n    color: #666;\r\n}\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n**二倍精灵图做法**\r\n\r\n1.  在firework里把精灵图等比例缩放为原来的一半\r\n1.  根据大小测量坐标（注意代码中backgroung-size也要写：精灵图原来宽度的一半）\r\n\r\n**图片格式**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4d87e25ddd4cfaad3ed9f84c376724~tplv-k3u1fbpfcp-zoom-1.image)![](<> \"点击并拖拽以移动\")​编辑\r\n\r\n***\r\n\r\n# Flex布局\r\n\r\n## 1 **.布局原理**\r\n\r\nflexible Box的缩写，意为“弹性布局”。用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。\r\n\r\n-   当我们为父盒子设置flex布局后，子元素的float、clear和vertical-align属性将失效。\r\n-   伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局\r\n\r\n总结：通过给父盒子添加flex属性，来控制子盒子的位置和排列方式。\r\n\r\n## 2.常见父项属性\r\n\r\n-   flex-direction: 设置主轴方向\r\n-   justify-content: 设置主轴上的子元素的排列方式\r\n-   flex-wrap: 设置子元素是否换行\r\n-   align-content: 设置侧轴上的子元素的排列方式（多行）\r\n-   align-items: 设置侧轴上的子元素的排列方式（单行）\r\n-   flex-flow: 复合属性，相当于同时设置了flex-direction和flex-wrap\r\n\r\n### flex-direction: 设置主轴方向\r\n\r\n### 2.1 主轴与侧轴\r\n\r\n-   默认的主轴方向为x轴方向，水平向右\r\n-   默认的侧轴方向为y轴方向，竖直向下\r\n\r\n### 2.2 属性值\r\n\r\n注： 主轴侧轴会变化，看flex-direction设置谁为主轴，剩下的就是侧轴，子元素跟着主轴排列\r\n\r\n| 属性值            | 说明      |\r\n| -------------- | ------- |\r\n| row            | 默认值从左到右 |\r\n| row-reverse    | 从右到左    |\r\n| column         | 从上到下    |\r\n| column-reverse | 从下到上    |\r\n\r\n### justify-content: 设置主轴上的子元素的排列方式\r\n\r\n该属性定义了项目在主轴上的对齐方式（一定先确定好主轴是哪个）\r\n\r\n| 属性值           | 说明                      |\r\n| ------------- | ----------------------- |\r\n| flex-start    | 默认值 从头部开始，如果主轴是x轴，则从左到右 |\r\n| flex-end      | 从尾部开始排列                 |\r\n| center        | 在主轴居中对齐（如果主轴是x轴则水平居中）   |\r\n| space-around  | 平分剩余空间                  |\r\n| space-between | 先两边贴边，在平分剩余空间           |\r\n\r\n### flex-wrap: 设置子元素是否换行\r\n\r\n| 属性值    | 说明      |\r\n| ------ | ------- |\r\n| nowrap | 默认值，不换行 |\r\n| wrap   | 换行      |\r\n\r\n### align-items: 设置侧轴上的子元素的排列方式（多行）\r\n\r\n| 属性值        | 说明           |\r\n| ---------- | ------------ |\r\n| flex-start | 从上到下         |\r\n| flex-end   | 从下到上         |\r\n| center     | 挤在一起居中（垂直居中） |\r\n| stretch    | 拉伸（默认值）      |\r\n\r\n### align-content: 设置侧轴上的子元素的排列方式（多行）\r\n\r\n在align-items基础上增加\r\n\r\n|               |                     |\r\n| ------------- | ------------------- |\r\n| space-around  | 子项在侧轴平分剩余空间         |\r\n| space-between | 子项在侧轴先分布在两头，再平分剩余空间 |\r\n\r\n### flex-flow: 复合属性，相当于同时设置了flex-direction和flex-wrap\r\n\r\nflex-flow： row wrap;\r\n\r\n## 3.flex布局子项常见属性\r\n\r\n-   flex子项目占的份数\r\n-   align-self控制子项自己在侧轴的排列方式\r\n-   order属性定义子项的排列顺序\r\n\r\n###  3.1 flex属性\r\n\r\nflex属性定义子项目分配剩余空间，用flex来表示占多少份数\r\n\r\n```\r\n.item {\r\n    flex: <number>; /* default 0 */\r\n}\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n### 3.2 align-self控制子项自己在侧轴上的排列方式\r\n\r\nalign-self可覆盖align-items,默认值为auto,表示继承父元素的align-items属性，如果没有父元素，则等同于stretch.\r\n\r\n```\r\nspan:nth-child(2){\r\n    /* 设置自己在侧轴上的排列方式 */\r\n    align-self: flex-end;\r\n}\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n### 3.3 order属性定义项目的排列顺序\r\n\r\n数值越小，排列越靠前，默认为0（和z-index不一样）\r\n\r\n!important 权重无穷大\r\n\r\n### 背景渐变 linear-gradient\r\n\r\n背景线性渐变（需要添加浏览器私有前缀）\r\n\r\n语法1\r\n\r\n```\r\nbackground: linear-gradient(起始方向，颜色1，颜色2);\r\nbackground: -webkit-linear-gradient(left,red,blue);\r\nbackground: -webkit-linear-gradient(left,top,red,blue);\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n起始方向可以是： 方位名词 或者 度数，如果省略默认就是top\r\n\r\n***\r\n\r\n# rem适配布局\r\n\r\n## 1.rem基础\r\n\r\n### rem单位\r\n\r\n-   rem(root em)是一个相对单位，类似于em，em是相对于父元素字体大小\r\n-   ### 不同的是rem是相对于html元素的字体大小，与父元素无关\r\n\r\neg.根元素（html）设置font-size=12px;非根元素设置width，换成px表示就是24px\r\n\r\nrem的优点就是可以通过修改html里面的文字大小来改变页面中元素的大小从而实现整体控制\r\n\r\n## 2.媒体查询\r\n\r\n-   使用@media查询，可以针对不同的媒体类型定义不同的样式\r\n-   @media可以针对不同的屏幕尺寸设置不同的样式\r\n-   当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面\r\n-   目前针对很多苹果手机、Android手机、平板等设备都用得到媒体查询\r\n\r\n###  语法规范\r\n\r\n```\r\n@media mediatype and|not|only (media feature){\r\n    CSS-Code;\r\n}\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n-   用@media开头，注意@符号\r\n-   mediatype媒体类型\r\n-   关键and not only\r\n-   media feature 媒体特性，必须有小括号包含\r\n\r\n###  2.1 mediatype查询类型\r\n\r\n将不同的终端设备划分成不同的类型，称为媒体类型\r\n\r\n| 值      | 解释说明              |\r\n| ------ | ----------------- |\r\n| all    | 用于所有设备            |\r\n| print  | 用于打印机和打印预览        |\r\n| screen | 用于电脑屏幕，平板电脑，智能手机等 |\r\n\r\n### 2.2 关键字\r\n\r\n将媒体类型或多个媒体特性连接到一起作为媒体查询的条件\r\n\r\n-   and： 可以将多个媒体特性连接到一起，相当于\"且\"的意思\r\n-   not： 排除某个媒体类型，相当于“非”的意思\r\n-   only： 指定某个特定的媒体类型，可以省略\r\n\r\n### 2.3 媒体特性\r\n\r\n每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格（注意加小括号包含）\r\n\r\n| 值         | 解释说明               |\r\n| --------- | ------------------ |\r\n| width     | 定义输出设备中页面可见区域的宽度   |\r\n| min-width | 定义输出设备中页面最小可见区域的宽度 |\r\n| max-width | 定义输出设备中页面最大可见区域的宽度 |\r\n\r\n### 2.3 媒体查询+rem实元素动态大小变化\r\n\r\n### 2.4 引入资源\r\n\r\n针对不同的屏幕尺寸，调用不同的css文件\r\n\r\n```\r\n<link rel=\"stylesheet\" media=\"mediatype and|not|only (media feature)\" href=\"mystylesheet.css\">\r\n```\r\n\r\n![](<> \"点击并拖拽以移动\")\r\n\r\n## 3.Less基础\r\n\r\nLess中文网址： http://lesscss.cn/\r\n\r\nLess是一门CSS预处理语言，它扩展了CSS的动态特性\r\n\r\n### 3.1 Less变量\r\n\r\n@变量名:值;\r\n\r\n**变量命名规范**\r\n\r\n-   必须有@前缀\r\n-   不能包含特殊字符\r\n-   不能以数字开头\r\n-   大小写敏感\r\n\r\n###  3.2 Less编译\r\n\r\n用VS Code中的Easy LESS插件\r\n\r\n### 3.3 Less嵌套\r\n\r\n子元素的样式直接写到父元素里面\r\n\r\n遇到交集/伪类/伪元素选择器：\r\n\r\n-   内层选择器的前面没有&符号，则他被解析为父选择器的后代\r\n\r\n-   如果有&符号，则被解析为父元素自身或父元素的伪类\r\n\r\n    ```\r\n    /* CSS中写法 */\r\n    a:hover {\r\n        color: red;\r\n    }\r\n    /* Less中写法 */\r\n    a {\r\n        &:hover {\r\n            color: red;\r\n        }\r\n    }\r\n    ```\r\n\r\n    ![](<> \"点击并拖拽以移动\")\r\n\r\n    ###\r\n\r\n###  3.4 Less运算\r\n\r\n任何数字、颜色、变量都可以参与加减乘除运算。\r\n\r\n注：\r\n\r\n-   运算符中间左右各有一个空格隔开1px + 5\r\n-   对于两个不同单位的值之间的运算，运算结果的值取第一个值的单位\r\n-   如果两个值之间只有一个值有单位，则运算结果就取该单位\r\n\r\n## 4.rem适配方案\r\n\r\n###  方案一\r\n\r\nrem+媒体查询+less技术\r\n\r\n**设计稿常见尺寸宽度**\r\n\r\n| 设备         | 常见宽度                 |\r\n| ---------- | -------------------- |\r\n| iphone 4 5 | 640px                |\r\n| iphone 678 | 750px                |\r\n| Android    | 大部分4.7~5寸的安卓设备为720px |\r\n\r\n**动态设置html标签font-size大小**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8359593eda0f48b48c29383b68430fa9~tplv-k3u1fbpfcp-zoom-1.image)![](<> \"点击并拖拽以移动\")​编辑\r\n\r\n**元素大小取值方法**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0129305ee5544146b5372e5f5bab21b8~tplv-k3u1fbpfcp-zoom-1.image)![](<> \"点击并拖拽以移动\")​编辑\r\n\r\n 将一个样式（css）文件导入另一个样式文件中： @import\"css文件名\"\r\n\r\n区别于link,link是把一个样式文件引入 html 页面中\r\n\r\n**方案2**\r\n\r\nrem+flexible.js\r\n\r\ngithub地址：https://github.com/amfe/lib-flexible\r\n\r\n***\r\n\r\n# 响应式布局 \r\n\r\n| 设备划分         | 尺寸区间              | 宽度     |\r\n| ------------ | ----------------- | ------ |\r\n| 超小屏幕（手机）     | <768px            | 100%   |\r\n| 小屏设备（平板）     | >=768px ~ <992px  | 750px  |\r\n| 中等屏幕（桌面显示器）  | >=992px ~ <1200px | 970px  |\r\n| 宽屏设备（大桌面显示器） | >=1200px          | 1170px |\r\n\r\n## Bootstrap\r\n\r\n中文官网： http://www.bootcss.com/\r\n\r\n官网： http://getbootstrap.com/\r\n\r\n推荐使用： http://bootstrap.css88.com/\r\n\r\n​",
        "timemini": ""
    },
    {
        "index": 24,
        "title": "简单计算器——JavaScript小实例",
        "essay": "## 简单计算器——JavaScript小实例\r\n\r\n>先来看一下下我们要做的计算器（以iQOO neo5手机计算器为例）：\r\n>\r\n><img src=\"\\计算器.jpg\" alt=\"计算器\" style=\"zoom:25%;\" />\r\n\r\n这就是我们今天要做的计算器的模板，成品的样子会略有不同，但功能完善。\r\n\r\n好，当我们看到这个计算器时，我们首先要想到它有几个功能，首先是，基础的加减乘除功能，正负号切换功能，AC(清除)功能，百分号功能，删除(Del)功能\r\n\r\n1.基本的HTML与CSS代码\r\n\r\n​\t首先，我们要写一个HTML页面，这包括一个屏幕(screen)，5行按钮(实现我们刚才所说的功能)，像这样，\r\n\r\n<img src=\"C:\\Users\\NS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220311201257243.png\" alt=\"image-20220311201257243\" style=\"zoom: 67%;\" />\r\n\r\nHTML代码如下：\r\n\r\n```HTML\r\n<div class=\"box\">\r\n    <!-- 屏幕 -->\r\n    <input type=\"button\" value=\"\" id=\"screen\" class=\"screen\">\r\n    <!-- 按钮 -->\r\n    <div>\r\n        <input type=\"button\" value=\"AC\" class=\"count\" onclick=\"clear_screen()\">\r\n        <input type=\"button\" value=\"Del\" class=\"count\" onclick=\"Delete()\">\r\n        <input type=\"button\" value=\"+/-\" class=\"count\" onclick=\"punctuation()\">\r\n        <input type=\"button\" value=\"/\" class=\"count\" onclick=\"add_string(this.value)\">\r\n    </div>\r\n    <div>\r\n        <input type=\"button\" value=\"7\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"8\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"9\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"*\" class=\"count\" onclick=\"add_string(this.value)\">\r\n     </div>\r\n     <div>\r\n        <input type=\"button\" value=\"4\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"5\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"6\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"-\" class=\"count\" onclick=\"add_string(this.value)\">\r\n     </div>\r\n     <div>\r\n        <input type=\"button\" value=\"1\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"2\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"3\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"+\" class=\"count\" onclick=\"add_string(this.value)\">\r\n     </div>\r\n     <div>\r\n        <input type=\"button\" value=\"%\" class=\"count\" onclick=\"add_string('*0.01')\">\r\n        <input type=\"button\" value=\"0\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\".\" class=\"count\" onclick=\"add_string(this.value)\">\r\n        <input type=\"button\" value=\"=\" class=\"count\" onclick=\"answer()\">\r\n     </div>\r\n</div>\r\n```\r\n\r\n简单的解释一下，在HTML中，每个按钮都有其对应的value，点击数字或符号按钮，我们会将相应的数字或符号(input中的value)以字符的形式相加，并将相加的值(字符串)赋值给id为screen的input标签的value属性，这样，就可以在屏幕中显示出来，点击等于号后，使用同样的方法，计算结果就能在屏幕中显示出来\r\n\r\nCSS 代码如下：\r\n\r\n```css\r\n*{\r\n    margin: 0;\r\n    text-decoration: none;\r\n    padding: 0;\r\n    list-style: none;\r\n    border: none;\r\n}\r\n.box1{\r\n    width: 100%;\r\n}\r\n.box{\r\n    width: 300px;\r\n    margin: 0 auto;\r\n}\r\n.count{\r\n    width:70px;\r\n    height: 70px;\r\n    text-align: center;\r\n    font-size: 30px;\r\n    cursor: pointer;\r\n    background-color: white;\r\n    transition: 0.8s all;\r\n}\r\n.count:hover{\r\n    background-color: rgb(144, 144, 233);\r\n}\r\n.screen{\r\n    height: 70px;\r\n    width: 280px;\r\n    border: transparent;\r\n    text-align: right;\r\n    font-size: 35px;\r\n}\r\n```\r\n\r\n2.计算器功能的实现\r\n\r\n* 加减乘除功能：\r\n\r\n  ​\t这里要介绍一个函数，叫作eval(string)，eval()函数会计算括号内的字符串，返回计算的结果，比如说eval(1+1)，返回值为2，下面涉及到加减乘除的功能都会使用这个方法。\r\n\r\n  ​\t通过按钮传输进来的参数会相加，成为一个字符串，进而用eval()函数实现加减乘除\r\n\r\n  ​\t例如：按下2，*，5，则会使用将2*5变为一个字符串，并使用eval()函数进行计算，得出结果\r\n\r\n  ``` javascript\r\n  //将screen变量与屏幕绑定\r\n  var screen = document.getElementById(\"screen\");\r\n  //将输入的字符相加为字符串\r\n  function add_string(a) {\r\n      screen.value += a;\r\n  }\r\n  //等于号功能(加减乘除功能)\r\n  function answer() {\r\n      //eval方法可以计算字符串表达式\r\n      var a;\r\n      try {\r\n          a = screen.value = eval(screen.value);\r\n      }\r\n      catch (err) {\r\n          if (a == undefined) {\r\n              screen.value = \"错误\";\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n* AC全部清除功能\r\n\r\n  ​\t想要清空屏幕，根据上面对HTML的介绍，我们只需要将id为screen的input标签的value值清除即可，这样屏幕便可清空\r\n\r\n  ```javascript\r\n  //将screen变量与屏幕绑定\r\n  var screen = document.getElementById(\"screen\");\r\n  //AC全部清除功能\r\n  function clear_screen() {\r\n      screen.value = \"\";\r\n  }\r\n  ```\r\n\r\n* 删除功能\r\n\r\n  ​\t接下来，又要给大家介绍一种新的函数，split()函数，将字符串分割，并返回一个字符数组，具体的使用方法是string.split(separator,limit)，string为字符串变量，separator为分割字符串的字符，limit为返回字符数组的最大length(长度)，也就是limit写多少，数组就会有几个元素，接下来给大家演示一下\r\n\r\n  ```javascript\r\n  //定义一个数组\r\n  var a=\"without you\";\r\n  //将数组按o分割\r\n  var arr=a.spilt('o');\r\n  ```\r\n\r\n  ​\t则，此时arr是一个字符数组，输出后的结果为\r\n\r\n  ​\twith,out  ,y,u\r\n\r\n  ​\t这时有人就要问了，如果我不写spilt内的值，像这样：\r\n\r\n  ```JavaScript\r\n  var arr=a.spilt('');\r\n  ```\r\n\r\n  ​\t会怎样呢\r\n\r\n  ​\t好问题，这样我们就可以获得以单个字符为基准的字符数组(空格也是字符哦)，如下：\r\n  ​\tw,i,t,h,o,u,t, ,y,o,u\r\n\r\n  ​\t好，我们的删除功能就是靠这个函数来实现的，我们先用上面的方法将字符串分开，然后，再去掉最后一个字符，就完成了删除的功能\r\n\r\n  ​\t我的想法是通过遍历(for循环)，将每一个字符相加，但是不加最后一个字符，这样，就去掉了最后一个字符，相加后说的字符串便是删除后的字符串\r\n\r\n  ​\t代码如下：\r\n\r\n  ```javascript\r\n  //将screen变量与屏幕绑定\r\n  var screen = document.getElementById(\"screen\");\r\n  //删除功能\r\n  function Delete() {\r\n      //将显示器中的字符串分隔为一个一个的字符数组\r\n      var str = screen.value;\r\n      var arr = str.split(\"\");\r\n  \r\n      //将字符串str定义为空，不然，默认的定义为undefined\r\n      var str1 = '';\r\n  \r\n      //删去最后一个字符，将字符重新连接成字符串\r\n      for (var i = 0; i < arr.length - 1; i++) {\r\n          str1 += arr[i];\r\n      }\r\n  \r\n      //重新为显示器赋值\r\n      screen.value = str1;\r\n  }\r\n  ```\r\n\r\n* 百分号功能：\r\n\r\n  ​\t这里的百分号是不能用eval()来计算的，功能主要使用0.01来替换，当输入%时，在屏幕上，会显示输入*0.01\r\n\r\n  ​\t这里说一下，并不是博主想要偷懒，而是，如果，我们想要实现百分号的功能的话，会涉及很多种情况，包括在字符串末尾，字符串中间，以及百分号的查找，识别，值的替换等等，十分繁琐，具体可以参考下面的正负号切换功能\r\n\r\n  ​\t当然，大家也可以参照下面的正负号切换来写这个百分号的功能\r\n\r\n  ​\t期待与大佬进行讨论\r\n\r\n* 正负号切换功能：\r\n\r\n  ​\t这个功能的解释篇幅有点多，如果大家不想看的话，可以跳过，直接看代码\r\n\r\n  ​\t好，首先来看一个思维导图：\r\n\r\n  ```mermaid\r\n  graph LR\r\n  A[字符串] -->|split方法|B(字符数组)\r\n  \r\n    B -->|for遍历|C[找到最后一个不为数字的字符]\r\n    C -->|右括号| D[有括号负数变正数]\r\n    C -->|加减乘除符号| E[正数变负数以及无括号负数变正数]\r\n    C -->|无| F[单一个数字的正数变负数]\r\n    D --> H[去括号和负号]\r\n    E --> I[加括号和负号]\r\n    F --> J[加括号和负号]\r\n    H --> M[负数变正数]\r\n    I --> K[正数变负数]\r\n    J --> K[正数变负数]\r\n    G[正负号切换功能]\r\n  ```\r\n  \r\n  ​\t这里 ，要再次为大家介绍一个函数，join()，这个函数可以将分开的字符数组连接，返回一个字符串值，使用方法如下：\r\n  \r\n  ​\tarray.join(separator)\r\n  \r\n  ​\tarray为数组，separator为一个可选参数，表示指定的分隔符，比如：\r\n  \r\n  ```javascript\r\n  var friends=[\"Ja\",\"va\",\"Sc\",\"ri\",\"pt\"];\r\n  var arr=friends.join('');\r\n  ```\r\n  \r\n  ​\t输出arr，则输出结果为\r\n  \r\n  ​\tJavaScript\r\n  \r\n  ​\t如果不设置分隔符，则默认分隔符为逗号\r\n  \r\n  ```javascript\r\n  var friends=[\"Ja\",\"va\",\"Sc\",\"ri\",\"pt\"];\r\n  var arr=friends.join();\r\n  ```\r\n  \r\n  ​\t则输出结果为\r\n  \r\n  ​\tJa,va,Sc,ri,pt\r\n  \r\n  **接下来，正式开始介绍正负号切换：**\r\n  \r\n  ​\t1.将字符分隔开，并找到最后一个不为数字的字符(且不为小数点)，使用for循环，使i的初值为字符数组的长度(最后一个字符的下标)，然后循环，直到找到最后一个不为数字的字符并将其下标存起来为止\r\n  \r\n  ​\t\t这样，就可以将正负号切换的几种情况分开\r\n  \r\n  ​\t\t此步的代码如下：\r\n  \r\n  ```JavaScript\r\n  var str = screen.value;     //屏幕的值\r\n  var arr = str.split(\"\");    //将屏幕值分为字符\r\n  var a;  //装载最后一个不为数字的字符\r\n  var m;  //传递右括号位置\r\n  //找出最后一个不为数字的字符(且不为小数点)\r\n  for (var i = arr.length - 1; i >= 0; i--) {\r\n  \t//字符与数字比较返回布尔值为false\r\n      if (!(arr[i] < 10) && arr[i] != '.') {\r\n          //将a赋值为最后一个字符，并以此分割\r\n          a = arr[i];\r\n          m = i;\r\n          break;\r\n      }\r\n  }\r\n  ```\r\n  \r\n  ​\t2.第一步结束后，最后一个不为数字的字符分为三种情况：undefined(无，单一个数字，正数变负数)，右括号(负数变正数)，加减乘除符号（正数变负数，无括号负数变正数），所以我们下面分三种情况来讨论\r\n  \r\n  ​\t3.1\tundefined(无，单一个数字，正数变负数)\r\n  \r\n  ​\t\t这里举一个例子，例如66这个数，无符号，单一个数字，我们首先将它乘以-1，再将其变为一个字符型常量，操作为\r\n  \r\n  ```javascript\r\n  var str=666;\r\n  str*=(-1);\r\n  str+='a';\r\n  ```\r\n  \r\n  ​\t这样上面的str的值就变为了666a，成为了一个字符型常量\r\n  \r\n  ​\t这时，为了计算方便同时不出错，就要加括号了，首先，将str分割为字符数组\r\n  \r\n  ```javascript\r\n  var arr1 = str1.split(\"\");\r\n  ```\r\n  \r\n  ​\t将数组中的字符统一向后移一位，留下左括号的位置，然后再将最后一个数组元素，也就是a替换为右括号，最后使用join函数连接，这样就大功告成了，示意图\r\n  \r\n  ![image-20220312134359726](C:\\Users\\NS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312134359726.png)\r\n  \r\n  ​\t\t此功能全部代码如下：\r\n  \r\n  ```javascript\r\n  var str = screen.value;     //屏幕的值\r\n  var arr = str.split(\"\");    //将屏幕值分为字符\r\n  var a;  //装载最后一个不为数字的字符\r\n  var m;  //传递右括号位置\r\n  var n;  //传递左括号位置\r\n  //找出最后一个不为数字的字符(且不为小数点)\r\n  for (var i = arr.length - 1; i >= 0; i--) {\r\n  \t//字符与数字比较返回布尔值为false\r\n      if (!(arr[i] < 10) && arr[i] != '.') {\r\n      \t//将a赋值为最后一个字符，并以此分割\r\n          a = arr[i];\r\n          m = i;\r\n          break;\r\n      }\r\n  }\r\n  //正数变负数\r\n  //最后一个不为数字字符不存在\r\n  if (a == undefined) {\r\n  \t//分割字符串为字符数组，并用arr1变量来装\r\n      var str1 = str;\r\n      str1 *= (-1);\r\n      if (str1 < 0) {\r\n      \t//将数字变为字符，不然无法分割\r\n          str1 += 'a';\r\n          var arr1 = str1.split(\"\");\r\n          //将所有字符向后移一位\r\n          for (var i = arr1.length - 1; i >= 0; i--) {\r\n          \tarr1[i + 1] = arr1[i];\r\n          }\r\n          //加上括号\r\n          arr1[0] = '(';\r\n          arr1[arr1.length - 1] = ')';\r\n          str1 = \"\";\r\n          for (var i = 0; i < arr1.length; i++) {\r\n          \tstr1 += arr1[i];\r\n          }\r\n  \t}\r\n      screen.value = str1;\r\n  }\r\n  ```\r\n  \r\n  ​\t3.2 加减乘除符号（正数变负数，无括号负数变正数）\r\n  \r\n  ​\t\t找出最后一个不为数字的符号为加减乘除符号后，并以此分割，这里以1+2-3为例，它的最后一个字符为减号，那么，我们就用减号作为split的分隔符\r\n  \r\n  ```JavaScript\r\n  var str='1+2-3';\r\n  var str1=str.split('-');\r\n  ```\r\n  \r\n  ​\t\t这样，则会得到一个数组，按照正负号切换的功能，我们要将计算字符串中最后一个数字切换正负号，比如，1+2-3切换正负号的结果为1+2-(-3)，所以，我们只需要分割后的字符数组的最后一个元素，这里，也就是3\r\n  \r\n  ​\t\t然后，将3转换为(-3)\r\n  \r\n  ​\t\t将3转换为(-3)的方法和**3.1undefined(无，单一个数字，正数变负数)**的方法是一样的\r\n  \r\n  ​\t\t之后，用split使用过的分隔符连接1+2和(-3)\r\n  \r\n  ```javascript\r\n  var str[1]='1+2';\r\n  var str[2]='(-3)';\r\n  var str1=str.join('-');\r\n  ```\r\n  \r\n  ​\t\t结果为1+2-(-3);\r\n  \r\n  ​\t\t此功能全部代码如下：\r\n  \r\n  ```javascript\r\n  var str = screen.value;     //屏幕的值\r\n  var arr = str.split(\"\");    //将屏幕值分为字符\r\n  var a;  //装载最后一个不为数字的字符\r\n  var m;  //传递右括号位置\r\n  var n;  //传递左括号位置\r\n  //找出最后一个不为数字的字符(且不为小数点)\r\n  for (var i = arr.length - 1; i >= 0; i--) {\r\n  \t//字符与数字比较返回布尔值为false\r\n      if (!(arr[i] < 10) && arr[i] != '.') {\r\n      \t//将a赋值为最后一个字符，并以此分割\r\n          a = arr[i];\r\n          m = i;\r\n          break;\r\n      }\r\n  }\r\n  //最后一个不为数字字符存在且不为右括号\r\n  else {\r\n  \t//分割字符串为字符数组，并用arr1变量来装\r\n      var arr1 = str.split(a);\r\n      //将arr2赋值为字符数组最后一个字符\r\n      var arr2 = arr1[arr1.length - 1];\r\n      //正负号切换\r\n      arr2 *= (-1);\r\n      //如果切换后为负值，将最后一个字符串分为一个一个的字符，插入括号\r\n      if (arr2 < 0) {\r\n      \tarr2 += 'a';\r\n          var arr3 = arr2.split(\"\");\r\n          for (var i = arr3.length - 1; i >= 0; i--) {\r\n          \tarr3[i + 1] = arr3[i];\r\n          }\r\n          arr3[0] = '(';\r\n          arr3[arr3.length - 1] = ')';\r\n          arr2 = \"\";\r\n          for (var i = 0; i < arr3.length; i++) {\r\n          \tarr2 += arr3[i];\r\n          }\r\n      }\r\n      //将最后一个值替换为正负号切换后的值\r\n      arr1[arr1.length - 1] = arr2;\r\n      //将分开的字符串连接\r\n      str = arr1.join(a);\r\n      screen.value = str;\r\n  }\r\n  ```\r\n  \r\n  ​\t3.3 右括号(负数变正数)\r\n  \r\n  ​\t\t举个例子，比如(-3)，将它变正数，需要将括号和负号去掉\r\n  \r\n  ​\t\t先将其分解为字符数组arr\r\n  \r\n  ​\t\t先找到右括号的数组元素，将其赋值为空，在找到左括号的数组元素，设其下标为index，则3的下标则为index+2，使用for循环使arr[index]=arr[index+2]，这样之后，就只存在数字，负号与括号就都被去掉了，图示如下\r\n  \r\n  ![image-20220312142534960](C:\\Users\\NS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312142534960.png)\r\n  \r\n\r\n到此，简单计算机的JavaScript块就结束了，全部JavaScript代码如下：\r\n\r\n```javascript\r\n//将screen变量与屏幕绑定\r\nvar screen = document.getElementById(\"screen\");\r\n//将输入的字符相加为字符串\r\nfunction add_string(a) {\r\n    screen.value += a;\r\n}\r\n//等于号功能(加减乘除功能)\r\nfunction answer() {\r\n    var a;\r\n    try {\r\n        a = screen.value = eval(screen.value);\r\n    }\r\n    catch (err) {\r\n        if (a == undefined) {\r\n            screen.value = \"错误\";\r\n        }\r\n    }\r\n}\r\n//清屏功能\r\nfunction clear_screen() {\r\n    screen.value = \"\";\r\n}\r\n//删除功能\r\nfunction Delete() {\r\n    //将显示器中的字符串分隔为一个一个的字符数组\r\n    var str = screen.value;\r\n    var arr = str.split(\"\");\r\n\r\n    //将字符串str定义为空，不然，默认的定义为undefined\r\n    var str1 = '';\r\n\r\n    //删去最后一个字符，将字符重新连接成字符串\r\n    for (var i = 0; i < arr.length - 1; i++) {\r\n        str1 += arr[i];\r\n    }\r\n\r\n    //重新为显示器赋值\r\n    screen.value = str1;\r\n}\r\n\r\n\r\n\r\n//切换正负号功能\r\nfunction punctuation() {\r\n    var str = screen.value;     //屏幕的值\r\n    var arr = str.split(\"\");    //将屏幕值分为字符\r\n    var a;  //装载最后一个不为数字的字符\r\n    var m;  //传递右括号位置\r\n    var n;  //传递左括号位置\r\n    //找出最后一个不为数字的字符(且不为小数点)\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        //字符与数字比较返回布尔值为false\r\n        if (!(arr[i] < 10) && arr[i] != '.') {\r\n            //将a赋值为最后一个字符，并以此分割\r\n            a = arr[i];\r\n            m = i;\r\n            break;\r\n        }\r\n    }\r\n    //正数变负数\r\n    //最后一个不为数字字符不存在\r\n    if (a == undefined) {\r\n        //分割字符串为字符数组，并用arr1变量来装\r\n        var str1 = str;\r\n\r\n        str1 *= (-1);\r\n        if (str1 < 0) {\r\n            //将数字变为字符，不然无法分割\r\n            str1 += 'a';\r\n            var arr1 = str1.split(\"\");\r\n            //将所有字符向后移一位\r\n            for (var i = arr1.length - 1; i >= 0; i--) {\r\n                arr1[i + 1] = arr1[i];\r\n            }\r\n            //加上括号\r\n            arr1[0] = '(';\r\n            arr1[arr1.length - 1] = ')';\r\n            str1 = \"\";\r\n            for (var i = 0; i < arr1.length; i++) {\r\n                str1 += arr1[i];\r\n            }\r\n        }\r\n        screen.value = str1;\r\n    }\r\n    //有括号负数变正数\r\n    //最后一个不为括号字符为右括号\r\n    else if (a == ')') {\r\n        //将装有右括号赋值为空\r\n        arr[m] = '';\r\n        var i;\r\n        //找到左括号位置\r\n        for (i = 0; i < arr.length; i++) {\r\n            if (arr[i] == '(') {\r\n                break;\r\n            }\r\n        }\r\n        //将左括号赋值为数字\r\n        for (n = i; n < arr.length; n++) {\r\n            //左括号与数字字符相差两个字符\r\n            arr[n] = arr[n + 2];\r\n        }\r\n        //将字符再次连接\r\n        var arr1 = arr.join('');\r\n        screen.value = arr1;\r\n    }\r\n    //最后一个不为数字字符存在且不为右括号\r\n    else {\r\n        //分割字符串为字符数组，并用arr1变量来装\r\n        var arr1 = str.split(a);\r\n        //将arr2赋值为字符数组最后一个字符\r\n        var arr2 = arr1[arr1.length - 1];\r\n        //正负号切换\r\n        arr2 *= (-1);\r\n        //如果切换后为负值，将最后一个字符串分为一个一个的字符，插入括号\r\n        if (arr2 < 0) {\r\n            arr2 += 'a';\r\n            var arr3 = arr2.split(\"\");\r\n            for (var i = arr3.length - 1; i >= 0; i--) {\r\n                arr3[i + 1] = arr3[i];\r\n            }\r\n            arr3[0] = '(';\r\n            arr3[arr3.length - 1] = ')';\r\n            arr2 = \"\";\r\n            for (var i = 0; i < arr3.length; i++) {\r\n                arr2 += arr3[i];\r\n            }\r\n        }\r\n        //将最后一个值替换为正负号切换后的值\r\n        arr1[arr1.length - 1] = arr2;\r\n        //将分开的字符串连接\r\n        str = arr1.join(a);\r\n        screen.value = str;\r\n    }\r\n}\r\n```\r\n\r\n好像这个简单计算器也没那么简单，思路简单，但是写起来麻烦，哈哈哈\r\n\r\n最后，感谢大家的阅读，谢谢，如果觉得有用可以点个赞哦\r\n\r\n如果，有什么错误，可以在评论区指出，期待与你们的讨论！\r\n\r\n  \r\n\r\n",
        "timemini": ""
    },
    {
        "index": 25,
        "title": "计算机网络",
        "essay": "## 计算机网络\r\n\r\n### Chapter 01计算机网络\r\n\r\n#### 1.3 网络、互联网、因特网\r\n\r\n网络：结点和链路\r\n\r\n互联网(internet)：网络的网络\r\n\r\n因特网(Internet)：最大的互联网\r\n\r\n因特网服务提供者ISP：中国电信、联通、移动\r\n\r\n边缘部分：连接在因特网上的主机\r\n\r\n核心部分：由大量网络和连接这些网络的路由器组成。为边缘部分提供服务。\r\n\r\n\r\n\r\n#### 1.3 三种交换方式\r\n\r\n电路交换：电话交换机接通电话线的方式。\r\n\r\n​\t\t\t\t\t三个步骤：①建立连接\t②通话\t③释放连接\r\n\r\n分组交换：发送方：构造分组，发送分组\t路由器：缓存分组，转发分组\t接收方：接收分组，还原报文\r\n\r\n报文交换\r\n\r\n\r\n\r\n#### 1.4 计算机网络的定义和分类\r\n\r\n计算机网络的定义：一些互相连接的、自治的计算机的集合\r\n\r\n计算机网络的分类：\r\n\r\n​\t\t按交换技术分类：电路交换网络，报文交换网络，分组交换网络\r\n\r\n​\t\t按使用者分类：公用网，专用网\r\n\r\n​\t\t按传输介质分类：有线网络，无线网络\r\n\r\n​\t\t按覆盖范围分类：广域网WAN，城域网MAN，局域网LAN，个域网PAN\r\n\r\n​\t\t按拓扑结构分类：总线型网络，星型网络，环型网络，网状型网络\r\n\r\n\r\n\r\n#### 1.5 计算机网络的性能指标\r\n\r\n**速率**(也称比特率或数据率)：连接在计算机网络上的主机在数字信道上传送比特的速率\r\n\r\n​\t\t注：比特的进制采用的是2^10^,而速率的进制采用10^3^\r\n\r\n**带宽**：用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点\t\t所能通过的最高数据率；单位：b/s,kb/s,Mb/s\r\n\r\n**吞吐量**：在单位时间内通过某个网络的数据量，受网络带宽或额定速率的限制。\r\n\r\n**时延**：网络时延由发送时延，传播时延和处理时延组成\r\n\r\n**时延带宽积**：传播时延与带宽的乘积，又称为以比特为单位的链路长度\r\n\r\n**往返时间(RTT)**：双向交互一次所需的时间\r\n\r\n**利用率**：信道利用率：某信道有百分之几的时间是被利用的。\t网络利用率：全网络的信道利用率加权平均\r\n\r\n​\t\t\t\t信道利用率增大时，该信道引起的时延也会迅速增加\r\n\r\n**丢包率**：即分组丢失率，传输过程中丢失的分组数量与总分组数量的比率\r\n\r\n​\t\t\t\t分组丢失主要有两种情况：传输过程中出现误码，分组到达一台队列已满的分组交换机时被丢弃。\r\n\r\n\r\n\r\n#### 1.6 计算机网络体系结构\r\n\r\n1. 常见的计算机网络体系结构\r\n\r\n   OSI体系结构：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层\r\n\r\n   ==TCP/IP体系结构：网络接口层、网际层、运输层、应用层==\r\n\r\n   ​\t网络接口层：网络接口……\r\n\r\n   ​\t网际层：IP\r\n\r\n   ​\t运输层：TCP  UDP\r\n\r\n   ​\t应用层：HTTP  SMTP     DNS  RTP\r\n\r\n   原理体系结构：物理层、数据链路层、网络层、运输层、应用层\r\n\r\n   \r\n\r\n2. 分层的必要性\r\n\r\n   ​\t物理层：解决使用何种信号来传输比特的问题\r\n\r\n   ​\t数据链路层：解决分组在一个网络上传输的问题\r\n\r\n   ​\t网络层：解决分组在多个网络上传输的问题\r\n\r\n   ​\t运输层：解决进程之间基于网络的通信问题\r\n\r\n   ​\t应用层：解决通过应用进程的交互来实现特定网络应用的问题\r\n\r\n   \r\n\r\n3. 分层思想举例\r\n\r\n   HTTP  ->  HTTP TCP  ->  HTTP TCP IP   ->  ETH HTTP TCP IP ETH  ->  比特流\r\n\r\n   \r\n\r\n4. 专业术语\r\n\r\n   实体：任何可发送或接收信息的硬件或软件进程\r\n\r\n   协议：控制两个对等实体进行逻辑通信的规则的集合\r\n\r\n   ​\t\t\t三要素：语法、语义、同步\r\n\r\n   服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还需\t\t\t要使用下面一层所提供的服务。\r\n\r\n   协议数据单元PDU：报文、TCP报文段或UDP报文段、IP数据报或分组、帧、比特流\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Chapter 02物理层\r\n\r\n#### 2.1 基本概念\r\n\r\n机械特性、电气特性、功能特性、过程特性\r\n\r\n- 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\r\n- 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒介是什么。\r\n\r\n\r\n\r\n#### 2.2 物理层下面的传输媒体\r\n\r\n导引型传输媒体：同轴电缆，双绞线，光纤，电力线。\r\n\r\n非导引型传输媒体：无线电波，微波，红外线，可见光。\r\n\r\n\r\n\r\n#### 2.3 传输方式\r\n\r\n串行传输、并行传输\r\n\r\n同步传输、异步传输\r\n\r\n单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）\r\n\r\n\r\n\r\n#### 2.4 编码与调制\r\n\r\n常用编码：不归零编码、归零编码、曼彻斯特编码、差分曼彻斯特编码\r\n\r\n基本调制方法：调幅、调频、调相\r\n\r\n\r\n\r\n#### 2.5 信道的极限容量\r\n\r\n奈氏准则：为避免码间串扰，码元传输速率是有上限的。\r\n\r\n香农公式：$c = W \\times log_{2}(1 + \\frac{S}{N})$\r\n\r\n\r\n\r\n\r\n\r\n### Chapter 03 数据链路层\r\n\r\n#### 3.1 概述\r\n\r\n链路：从一个结点到相邻结点的一段物理线路，中间没有任何其他交换结点。\r\n\r\n数据链路：把实现通信协议的硬件和软件加到链路上。（以**帧**为单位传输）\r\n\r\n封装成帧：添加帧头和帧尾。\r\n\r\n差错检测：通过帧尾的检错码和检错算法，判断是否出现误码。\r\n\r\n可靠传输：发送方发送什么，接收方就能接收什么。\r\n\r\n\r\n\r\n#### 3.2 封装成帧\r\n\r\n封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使其成为帧。\r\n\r\n帧头和帧尾中包含重要的控制信息。\r\n\r\n帧头和帧尾的作用之一就是**帧定界**。\r\n\r\n- 透明传输：数据链路层对上层交付的传输数据没有任何限制。\r\n  - 面对字节：使用字节填充（转义字符）\r\n    - 对传输数据中出现的与定界符和转义字符相同的数据，前面再添加一个转义字符。（转义字符是一个字节，十进制为27）\r\n  - 面对比特：使用比特填充。\r\n\r\n\r\n\r\n#### 3.3 差错检测\r\n\r\n比特差错：比特出现误码\r\n\r\n误码率BER：传输错误的比特所占传输比特总数的比率。\r\n\r\n差错检测码\r\n\r\n- 奇偶校验\r\n- 循环冗余校验CRC\r\n\r\n\r\n\r\n#### 3.4 可靠传输\r\n\r\n##### 3.4.1 基本概念\r\n\r\n对于检测出了误码，数据链路层向上层提供的服务类型\r\n\r\n- 不可靠传输服务：仅仅丢弃有误码的帧\r\n- 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。\r\n\r\n一般，有线链路误码率较低，不要求数据链路层向上提供可靠传输服务。可靠传输的问题由其上层处理。\r\n\r\n无线链路误码率较高，要求数据链路层向上层提供可靠传输服务。\r\n\r\n上层传输差错：分组丢失、分组失序、分组重复\r\n\r\n##### 3.4.2 可靠传输的实现机制——停止等待协议SW\r\n\r\n![SW](C:\\D\\PCR\\Notes\\Pictures\\SW.jpg)\r\n\r\n##### 3.4.3 可靠传输的实现机制——回退N帧协议GBN\r\n\r\n累积确认：ACKn表示序号为n及以前的所有数据分组都已正确接收\r\n\r\n##### <img src=\"C:\\D\\PCR\\Notes\\Pictures\\GBN.jpg\" alt=\"GBN\" style=\"zoom: 50%;\" />\r\n\r\n##### 3.4.4 可靠传输的实现机制——选择重传协议SR\r\n\r\n![SR](C:\\D\\PCR\\Notes\\Pictures\\SR.jpg)\r\n\r\n\r\n\r\n#### 3.5 点对点协议PPP\r\n\r\n目前使用最广泛的点对点数据链路层协议\r\n\r\n封装成帧、链路控制协议LCP、一套网络控制协议NCPs\r\n\r\n- 标志字段(Flag)：PPP帧的定界符，取值为0X7E\r\n\r\n- 地址字段(Address)：取值为0XFF,预留\r\n\r\n- 控制字段(Control)：取值为0X03,预留\r\n\r\n- 协议字段(Protocol)：指明帧的数据部分送交哪个协议处理\r\n  - 取值0x0021表示：帧的数据部分为IP数据报\r\n  - 取值0xC021表示：帧的数据部分为LCP分组\r\n  - 取值0x8021表示：帧的数据部分为NCP分组\r\n- 帧校验序列字段FCS：CRC计算出的校验位\r\n\r\n\r\n\r\n#### 3.6 媒体接入控制MAC\r\n\r\n##### 3.6.1 基本概念\r\n\r\n共享信道要着重考虑的一个问题就是如何协调多个发送和接受站点对一个共享传输媒体的占用，即**媒体接入控制MAC**\r\n\r\n媒体接入控制->动态接入控制->随机接入\r\n\r\n##### 3.6.2 静态划分信道\r\n\r\n- FDM频分复用\r\n- TDM时分复用\r\n- WDM波分复用：光纤中不同波长的光\r\n- CDM码分复用：每个站指派一个唯一的码\r\n\r\n##### 3.6.3随机接入——CSMA/CD协议（有线局域网）\r\n\r\n载波监听多址接入/碰撞检测 CSMA/CD\r\n\r\n![image-20220713215027051](C:\\D\\PCR\\Notes\\Pictures\\CSMACD.png)\r\n\r\n争用期：以太网的端到端往返传输时延。\r\n\r\n最小帧长：确保了主机可以在帧发送完成之前就检测到该帧的发送过程中是否发送了碰撞，以太网规定最小帧长为64字节。\r\n\r\n最大帧长\r\n\r\n截断二进制指数退避算法\r\n\r\n![image-20220713220712387](C:\\D\\PCR\\Notes\\Pictures\\image-20220713220712387.png)\r\n\r\n信道利用率\r\n\r\n##### 3.6.4 随机接入——CSMA/CA协议（无线局域网）\r\n\r\n载波监听多址接入/碰撞避免 CSMA/CA\r\n\r\n**在无线局域网中仍可以使用CSMA,但不能使用CD**\r\n\r\n帧间间隔：站点必须在持续检测到信道空闲一段指定时间后才能发送帧，即帧间间隔IFS\r\n\r\n长帧间间隔DIFS、短帧间间隔SIFS\r\n\r\n\r\n\r\n#### 3.7 MAC地址、IP地址以及APR协议\r\n\r\nMAC地址：以太网的MAC子层所使用的地址\r\n\r\nIP地址：TCP/IP体系结构网际层所使用的地址\r\n\r\nAPR协议：属于TCP/IP体系结构的网际层，作用是已知设备所分配到的IP地址，使用APR协议可以通过该IP地址获取到设备的MAC地址\r\n\r\n##### 3.7.1MAC地址\r\n\r\n- 用于媒体接入控制的地址就是MAC地址。是主机发送的帧中携带标识发送主机和接受主机的地址。\r\n\r\n- 也被称为**硬件地址**,有时也称为**物理地址**。\r\n- MAC地址是对网络上接口的唯一标识。\r\n  - IEEE 802局域网的MAC地址格式：XX-XX-XX-XX-XX-XX 或 XX:XX:XX:XX:XX:XX 或 XXXX.XXXX.XXXX\r\n  - 单播地址、广播地址、多播地址\r\n\r\n##### 3.7.2 IP地址\r\n\r\nIP地址是因特网上的主机和路由器所使用的地址，用于表示两部分信息：\r\n\r\n网络编号：标识以太网上数以百万计的网络\r\n\r\n主机编号：表示同一网络上不同主机哦（或路由器接口）\r\n\r\n数据包转发过程中：源IP地址和目的IP地址保持不变；源MAC地址和目的MAC地址逐个网络改变。\r\n\r\n##### 3.7.3 ARP协议\r\n\r\n根据IP寻找MAC\r\n\r\n\r\n\r\n#### 3.8 集线器和交换机\r\n\r\n集线器HUB：简单看作一条总线\r\n\r\n交换机AWITCH：全双工，多接口，隔离碰撞域\r\n\r\n\r\n\r\n#### 3.9 交换机自学习和转发帧的过程\r\n\r\n\r\n\r\n#### 3.10 交换机的生成树协议STP\r\n\r\n\r\n\r\n#### 3.11 虚拟局域网VLAN\r\n\r\n- 使用路由器可以隔离广播域\r\n- 虚拟局域网是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术。\r\n- 实现机制\r\n  - .1Q帧\r\n  - 端口类型\r\n    - Access\r\n    - Trunk\r\n    - Hybrid\r\n\r\n\r\n\r\n\r\n\r\n### Chapter04 网络层\r\n\r\n#### 4.1 概述\r\n\r\n网络层的主要任务是**实现网络互联，进而实现数据包在各网络之间的传输**\r\n\r\n- 网络层向运输层提供怎样的服务\r\n- 网络层寻址问题\r\n- 路由选择问题\r\n\r\n因特网使用TCP/IP协议，其网络层使用网际协议IP，因此在TCP/IP协议栈中网络层常称为**网际层**\r\n\r\n\r\n\r\n#### 4.2 网络层提供的两种服务\r\n\r\n##### 4.2.1 面向连接的虚电路服务\r\n\r\n- 可靠性由网络来保证\r\n- 建立网络层的连接——虚电路VC\r\n- 沿着已建立的虚电路发送分组\r\n\r\n##### 4.2.2 无连接的数据报服务\r\n\r\n- 可靠通信由用户主机保证\r\n- 不需要建立网络层连接\r\n- 每个分组走不同的路径\r\n\r\n![image-20220718153225771](C:\\D\\PCR\\Notes\\Pictures\\image-20220718153225771.png)\r\n\r\n\r\n\r\n#### 4.3 IPv4地址\r\n\r\n**IPv4地址**：给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的32比特标识符\r\n\r\n点分十进制表示方法，如：255.255.0.1\r\n\r\n##### 4.3.2 分类编址的IPv4地址\r\n\r\nA类地址   8+24：网络号0+主机号\r\n\r\n- 网络号0保留，最小可指派网络号为1，即1.0.0.0 最后一个可指派网络号为126，网络地址为126.0.0.0\r\n- 最大网络号127为本地环回测试地址不指派，最小本地环回测试地址为127.0.0.1，最大为127.255.255.254\r\n\r\nB类地址   16+16：网络号10+主机号\r\n\r\n- 第一个可指派网络号128.0\r\n- 最大网络号191.255\r\n\r\nC类地址\t24+8：网络号110+主机号\r\n\r\n- 第一个可指派网络号192.0.0\r\n- 最大网络号223.255.255\r\n\r\nD类地址\t1110多播地址\r\n\r\nE类地址\t1111保留为今后使用\r\n\r\n主机号全0是网络地址，主机号全1是广播地址\r\n\r\n##### 4.3.3 划分子网的IPv4地址\r\n\r\n**子网掩码**：32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特来作为子网号\r\n\r\n- 用连续的比特1来对应网络号和子网号\r\n- 用连续的比特0来对应主机号\r\n- 将划分子网的IPv4地址与子网掩码进行逻辑与运算即可得到所在子网的网络地址\r\n\r\n默认子网掩码：未划分子网情况下的子网掩码\r\n\r\n- A类：255.0.0.0\r\n- B类：255.255.0.0\r\n- C类：255.255.255.0\r\n\r\n##### 4.3.4 无分类编址的IPv4地址\r\n\r\nCIDR使用“斜线记法”，即在IPv4地址后面加上斜线“/”，在斜线后面写上网络前缀所占的比特数量。\r\n\r\n如：128.14.35.7 /20\r\n\r\n地址块：最小地址、最大地址、地址数量、聚合C类网的数量、地址掩码\r\n\r\n路由聚合：（构造超网）\r\n\r\n用共同前缀代替多个IP地址\r\n\r\n最长前缀匹配：若多个路由都可匹配，选择前缀最长的\r\n\r\n##### 4.3.5 IPv4地址的应用规划\r\n\r\n定长的子网掩码FLSM：使用同一个子网掩码\r\n\r\n变长的子网掩码VLSM：使用不同子网掩码\r\n\r\n\r\n\r\n#### 4.4 IP数据报的发送和转发过程\r\n\r\n- 主机发送IP数据报\r\n- 路由器转发IP数据报\r\n\r\n判读是否在同一个子网下：\r\n\r\n- 将自己的子网掩码与IP与得自己的网络地址，将对方的IP与自己的子网掩码与，判断与自己的网络地址是否相同。\r\n- 默认网关：向外转发的路由器的接口的IP地址\r\n\r\n\r\n\r\n#### 4.5 静态路由配置\r\n\r\n- 人为配置\r\n- 多种情况下都可能出现路由环路\r\n\r\n\r\n\r\n#### 4.6 路由选择协议\r\n\r\n##### 4.6.1 概述\r\n\r\n- 静态路由选择\r\n  - 人工配置\r\n  - 不能及时适应网络状态变化\r\n  - 小规模网络采用\r\n- 动态路由选择\r\n  - 自动获取路由信息\r\n  - 能较好适应网络状态变化\r\n  - 适用于大规模网络\r\n\r\n因特网所采用的路由选择协议的主要特点\r\n\r\n- 自适应\r\n- 分布式\r\n- 分层次\r\n\r\n##### 4.6.2 路由信息协议RIP\r\n\r\n内部网关协议之一\r\n\r\n使用**跳数**作为度量来衡量到达目的网络的距离\r\n\r\n距离向量D-V：自治系统AS内的每一个路由器都要维护他自己到AS内其他每一个网络的距离记录\r\n\r\n路由器到直连网络的距离定义为1\r\n\r\n允许一条路径最多包含15个路由器，距离等于16时相当于不可达，故RIP只适用于小型互联网。\r\n\r\nRIP包含以下三个要点：\r\n\r\n1. 和谁交换信息？仅和相邻路由器交换信息\r\n2. 交换什么信息？自己的路由表\r\n3. 何时交换信息？周期性交换\r\n\r\nRIP存在“坏消息传得慢”的问题，解决办法：\r\n\r\n1. 限制最大路径距离\r\n2. 触发更新而不仅是周期性发送\r\n3. 水平分割\r\n\r\n##### 4.6.3 开放最短路径优先OSPF\r\n\r\n- 公开发表\r\n- 采用最短路径算法SPF\r\n- 基于链路状态（链路状态指和哪些路由器相邻，及相应链路的代价）\r\n- 不会产生路由环路\r\n- 不限制网络规模，收敛速度快\r\n\r\n使用OSPF的每个路由器都会产生**链路状态通告LSA** 。包含以下内容：直连网络的链路状态信息、邻居路由器的链路状态信息\r\n\r\n使用链路状态数据库LSDB存储链路状态通告\r\n\r\n##### 4.6.4 边界网关协议BGP\r\n\r\n外部网关协议\r\n\r\nBGP报文被封装在TCP报文中\r\n\r\nRIP封装哎UDP中，OSPF封装在IP中\r\n\r\n\r\n\r\n#### 4.7 IPv4数据报的首部格式\r\n\r\n![image-20220719212429988](C:\\D\\PCR\\Notes\\Pictures\\image-20220719212429988.png)\r\n\r\n#### 4.8 网际控制报文协议ICMP\r\n\r\n主机或路由器使用ICMP来发送差错报告报文和询问报文，ICMP封装在IP数据报中\r\n\r\n差错报文：\r\n\r\n- 终点不可达\r\n- 源点抑制\r\n- 时间超过\r\n- 参数问题\r\n- 改变路由（重定向）\r\n\r\n以下情况不应发送ICMP差错报告报文：\r\n\r\n- 对ICMP差错报告报文不再发送ICMP差错报告报文\r\n- 对第一个分片的数据包片的所有后续数据报片都不发送ICMP差错报告报文\r\n- 对具有多播地址的数据报都不发生ICMP差错报告报文\r\n- 对具有特殊地址的数据报不发送ICMP差错报告报文\r\n\r\n询问报文：\r\n\r\n- 回送请求和问答\r\n- 时间戳请求和回答\r\n\r\nICMP应用举例：分组网间探测PING、跟踪路由tracert\r\n\r\n#### 4.9 虚拟专用网VPN与网络地址转换NAT\r\n\r\n虚拟专用网VPN：用于内部通信，无需申请\r\n\r\n网络地址转换NAT：再次缓解IPv4耗尽的问题，将私有地址修改为临时的全球ip地址\r\n\r\n\r\n\r\n\r\n\r\n### Chapter05 传输层\r\n\r\n#### 5.1 概述\r\n\r\nAP：应用进程\r\n\r\n运输层是进程到进程的通信（端到端）\r\n\r\n网络层是主机到主机的通信\r\n\r\n两种协议：面向连接的TCP和面向无连接的UDP\r\n\r\n\r\n\r\n#### 5.2 运输层端口号、复用与分用\r\n\r\n- 运行在计算机上的进程使用进程标识符PID来标识\r\n\r\n- 不同操作系统有不同的进程标识符，为统一标识进程采用端口号来区分不同应用进程\r\n\r\n- 端口号使用**16**比特表示，取值范围为**0~65535**\r\n\r\n  - 熟知端口号：0~1023，如HTTP使用80，DNS使用53\r\n  - 登记端口号：1024~49151\r\n  - 短暂端口号：49152~65535\r\n\r\n  **端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，不同计算机中相同端口号是没有联系的。**\r\n\r\n- 发送方的复用和接收方的分用\r\n\r\n  ![image-20220721154619937](C:\\D\\PCR\\Notes\\Pictures\\image-20220721154619937.png)\r\n\r\n\r\n\r\n#### 5.3 ==UDP和TCP的对比==\r\n\r\n![image-20220721160044567](C:\\D\\PCR\\Notes\\Pictures\\image-20220721160044567.png)\r\n\r\n\r\n\r\n#### 5.4 TCP的流量控制\r\n\r\n滑动窗口机制：\r\n\r\n- TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小\r\n- TCP发送方收到接收方的零窗口通知后，应用启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。\r\n\r\n\r\n\r\n#### 5.5 TCP的拥塞控制\r\n\r\n拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可以部分，网络性能就要变坏。\r\n\r\n若出现拥塞而不进行控制，整个网络的吞吐量将对输入负荷的增大而下降。\r\n\r\n慢开始：指数\r\n\r\n拥塞避免：线性+1\r\n\r\n快重传：发送方一旦受到3个连续的重复确认，就将相应的报文段立即重传。\r\n\r\n快恢复：降到当前的一半然后线性加1\r\n\r\n![image-20220721164039667](C:\\D\\PCR\\Notes\\Pictures\\image-20220721164039667.png)\r\n\r\n\r\n\r\n#### 5.6 TCP超时重传时间的选择\r\n\r\n![image-20220721164658333](C:\\D\\PCR\\Notes\\Pictures\\image-20220721164658333.png)\r\n\r\n\r\n\r\n#### 5.7 TCP可靠传输的实现\r\n\r\nTCP基于以字节为单位的滑动窗口来实现可靠传输\r\n\r\n\r\n\r\n#### 5.8 TCP的运输连接管理\r\n\r\n##### 5.8.1 TCP的连接建立\r\n\r\n“三次握手”建立连接\r\n\r\n![image-20220721171408668](C:\\D\\PCR\\Notes\\Pictures\\image-20220721171408668.png)\r\n\r\n\r\n\r\n为什么要三次握手而不是两次握手？\r\n\r\n> 为了防止已失效的连接请求报文突然又传入了TCP服务器\r\n>\r\n> 为了服务器可以确认自己的发送功能和客户端的接受功能正常\r\n\r\n##### 5.8.2 TCP的连接释放\r\n\r\n“四次挥手”释放连接\r\n\r\n![image-20220721172238659](C:\\D\\PCR\\Notes\\Pictures\\image-20220721172238659.png)\r\n\r\n时间等待状态是为了确保服务端收到最后一个TCP确认报文从而进入关闭状态\r\n\r\n\r\n\r\n#### 5.9 TCP报文段的首部格式\r\n\r\n![image-20220721172532622](C:\\D\\PCR\\Notes\\Pictures\\image-20220721172532622.png)\r\n\r\n\r\n\r\n\r\n\r\n### Chapter06 应用层\r\n\r\n#### 6.1 概述\r\n\r\n应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的。\r\n\r\n\r\n\r\n#### 6.2 客户/服务器方式和对等方式\r\n\r\n- 客户/服务器方式（C/S方式）\r\n\r\n  - 客户是服务请求放，服务器是服务提供方\r\n\r\n  - 服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（如HTTP服务器的默认端口号为80），而运行服务器的主机也具有固定的IP地址。\r\n\r\n  - 基于C/S方式的应用服务通常是服务集中型的，常会出现服务器跟不上众多客户机请求的情况，为此常用计算机群集构建一个强大的虚拟服务器。\r\n\r\n- 对等方式（P2P方式）\r\n  - 没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者又是服务的提供者。\r\n  - 服务分散型\r\n  - 可扩展性，系统性能不会因为规模的增大而降低。\r\n  - 具有成本上的优势\r\n\r\n\r\n\r\n#### 6.3 动态主机配置协议DHCP\r\n\r\n- DHCP的工作过程\r\n  - 使用UDP协议\r\n\r\n![image-20220722154345931](C:\\D\\PCR\\Notes\\Pictures\\image-20220722154345931.png)\r\n\r\n\r\n\r\n- DHCP中继代理\r\n  - 计算机在向DHCP服务器发送请求时无法通过路由器转发到服务器，此时需要给路由器配置DHCP服务器的IP地址使其成为DHCP中继代理。\r\n\r\n\r\n\r\n#### 6.4 域名系统DNS\r\n\r\n- 域名系统的作用\r\n\r\n  - 根据域名查询IP地址\r\n  - 先在自己的DNS缓存中查询，然后再去DNS服务器中查询\r\n\r\n- 域名结构\r\n\r\n  - ···  .  三级域名  .  二级域名  .  顶级域名\r\n  - 每一级都由英文字母和数字组成，不超过63个字符，不区分大小写\r\n  - 完整的域名不超过255个字符\r\n  - 顶级域名TLD分为以下三类\r\n    - 国家顶级域名nTLD:  cn表示中国  us表示美国  uk表示英国\r\n    - 通用顶级域名gTLD:  com公司企业  net网络服务机构  org非盈利组织  int国际组织  edu  gov  mil\r\n    - 反向域arpa:用于反向域名解析，即IP地址反向解析为域名\r\n  - 我国二级域名\r\n    - 类别域名：ac科研机构  com工商金融企业  edu教育机构  gov政府部门  net提供网络服务的机构  mil军事机构  org非盈利性组织\r\n    - 行政区域名：bj北京  sh上海  js江苏省\r\n\r\n- 域名解析的过程\r\n\r\n  - 递归查询\r\n\r\n  - 迭代查询\r\n\r\n    \r\n\r\n    ![image-20220722160421990](C:\\D\\PCR\\Notes\\Pictures\\image-20220722160421990.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 6.5 文件传送协议FTP\r\n\r\n- 是因特网上使用得最广泛的文件传送协议\r\n- 提供交互式访问，允许客户指明文件的类型与格式，并允许文件具有存取权限\r\n- 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件\r\n\r\n![image-20220722165850420](C:\\D\\PCR\\Notes\\Pictures\\image-20220722165850420.png)\r\n\r\n\r\n\r\n#### 6.6 电子邮件\r\n\r\n- 采用各户/服务器方式\r\n\r\n- 三个主要组成构件：用户代理、邮件服务器、电子邮件所需的协议\r\n\r\n  - 用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件\r\n  - 邮件服务器是电子邮件系统的基础设施。其功能是发送和接收邮件\r\n  - 协议包括邮件发送协议和读取协议\r\n\r\n- 简单邮件传送协议SMTP\r\n\r\n\r\n\r\n#### 6.7 万维网WWW\r\n\r\n- 万维网(World Wide Web)并非某种特殊的计算机网络，它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。\r\n\r\n- 利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。\r\n\r\n- 万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。\r\n\r\n- URL的一般格式由以下四部分组成\r\n\r\n  ==<协议>://<主机>:<端口>/<路径>==\r\n\r\n\r\n\r\n##### 超文本传输协议HTTP\r\n\r\n- 定义了浏览器怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。\r\n\r\n- HTTP1.0：\r\n\r\n  - 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接\r\n\r\n  HTTP1.1：\r\n\r\n  - 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用\r\n  - 在同一个TCP连接里面，客户端可以同时发送多个请求\r\n  - 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等待\r\n  - 新增了一些请求方法\r\n  - 新增了一些请求头和响应头\r\n\r\n- 使用Cookie在服务器上记录用户信息\r\n\r\n  - 早期HTTP是一种无状态的协议\r\n\r\n  - Cookie是一种对无状态的HTTP进行状态化的技术\r\n\r\n    ![image-20220722172611889](C:\\D\\PCR\\Notes\\Pictures\\image-20220722172611889.png)\r\n\r\n\r\n\r\n- 万维网缓存与代理服务器\r\n  - 万维网缓存又称为Web缓存，可位于客户机也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器。\r\n  - Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时若发现这个请求与暂时存放的请求相同，则返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源。\r\n\r\n\r\n\r\n\r\n\r\n",
        "timemini": ""
    },
    {
        "index": 26,
        "title": "计网笔记（一）",
        "essay": "## 1、OSI 7层模型\r\n\r\n1、物理层\r\n\r\n​\t\t主要定义物理传输设备标准，如网线、光纤的接口类型，各种传输介质的传输速率等。\r\n\r\n​\t\t主要作用是传输比特流。该层传输的数据为比特\r\n\r\n2、数据链路层\r\n\r\n​\t\t主要将从物理层接受到的数据进行MAC地质的封装与解封装。\r\n\r\n​\t\t该层的数据叫做帧，在这一层工作的设备是交换机，数据通过交换机来传输。\r\n\r\n3、网络层\r\n\r\n​\t\t将从下层中接收到的数据进行IP地质的封装与解封装\r\n\r\n​\t\t该层的数据叫报文\\数据包，工作的设备叫路由器\r\n\r\n4、传输层\r\n\r\n​\t\t传输层是向用户提供可靠的端到端服务，透明地传送报文。\r\n\r\n5、会话层\r\n\r\n​\t\t会话层的主要目的是组织同步的两个会话用户之间的对话，并管理数据的交换。\r\n\r\n6、表示层\r\n\r\n​\t\t表示层主要用于处理两个通信系统间信息交换的表示方式，它包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。\r\n\r\n7、应用层\r\n\r\n​\t\t应用层是OSI参考模型的最高层。应用层不仅要提供应用进程所需要信息交换和远程操作，而且还要作为应用进程的用户代理，完成一些为进行语义上有意义的信息交换所必须的功能。\r\n\r\n## 2、IP 协议原理\r\n\r\nIP协议是TCP/IP协议的动力，它为上层协议提供不可靠、无状态、无链接的服务\r\n\r\n**IP(Internet Protocol)协议的英文名直译就是：因特网协议，简称为“网协”，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。**\r\n\r\n无状态指的是通信双方传输数据状态的不同步，因此所有的IP数据包的发送、传输和接收都是相互独立的、没有上下文关系。这意味着它无法处理乱序和重复的IP数据包。但无状态的优点也很明显：简单、高效，我们无需为保持通信而分配一些内核资源，传输数据时也不用携带状态信息\r\n\r\n不可靠体现在IP协议不能保证数据准确发送到接收端。如果IP发送端检测到发送失败，它只会通知上层协议发送失败，而不会试图重传\r\n\r\nIPV4头部数据\r\n\r\n![IPV4头部数据](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard.png)\r\n\r\nIP分片：当IP数据包的长度超过帧的MTU时，他会被分片传输。分片的过程可能发生在发送端上，也可能发生在中转路由器上\r\n\r\n**IPV4和IPV6的区别**\r\n\r\n\r\n\r\n\r\n\r\n## 3、三次握手与四次挥手\r\n\r\nTCP是面向连接的协议。运输连接是用来传送TCP报文的。传输连接一共三个阶段：连接建立、数据传送、连接释放\r\n\r\n在TCP连接建立过程中要解决以下三个问题：\r\n\r\n- 要使每一方能够确知对方的存在\r\n- 要允许双方协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项以及服务质量等）\r\n- 能够对运输实体资源进行分配\r\n\r\n#### **TCP连接建立（三次握手）**\r\n\r\n\r\n在本例中，A主动打开连接，B被动打开连接\r\n\r\n- **A的TCP客户进程首先创建传输控制模块TCB。然后在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初试序号seq=x。TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP客户端进程进入SYN-SENT（同步已发送）状态。**\r\n\r\n- **B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN为和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初试序号seq=y。请注意，这个报文段也不能携带数据，但同样要消耗一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。**\r\n- **TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而不是自己的序号x+1。TCP标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。**\r\n\r\n这时，TCP的连接已经建立，也进入ESTABLISHED（已建立连接）状态。\r\n\r\nA第二次发给B的确认是为了防止已经失效的连接请求报文段突然又传送到了B，因而产生错误\r\n\r\n- 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。\r\n\r\n- 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。\r\n- 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效\r\n- 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。\r\n- 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接\r\n\r\n#### **TCP的连接释放（四次挥手）**\r\n\r\n在本例中，A主动发出连接释放请求\r\n\r\n- **A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1.这是A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，也要消耗掉一个序号。**\r\n\r\n- **B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号等于v，等于B前面已经传送过的数据的最后一个字节的序号加1.然后B就进入CLOSE-WAIT（关闭等待状态）。TCP服务器进程这时就应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A任要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。**\r\n- **A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）转态，等待B发出的连接释放报文段。**\r\n- **若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已经发送过的确认号ack=u+1.这时B就进入LAST-ACK（最后确认）状态，等待A的确认。**\r\n- **A在收到B的连接释放报文段后，必须对此发出确认。在报文段中把ACK置1，确认号ack=w+1,而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命。**\r\n\r\n**为什么A在TIME-WAIT状态必须等待2MSL的时间呢？**\r\n\r\n1. 为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN_ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就可以在2MSL的时间内收到这个重传的FIN+ACK报文段。\r\n\r\n2. 为了防止“已经失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。\r\n\r\n#### **Time_wait状态产生的原因**\r\n\r\nhttps://blog.csdn.net/dog250/article/details/13760985\r\n\r\n为实现TCP全双工连接的可靠释放\r\n\r\n为使旧的数据包在网络因过期而消失\r\n\r\n**Time-Wait状态过多的原因**\r\n\r\n**如果你的程序设计为服务器主动关闭，那么你才有可能需要关注这个TIMEWAIT状态过多的问题。**\r\n\r\n1. 在生产过程中，如果服务器使用短连接，那么完成一次请求后会主动断开连接，就会造成大量time_wait状态。因此我们常常在系统中会采用长连接，减少建立连接的消耗，同时也减少TIME_WAIT的产生，\r\n2. 但实际上即使使用长连接配置不当时，当TIME_WAIT的生产速度远大于其消耗速度时，系统仍然会累计大量的TIME_WAIT状态的连接。TIME_WAIT状态连接过多就会造成一些问题。如果客户端的TIME_WAIT连接过多，同时它还在不断产生，将会导致客户端端口耗尽，新的端口分配不出来，出现错误。如果服务器端的TIME_WAIT连接过多，可能会导致客户端的请求连接失败，这在接下来举例说明。\r\n\r\n**Time-Wait过多造成的影响**\r\n\r\n在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。\r\n我来解释下这个场景。主动正常关闭TCP连接，都会出现TIMEWAIT。\r\n\r\n为什么我们要关注这个高并发短连接呢？有两个方面需要注意：\r\n\r\n1. **高并发可以让服务器在短时间范围内同时占用大量端口**，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。\r\n2. 在这个场景中，**短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接**。\r\n\r\n这里有个相对长短的概念，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般**长连接对应的业务的并发量并不会很高**。\r\n\r\n综合这两个方面，持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。同时，这些端口都是服务器临时分配，无法用SO_REUSEADDR选项解决这个问题。\r\n\r\n\r\n\r\n**如何快速回收TCP中的time_wait状态**\r\n\r\n让服务器能够快速回收和重用那些TIME_WAIT的资源这个可以通过改变内核配置做到\r\n\r\nvi /etc/sysctl.conf 编辑文件，加入以下内容：    \r\n\r\n```yaml\r\nnet.ipv4.tcp_syncookies = 1      \r\n表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0\r\n\r\nnet.ipv4.tcp_tw_reuse = 1    \r\n表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\r\n\r\nnet.ipv4.tcp_tw_recycle = 1    \r\n表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\r\n\r\nnet.ipv4.tcp_fin_timeout = 30 \r\n修改系統默认的TIMEOUT时间\r\n```\r\n\r\n#### **Close-Wait什么时候过多**\r\n\r\nclose_wait 按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送fin包告知客户端关闭关闭连接，之后迁移到Last_ACK状态。但是close_wait过多只能说明没有迁移到Last_ACK，也就是服务端是否发送fin包，只有发送fin包才会发生迁移，所以问题定位在是否发送fin包。fin包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。\r\n\r\n**CLOSE-WAIT过多解决办法**\r\n\r\n基本的思想就是要检测出对方已经关闭的socket，然后关闭它。\r\n\r\n1. 代码需要判断socket，一旦read返回0，断开连接，read返回负，检查一下errno，如果不是AGAIN（表示现在没有数据稍后重新读取），也断开连接。\r\n2. 给每一个socket设置一个时间戳last_update，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个socket。\r\n3. 使用一个Heart-Beat线程，定期向socket发送指定格式的心跳数据包，如果接收到对方的RST报文，说明对方已经关闭了socket，那么我们也关闭这个socket。\r\n4. 设置SO_KEEPALIVE选项，并修改内核参数\r\n\r\n#### **三次握手有哪些缺陷**\r\n\r\n1、TCP三次握手可能会出现SYN Flood攻击\r\n\r\n利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。\r\n\r\n要明白这种攻击的基本原理，还是要从TCP连接建立的过程开始说起：\r\n\r\n1. 首先，请求端（客户端）发送一个包含SYN标志的TCP报文，SYN即同步（Synchronize），同步报文会指明客户端使用的端口以及TCP连接的初始序号。\r\n2. 第二部，服务器在收到客户端的SYN报文后，将返回一个SYN+ACK的报文，表示客户端的请求被接受，同时TCP序号被加一，ACK即确认（Acknowledgment）。\r\n3. 第三部，客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加一，到此一个TCP连接完成。\r\n\r\n以上的连接过程在TCP协议中称为三次握手。\r\n\r\n问题就出在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会不停地重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者发送大量伪造原IP地址的攻击报文。发送到服务端，服务器将为了维护一个非常大的半连接队列而消耗非常多的CPU时间和内存。服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常需求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击（SYN 洪水攻击）。\r\n\r\n2、TCP三次握手可能会出现Land攻击\r\n\r\nLAND攻击力用了TCP连接建立的三次握手过程，通过向一个目标主机发送一个用于建立请求连接的TCP SYN报文而实现对目标主机的攻击。与正常的TCP SYN报文不同的是：LAND攻击报文的源IP地址和目的IP地址是相同的，都是目标主机的IP地址。这样目标主机接在收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构，而该报文的源地址就是自己。由于目的IP地址和源IP地址是相同的，都是目标主机的IP地址，因此这个ACK报文就发给目标主机本身。这样如果攻击者发送了足够多的SYN报文，则目标计算机的TCB可能会耗尽，最终不能正常服务。\r\n\r\n3、可能会出现Connection Flood攻击\r\n\r\n原理是利用真实的IP地址向服务器发起大量资源的连接，并且建立连接之后很长时间不释放并定时发送垃圾数据包给服务器使连接得以长时间保持，占用服务器上的资源，造成服务器上残余连接（Wai-Time状态）过多，效率降低，甚至资源耗尽，无法响应其他客户所发起的连接\r\n\r\n**解决方法**\r\n\r\n1、限制每个源IP的连接数\r\n\r\n2、对恶意连接的IP进行封禁\r\n\r\n3、主动清楚残余连接\r\n\r\n**初始序列号的选择**\r\n\r\n初始序列号是通过ISN来实现的\r\n\r\nTCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。\r\n\r\nISN是一种随机生成初始序列号的算法\r\n\r\n**ISN = M + F(localhost, localport, remotehost, remoteport).**\r\n\r\n> **M**是一个计时器，这个计时器每隔4毫秒加1。\r\n>\r\n> **F**是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用**MD5**算法是一个比较好的选择。\r\n\r\n#### **TCP的状态**\r\n\r\n> **l CLOSED**：初始状态，表示TCP连接是“关闭着的”或“未打开的”。\r\n>\r\n> **l LISTEN** ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。\r\n>\r\n> **l SYN_RCVD** ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。\r\n>\r\n> **l SYN_SENT** ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。\r\n>\r\n> **l ESTABLISHED** ：表示TCP连接已经成功建立。\r\n>\r\n> **l FIN_WAIT_1** ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。\r\n>\r\n> **l FIN_WAIT_2** ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。\r\n>\r\n> **l TIME_WAIT** ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）\r\n>\r\n> l **CLOSING** ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。\r\n>\r\n> **l CLOSE_WAIT** ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。\r\n>\r\n> **l LAST_ACK** ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。\r\n\r\n## 4、HTTP与HTTPS\r\n\r\n**HTTP**:\r\n\r\n超文本传输协议，是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提高一种发布和接收HTML页面的方法。HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度来看，HTTP是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础\r\n\r\n#### HTTP原理:\r\n\r\n- 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。\r\n- 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。\r\n\r\n\r\n\r\n#### HTTP报文结构\r\n\r\n![请求报文](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/bVbvbwo)\r\n\r\n#### HTTP请求方法：\r\n\r\n![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)\r\n\r\n响应报文结构图\r\n\r\n![响应报文](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/bVbvbK9)\r\n\r\n#### 响应状态码：\r\n\r\n状态代码由服务器发出，以响应客户端对服务器的请求。\r\n\r\n- 1xx（信息）：收到请求，继续处理\r\n\r\n  | 100  | 服务器通知浏览器之前一切正常，请客户端继续请求 |\r\n  | ---- | ---------------------------------------------- |\r\n  | 101  | 针对请求头的Upgrade返回的信息。                |\r\n\r\n- 2xx（成功）：请求已成功接收，理解和接受\r\n\r\n  | 200  | 请求成功                                                     |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 201  | 常用于POST，PUT 请求，表明请求已经成功，并新建了一个资源     |\r\n  | 202  | 请求已经接收到，但没有响应，稍后也不会返回一个异步请求结果   |\r\n  | 203  | 表明响应返回的元信息（meta-infomation）和最初的服务器不同，而是从本地或者第三方获取的。 |\r\n  | 204  | 请求没有数据返回，但是头信息有用                             |\r\n  | 205  | 告诉用户代理（浏览器）重置发送该请求的文档。                 |\r\n  | 206  | 当客户端使用Range请求头时，返回该状态码。                    |\r\n\r\n- 3xx（重定向）：需要采取进一步措施才能完成请求\r\n\r\n  | 300  | 返回多个响应，需要浏览器或者用户选择                         |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 301  | 请求资源的URL被永久的改变，新的URL会在响应的Location中给出。 |\r\n  | 302  | 请求资源的URL被暂时修改到Location提供的URL。                 |\r\n  | 303  | 服务通过返回的响应数据指导客户端通过GET方法去另一个URL获取资源。 |\r\n  | 304  | 资源未变更。服务器根据请求头判断，需要资源未修改，只返回响应头； |\r\n\r\n- 4xx（客户端错误）：请求包含错误的语法或无法满足\r\n\r\n  | 400  | 请求语法有问题，服务器无法识别。 |\r\n  | ---- | -------------------------------- |\r\n  | 401  | 客户端未授权该请求。             |\r\n  | 403  | 服务器拒绝响应。权限不足。       |\r\n  | 404  | URL无效或者URL有效但是没有资源。 |\r\n  | 405  | 请求方式Method不允许。           |\r\n\r\n- 5xx（服务器错误）：服务器无法满足明显有效的请求\r\n\r\n  | 500  | 服务器内部错误，未捕获。                                     |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 502  | 服务器作为网关使用时，收到上游服务器返回的无效响应。         |\r\n  | 503  | 无法服务。一般发生在因维护而停机或者服务过载。               |\r\n  | 504  | 网关超时。服务器作为网关或者代理，不能及时从上游服务器获取响应返回给客户端。 |\r\n  | 505  | 发出的请求http版本服务器不支持。如果请求通过http2发送，服务器不支持http2.0，就会返回该状态码。 |\r\n\r\n\r\n#### Header：请求头\r\n\r\n| Header              | 解释                                                         | 示例                                                         |\r\n| :------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| Accept              | 指定客户端能够接收的内容类型                                 | Accept: text/plain, text/html,application/json               |\r\n| Accept-Charset      | 浏览器可以接受的字符编码集。                                 | Accept-Charset: iso-8859-5                                   |\r\n| Accept-Encoding     | 指定浏览器可以支持的web服务器返回内容压缩编码类型。          | Accept-Encoding: compress, gzip                              |\r\n| Accept-Language     | 浏览器可接受的语言                                           | Accept-Language: en,zh                                       |\r\n| Accept-Ranges       | 可以请求网页实体的一个或者多个子范围字段                     | Accept-Ranges: bytes                                         |\r\n| Authorization       | HTTP授权的授权证书                                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |\r\n| Cache-Control       | 指定请求和响应遵循的缓存机制                                 | Cache-Control: no-cache                                      |\r\n| Connection          | 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）           | Connection: close                                            |\r\n| Cookie              | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 | Cookie: $Version=1; Skin=new;                                |\r\n| Content-Length      | 请求的内容长度                                               | Content-Length: 348                                          |\r\n| Content-Type        | 请求的与实体对应的MIME信息                                   | Content-Type: application/x-www-form-urlencoded              |\r\n| Date                | 请求发送的日期和时间                                         | Date: Tue, 15 Nov 2010 08:12:31 GMT                          |\r\n| Expect              | 请求的特定的服务器行为                                       | Expect: 100-continue                                         |\r\n| From                | 发出请求的用户的Email                                        | From: user@email.com                                         |\r\n| Host                | 指定请求的服务器的域名和端口号                               | Host: www.zcmhi.com                                          |\r\n| If-Match            | 只有请求内容与实体相匹配才有效                               | If-Match: “737060cd8c284d8af7ad3082f209582d”                 |\r\n| If-Modified-Since   | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT             |\r\n| If-None-Match       | 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 | If-None-Match: “737060cd8c284d8af7ad3082f209582d”            |\r\n| If-Range            | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: “737060cd8c284d8af7ad3082f209582d”                 |\r\n| If-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功                     | If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT           |\r\n| Max-Forwards        | 限制信息通过代理和网关传送的时间                             | Max-Forwards: 10                                             |\r\n| Pragma              | 用来包含实现特定的指令                                       | Pragma: no-cache                                             |\r\n| Proxy-Authorization | 连接到代理的授权证书                                         | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==      |\r\n| Range               | 只请求实体的一部分，指定范围                                 | Range: bytes=500-999                                         |\r\n| Referer             | 先前网页的地址，当前请求网页紧随其后,即来路                  | Referer: [http://www.zcmhi.com/archives...](http://www.zcmhi.com/archives/71.html) |\r\n| TE                  | 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息     | TE: trailers,deflate;q=0.5                                   |\r\n| Upgrade             | 向服务器指定某种传输协议以便服务器进行转换（如果支持）       | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               |\r\n| User-Agent          | User-Agent的内容包含发出请求的用户信息                       | User-Agent: Mozilla/5.0 (Linux; X11)                         |\r\n| Via                 | 通知中间网关或代理服务器地址，通信协议                       | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)                  |\r\n| Warning             | 关于消息实体的警告信息                                       | Warn: 199 Miscellaneous warning                              |\r\n\r\n#### Body：请求体\r\n\r\n根据应用场景的不同，HTTP请求的请求体有三种不同的形式。\r\n\r\n**任意类型**\r\n\r\n移动开发者常见的，请求体是任意类型，服务器不会解析请求体，请求体的处理需要自己解析，如 POST JSON时候就是这类。\r\n![Body](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180329110240368)\r\n\r\n**application/json**\r\n\r\napplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。\r\n\r\nJSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。\r\n\r\nGoogle 的 [AngularJS](http://angularjs.org/) 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：\r\n\r\n```json\r\nJSvar data = {'title':'test', 'sub' : [1,2,3]};\r\n$http.post(url, data).success(function(result) {\r\n    ...\r\n});\r\n```\r\n\r\n最终发送的请求是：\r\n\r\n```json\r\nBASHPOST http://www.example.com HTTP/1.1 \r\nContent-Type: application/json;charset=utf-8\r\n{\"title\":\"test\",\"sub\":[1,2,3]}\r\n```\r\n\r\n这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 `php://input` 里获得原始输入流，再 `json_decode` 成对象。一些 php 框架已经开始这么做了。\r\n\r\n当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考[这篇文章](http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/)。\r\n\r\n**text/xml**\r\n\r\n我的博客之前[提到过 XML-RPC](http://www.imququ.com/post/64.html)（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：\r\n\r\n```xml\r\nHTMLPOST http://www.example.com HTTP/1.1 \r\nContent-Type: text/xml\r\n<?xml version=\"1.0\"?>\r\n<methodCall>\r\n    <methodName>examples.getStateName</methodName>\r\n    <params>\r\n        <param>\r\n            <value><i4>41</i4></value>\r\n        </param>\r\n    </params>\r\n</methodCall>\r\n```\r\n\r\nXML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 [XML-RPC Api](http://codex.wordpress.org/XML-RPC_WordPress_API)，搜索引擎的 [ping 服务](http://help.baidu.com/question?prod_en=master&class=476&id=1000423)等等。JavaScript 中，也有[现成的库](http://plugins.jquery.com/xmlrpc/)支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。\r\n\r\n**Query String:application/x-www-form-urlencoded**\r\n\r\n这算是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：\r\n\r\n```json\r\nPOST [http://www.example.com](http://www.example.com/) HTTP/1.1\r\nContent-Type: application/x-www-form-urlencoded; charset=utf-8\r\ntitle = test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3\r\n```\r\n\r\n首先，Content-Type 被指定为 application/x-www-form-urlencoded；这里的格式要求就是URL中Query String的格式要求：多个键值对之间用&连接，键与值之前用=连接，且只能用ASCII字符，非ASCII字符需使用UrlEncode编码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST['title'] 可以获取到 title 的值，$_POST['sub'] 可以得到 sub 数组。\r\n![http请求格式](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180329110305244)\r\n\r\n**文件分割**\r\n\r\n第三种请求体的请求体被分成为多个部分，文件上传时会被使用，这种格式最先应该是被用于邮件传输中，每个字段/文件都被boundary（Content-Type中指定）分成单独的段，每段以-- 加 boundary开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标制为boundary后面加--，结构见下图：\r\n![**文件分割**](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180329110318499)\r\n区分是否被当成文件的关键是Content-Disposition是否包含filename，因为文件有不同的类型，所以还要使用Content-Type指示文件的类型，如果不知道是什么类型取值可以为application/octet-stream表示该文件是个二进制文件，如果不是文件则Content-Type可以省略。\r\n我们使用表单上传文件时，必须让 <form> 表单的 `enctyped` 等于 multipart/form-data。直接来看一个请求示例：\r\n\r\n```json\r\nBASHPOST http://www.example.com HTTP/1.1\r\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\r\n\r\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\r\nContent-Disposition: form-data; name=\"text\"\r\n\r\ntitle\r\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\r\nContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"\r\nContent-Type: image/png\r\n\r\nPNG ... content of chrome.png ...\r\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\r\n```\r\n\r\n这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 `--boundary` 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 `--boundary--` 标示结束。关于 multipart/form-data 的详细定义，请前往 [rfc1867](http://www.ietf.org/rfc/rfc1867.txt) 查看。\r\n\r\n这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。\r\n\r\n上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也[只支持这两种方式](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4)（通过 <form> 元素的`enctype` 属性指定，默认为 `application/x-www-form-urlencoded`。其实 `enctype` 还支持 `text/plain`，不过用得非常少）。\r\n\r\n随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。\r\n\r\n**Encoding:编码**\r\n\r\n网页中的表单使用POST方法提交时，数据内容的类型是 application/x-www-form-urlencoded，这种类型会：\r\n\r\n　　1.字符\"a\"-\"z\"，\"A\"-\"Z\"，\"0\"-\"9\"，\".\"，\"-\"，\"*\"，和\"_\" 都不会被编码;\r\n\r\n　　2.将空格转换为加号 (+)\r\n\r\n　　3.将非文本内容转换成\"%xy\"的形式,xy是两位16进制的数值;\r\n\r\n　　4.在每个 name=value 对之间放置 & 符号。\r\n\r\nweb设计者面临的众多难题之一便是怎样处理不同操作系统间的差异性。这些差异性能引起URL方面的问题：例如，一些操作系统允许文件名中含有空格符，有些又不允许。大多数操作系统不会认为文件名中含有符号“#”会有什么特殊含义;但是在一个URL中，符号“#”表示该文件名已经结束，后面会紧跟一个fragment(部分)标识符。其他的特殊字符，非字母数字字符集，它们在URL或另一个操作系统上都有其特殊的含义，表述着相似的问题。为了解决这些问题，我们在URL中使用的字符就必须是一个ASCII字符集的固定字集中的元素，具体如下：\r\n\r\n　　1.大写字母A-Z\r\n\r\n　　2.小写字母a-z\r\n\r\n　　3.数字 0-9\r\n\r\n　　4.标点符 - _ . ! ~ * ' (和 ,)\r\n\r\n诸如字符: / & ? @ # $ + = 和 %也可以被使用，但是它们各有其特殊的用途，如果一个文件名包括了这些字符( / & ? @ # $ + = %)，这些字符和所有其他字符就应该被编码。\r\n\r\n编码过程非常简单，任何字符只要不是ASCII码数字，字母，或者前面提到的标点符，它们都将被转换成字节形式，每个字节都写成这种形式：一个“%”后面跟着两位16进制的数值。空格是一个特殊情况，因为它们太平常了。它除了被编码成“%20”以外，还能编码为一个“+”。加号(+)本身被编码为%2B。当/ # = & 和?作为名字的一部分来使用时，而不是作为URL部分之间的分隔符来使用时，它们都应该被编码。\r\n\r\nWARNING这种策略在存在大量字符集的异构环境中效果不甚理想。例如：在U.S. Windows 系统中, é 被编码为 %E9. 在 U.S. Mac中被编码为%8E。这种不确定性的存在是现存的URI的一个明显的不足。所以在将来URI的规范当中应该通过国际资源标识符(IRIs)进行改善。\r\n\r\n类URL并不自动执行编码或解码工作。你能生成一个URL对象，它可以包括非法的ASCII和非ASCII字符和/或%xx。当用方法getPath() 和toExternalForm( ) 作为输出方法时，这种字符和转移符不会自动编码或解码。你应对被用来生成一个URL对象的字符串对象负责，确保所有字符都会被恰当地编码。\r\n\r\n\r\n\r\n#### HTTPS:\r\n\r\n是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL/TSL（Secure Sockets Layer，即安全套接层协议、Transport Layer Security，即安全传输层协议）。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。\r\n\r\nTLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。\r\n\r\n#### HTTP与WebSocket\r\n\r\n- WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是全双工通信。\r\n- TTP 有 1.1 和 1.0 之说，也就是所谓的 keep-alive，把多个 HTTP 请求合并为一个，但是 Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器，所以**在握手阶段使用了HTTP**\r\n\r\n![HTTP与WebSocket](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/006qX6GLgy1g8dyiz3npej30n90j6tbw.jpg)\r\n\r\n#### HTTPS设计目标：\r\n\r\n- 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了么。\r\n- 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。\r\n- 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。\r\n\r\n#### 为什么说HTTP是无状态的\r\n\r\n无状态含义：\r\n\r\n无状态是指协议对于事务处理没有记忆功能。缺少状态意味着，假如后面的处理需要前面的信息，则前面的信息必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要前面信息时，应答就较快。直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。\r\n\r\n**无状态协议：**\r\n\r\n- 协议的状态是指下一次传输可以“记住”这次传输信息的能力。\r\n- http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。\r\n- 比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。\r\n- 由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。\r\n\r\n**如何解决HTTP无状态这个问题？**\r\n\r\nCookie和Session\r\n\r\n#### HTTPS原理：\r\n\r\nhttps://www.jianshu.com/p/14cd2c9d2cd2\r\n\r\n- 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；\r\n\r\n- 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；\r\n- 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；\r\n- 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法）；\r\n- 客户端将所有握手消息的 MAC 值发送给服务器；\r\n- 服务器将所有握手消息的 MAC 值发送给客户端。\r\n\r\n**核心**：HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，**总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输**。\r\n\r\n**HTTPS请求的过程**\r\n\r\n一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。\r\n\r\n1.客户端向服务器发起HTTPS请求，连接到服务器的443端口\r\n\r\n2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。\r\n\r\n3.服务器将自己的公钥和证书发送给客户端。\r\n\r\n4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。\r\n\r\n5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。\r\n\r\n6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。\r\n\r\n7.然后服务器将加密后的密文发送给客户端。\r\n\r\n8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。\r\n\r\n![HTTPS请求的过程](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/image-20200701110030250.png)\r\n\r\n#### 验证证书过程\r\n\r\n客户端接收到证书以后，就要开始进行验证工作了。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书。上面我们也看到，世界上权威CA机构的根证书都是预先嵌入到浏览器中的，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假，比如以前打开12360网站就会提示，现在不会了\r\n\r\n如果我们找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的，因为hash值具有唯一性，不同内容通过hash计算得到的值是不可能相同的\r\n\r\n有人说假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）\r\n\r\n在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的\r\n\r\n但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的\r\n\r\n到这里我们认证了三点信息：\r\n\r\n1. 证书是否为受信任的权威机构颁发的\r\n\r\n2. 证书是否被篡改\r\n\r\n3. 证书是否为服务器发过来的，而不是第三方发的\r\n\r\n#### HTTP与HTTPS的区别\r\n\r\n- https协议需要到CA （Certificate Authority，\t证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)\r\n\r\n- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\r\n- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\r\n- http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)\r\n\r\n#### HTTPS相对于HTTP的改进\r\n\r\n1. 双向的身份认证\r\n\r\n\r\n2. 1. 客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：\r\n    2. 客户端发起 SSL 握手消息给服务端要求连接。\r\n    3. 服务端将证书发送给客户端。\r\n    4. 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。\r\n    5. 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。\r\n\r\n3. 数据传输的机密性\r\n\r\n4. 1. 客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。\r\n\r\n5. 防止重放攻击\r\n\r\n6. 1. SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。\r\n    2. 可以看到，鉴于电子商务等安全上的需求，Https对比Http协议，在安全方面已经取得了极大的增强。总结来说，Https的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。\r\n\r\n#### HTTPS的优点\r\n\r\n1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。\r\n\r\n2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。\r\n\r\n3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\r\n\r\n#### HTTPS的缺点（对比优点）\r\n\r\n1、Https协议握手阶段比较费时，会使页面的加载时间延长。\r\n\r\n2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。\r\n\r\n3、Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。\r\n\r\n4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。\r\n\r\n5、成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。\r\n\r\n6、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。\r\n\r\n#### HTTPs为什么要用对称加密+非对称加密，相对于只使用非对称加密有什么好处\r\n\r\n因为非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘钥必须使用非对称加密算法。\r\n\r\n**密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。\r\n\r\n**对称加密**: 加密和解密的密钥使用的是同一个.\r\n\r\n**非对称加密**: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。\r\n\r\n**对称加密算法**: 密钥较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，且对计算机性能要求也没有那么高.\r\n\r\n优点: 算法公开、计算量小、加密速度快、加密效率高\r\n\r\n缺点:在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。\r\n\r\n常见的对称加密算法有: DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES \r\n\r\n**非对称加密算法**: 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\r\n\r\n非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。\r\n\r\n优点: 安全\r\n\r\n缺点:速度较慢\r\n\r\n常见的非对称加密算法有: RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）\r\n\r\n#### HTTP提交表单的方法有哪些\r\n\r\n\r\n\r\n#### HTTP 1.0、HTTP1.1 和 HTTP 2.0的区别\r\n\r\n##### HTTP1.0\r\n\r\nHTTP 协议老的标准是HTTP/1.0，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。\r\n\r\n同时，带宽和延迟也是影响一个网络请求的重要因素。在网络基础建设已经使得带宽得到极大的提升的当下，大部分时候都是延迟在于响应速度。基于此会发现，http1.0被抱怨最多的就是**连接无法复用**，和**head of line blocking**这两个问题。理解这两个问题有一个十分重要的前提：客户端是依据域名来向服务器建立连接，一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个。显然连接数并不是越多越好，资源开销和整体延迟都会随之增大。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。\r\n\r\nhead of line blocking(holb)会导致健康的请求会被不健康的请求影响，而且这种体验的损耗受网络环境影响，出现随机且难以监控。为了解决holb带来的延迟，协议设计者设计了一种新的pipelining机制。pipelining只能适用于http1.1,而且由于使用苛刻，很多浏览器厂商并不支持。\r\n\r\n##### HTTP1.1\r\n\r\n为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。\r\n\r\n在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。\r\n\r\n在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。\r\n\r\nHTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。HTTP 1.1通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。\r\n\r\n如，HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP/1.0不支持文件断点续传，<code>RANGE:bytes</code>是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。<code>RANGE:bytes=XXXX</code>表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！\r\n\r\n##### HTTP 1.1与HTTP 1.0 的区别\r\n\r\n1. 缓存处理\r\n\r\n   在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\r\n\r\n2. 带宽优化及网络连接的使用\r\n\r\n   HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\r\n\r\n3. 错误通知的管理\r\n\r\n   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\r\n\r\n4. 消息在网络中的发送\r\n\r\n5. 互联网地址的维护\r\n\r\n6. 安全性及完整性\r\n\r\n7. 长连接\r\n\r\n   HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\r\n\r\n##### HTTP2.0\r\n\r\n使用[HTTP2.o测试](https://http2.akamai.com/demo)便可看出HTTP2.0比之前的协议在性能上有很大的提升。下面总结了HTTP2.0协议的几个特性。\r\n\r\n**多路复用 (Multiplexing)**\r\n\r\n多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。\r\n\r\n**二进制分帧**\r\n\r\nHTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。\r\n\r\nHTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。\r\n\r\n这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。\r\n\r\n**首部压缩（Header Compression）**\r\n\r\nHTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。\r\n\r\n**服务端推送（Server Push）**\r\n\r\n服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。\r\n\r\n##### HTTP2.0与1.1的区别\r\n\r\n（1）.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。\r\n\r\n二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示\r\n\r\n（2）.HTTP2支持多路复用\r\n\r\n因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求\r\n\r\n（3）.HTTP2头部压缩\r\n\r\nHTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值\r\n\r\n（4）.HTTP2支持服务器推送\r\n\r\nHTTP2支持在未经客户端许可的情况下，主动向客户端推送内容",
        "timemini": ""
    },
    {
        "index": 27,
        "title": "计网笔记（三）",
        "essay": "## 11、Cookie与Session\r\n\r\ncookie、session 都是用来保存用户状态信息的一种方法或手段\r\n\r\n主要区别是：\r\n\r\n​    1.保存位置：cookie保存在客户端，session 保存在服务端\r\n\r\n​    2.安 全 性：cookie 安全性差，session 安全性高\r\n\r\n​    3.生命周期：在不设置条件的情况下两者都是在浏览器关闭后消失\r\n\r\n​    （可在客户端设置cookie的存活时间，也可在服务端设置session的存活时间）\r\n\r\n**Cookie是什么？**\r\n\r\nCookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie就可以做到。每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。\r\n\r\n**Session是什么？**\r\n\r\nSession是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。\r\n\r\n由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下\r\n\r\n- 首先，客户端会发送一个http请求到服务器端。\r\n- 服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionID，sessionID会被存储在cookie中。\r\n\r\n- 在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie\r\n- 服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209416247.png)\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/v2-369c25ea411974a1cd4d6ed69d533bcb_720w.jpg)\r\n\r\n实际上Cookie与Session都是会话的一种方式。它们的典型使用场景比如“购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建Cookie/Session来获取这些信息。\r\n\r\n如果你的站点是多节点部署，使用Nginx做负载均衡，那么有可能会出现Session丢失的情况（比如，忽然就处于未登录状态）。这时可以使用IP负载均衡（IP绑定ip_hash，每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决Session的问题），或者将Session信息存储在集群中。在大型的网站中，一般会有专门的Session服务器集群，用来保存用户会话，这时可以使用缓存服务比如Memcached或者Redis之类的来存放Session。\r\n\r\n**注意**\r\n\r\n- cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中\r\n- 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用\r\n- 用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。\r\n- 如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大\r\n\r\n目前大多数的应用都是用Cookie 实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中反馈到客户端，需要在 Cookie 中记录一个Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。\r\n\r\n客户端和服务端之间的通信交流，可以这样简单理解：\r\n\r\n比如当你在个推技术分享沙龙上觉得某位讲师讲得很好，在会后问了他几个问题，他对你这些问题进行了回答，这就是一个会话。但这个讲师太受欢迎，于是工作人员收集问题，并给每个提问者一个号码牌，讲师按照号码牌依次给出相应解答并告诉相应的人。这就是Session。一段时间后，当你再次遇见这位讲师，他发现你身上有上次回复你的答案，知晓你是那个好学的程序猿。于是你欣喜若狂，哇塞，讲师居然认出我了，这就是Cookie，你的小甜点。客户端好比听课的技术爱好者，服务端就是这位讲师。\r\n\r\nCookie还可以在一些方便用户的场景下使用。比如你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以被写到Cookie里面，当访问网站时，网站页面的脚本可以读取这个信息，自动填写用户名，方便用户使用，给用户一点甜头。\r\n\r\n**总结**：\r\n\r\n1、Cookie 在客户端（浏览器），Session 在服务器端。\r\n\r\n2、Cookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。\r\n\r\n3、单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。\r\n\r\n4、Session 可以放在 文件、数据库或内存中，比如在使用Node时将Session保存在redis中。由于一定时间内它是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用Cookie。\r\n\r\n5、Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）。\r\n\r\n6、用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即Session ID。\r\n\r\n**Cookie和Session如何选择**\r\n\r\n\r\n\r\n\r\n\r\n## 12、常见的服务端认证机制\r\n\r\n\r\n\r\n## 13、Http状态码\r\n\r\n200 – 请求成功\r\n\r\n301 – 资源(网页等)被永久转移到其它URL\r\n\r\n404 – 请求的资源(网页等)不存在\r\n\r\n500 – 内部服务器错误\r\n\r\n分类分类描述\r\n\r\n- 1**信息，服务器收到请求，需要请求者继续执行操作\r\n- 2**成功，操作被成功接收并处理\r\n- 3**重定向，需要进一步的操作以完成请求\r\n- 4**客户端错误，请求包含语法错误或无法完成请求\r\n- 5**服务器错误，服务器在处理请求的过程中发生了错误\r\n\r\n状态代码由服务器发出，以响应客户端对服务器的请求。\r\n\r\n- 1xx（信息）：收到请求，继续处理\r\n\r\n  | 100  | 服务器通知浏览器之前一切正常，请客户端继续请求 |\r\n  | ---- | ---------------------------------------------- |\r\n  | 101  | 针对请求头的Upgrade返回的信息。                |\r\n\r\n- 2xx（成功）：请求已成功接收，理解和接受\r\n\r\n  | 200  | 请求成功                                                     |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 201  | 常用于POST，PUT 请求，表明请求已经成功，并新建了一个资源     |\r\n  | 202  | 请求已经接收到，但没有响应，稍后也不会返回一个异步请求结果   |\r\n  | 203  | 表明响应返回的元信息（meta-infomation）和最初的服务器不同，而是从本地或者第三方获取的。 |\r\n  | 204  | 请求没有数据返回，但是头信息有用                             |\r\n  | 205  | 告诉用户代理（浏览器）重置发送该请求的文档。                 |\r\n  | 206  | 当客户端使用Range请求头时，返回该状态码。                    |\r\n\r\n- 3xx（重定向）：需要采取进一步措施才能完成请求\r\n\r\n  | 300  | 返回多个响应，需要浏览器或者用户选择                         |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 301  | 请求资源的URL被永久的改变，新的URL会在响应的Location中给出。 |\r\n  | 302  | 请求资源的URL被暂时修改到Location提供的URL。                 |\r\n  | 303  | 服务通过返回的响应数据指导客户端通过GET方法去另一个URL获取资源。 |\r\n  | 304  | 资源未变更。服务器根据请求头判断，需要资源未修改，只返回响应头； |\r\n\r\n- 4xx（客户端错误）：请求包含错误的语法或无法满足\r\n\r\n  | 400  | 请求语法有问题，服务器无法识别。 |\r\n  | ---- | -------------------------------- |\r\n  | 401  | 客户端未授权该请求。             |\r\n  | 403  | 服务器拒绝响应。权限不足。       |\r\n  | 404  | URL无效或者URL有效但是没有资源。 |\r\n  | 405  | 请求方式Method不允许。           |\r\n\r\n- 5xx（服务器错误）：服务器无法满足明显有效的请求\r\n\r\n  | 500  | 服务器内部错误，未捕获。                                     |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 502  | 服务器作为网关使用时，收到上游服务器返回的无效响应。         |\r\n  | 503  | 无法服务。一般发生在因维护而停机或者服务过载。               |\r\n  | 504  | 网关超时。服务器作为网关或者代理，不能及时从上游服务器获取响应返回给客户端。 |\r\n  | 505  | 发出的请求http版本服务器不支持。如果请求通过http2发送，服务器不支持http2.0，就会返回该状态码。 |\r\n\r\n## 14、ping用的是什么协议\r\n\r\n使用的是ICMP协议（Internet Control Message Protocal）的缩写，是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息\r\n\r\n**ICMP详解**\r\n\r\n**ICMP协议是一个网络层协议。**\r\n\r\n用来测试网络层是不是有故障，若有故障，该协议还能报告故障\r\n\r\n一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。\r\n\r\n所以我们就需要一种协议来完成这样的功能–ICMP协议。\r\n\r\n**ICMP协议的功能**\r\n\r\n1. 确认IP包是否成功到达目标地址\r\n\r\n2. 通知在发送过程中IP包被丢弃的原因\r\n\r\n![ICMP协议](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209428199.png)\r\n\r\n我们需要注意几点：\r\n\r\n1. ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议\r\n\r\n2. ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6\r\n\r\n**常见的ICMP报文**\r\n\r\n**响应请求**\r\n\r\n我们用的ping操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。\r\n\r\n过程：\r\n\r\n一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。\r\n\r\n**目标不可达，源抑制和超时报文**\r\n\r\n这三种报文的格式是一样的。\r\n\r\n（1）目标不可到达报文（类型值为3）在路由器或者主机不能传递数据时使用。\r\n\r\n例如：我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回类型字段值3、代码字段值为3的ICMP报文。\r\n\r\n常见的不可到达类型还有网络不可到达（代码字段值为0）、主机不可达到（代码字段值为1）、协议不可到达（代码字段值为2）等等。\r\n\r\n（2）源抑制报文（类型字段值为4，代码字段值为0）则充当一个控制流量的角色，通知主机减少数据报流量。由于ICMP没有回复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。\r\n\r\n（3）无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定的时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。\r\n\r\n超时报文（类型字段值为11）的代码域有两种取值：代码字段值为0表示传输超时，代码字段值为1表示分段重组超时。\r\n\r\n**时间戳请求**\r\n\r\n时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。\r\n\r\n传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。\r\n\r\n(有些系统不响应这种报文)\r\n\r\n## 15、ARP协议\r\n\r\n**1. ARP出现原因**\r\n\r\nARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而**将已知IP地址转换为MAC地址**的工作是由ARP协议来完成的。\r\n\r\n在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。\r\n\r\n**2. ARP映射方式**\r\n\r\n2.1. 静态映射\r\n\r\n静态映射的意思是要手动创建一张ARP表，把逻辑（IP）地址和物理地址关联起来。这个ARP表储存在网络中的每一台机器上。例如，知道其机器的IP地址但不知道其物理地址的机器就可以通过查ARP表找出对应的物理地址。这样做有一定的局限性，因为物理地址可能发生变化：\r\n\r\n（1）机器可能更换NIC（网络适配器），结果变成一个新的物理地址。\r\n\r\n（2）在某些局域网中，每当计算机加电时，他的物理地址都要改变一次。\r\n\r\n（3）移动电脑可以从一个物理网络转移到另一个物理网络，这样会时物理地址改变。\r\n\r\n要避免这些问题出现，必须定期维护更新ARP表，此类比较麻烦而且会影响网络性能。 \t\r\n\r\n2.2. 动态映射\r\n\r\n动态映射时，每次只要机器知道另一台机器的逻辑（IP）地址，就可以使用协议找出相对应的物理地址。已经设计出的实现了动态映射协议的有ARP和RARP两种。ARP把逻辑（IP）地址映射为物理地址。RARP把物理地址映射为逻辑（IP）地址。\r\n\r\n**3. ARP原理及流程**\r\n\r\n在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。\r\n\r\n**3.1.ARP请求**\r\n\r\n任何时候，当主机需要找出这个网络中的另一个主机的物理地址时，它就可以发送一个ARP请求报文，这个报文包好了发送方的MAC地址和IP地址以及接收方的IP地址。因为发送方不知道接收方的物理地址，所以这个查询分组会在网络层中进行广播。（见图1）\r\n\r\n![ARP](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209434312.png)\r\n\r\n**3.2.ARP响应**\r\n\r\n局域网中的每一台主机都会接受并处理这个ARP请求报文，然后进行验证，查看接收方的IP地址是不是自己的地址，只有验证成功的主机才会返回一个ARP响应报文，这个响应报文包含接收方的IP地址和物理地址。这个报文利用收到的ARP请求报文中的请求方物理地址以单播的方式直接发送给ARP请求报文的请求方。（见图2）\r\n\r\n![ARP响应](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209441293.png)\r\n\r\n## 16、ICMP协议\r\n\r\n为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用ICMP（Internet Control Message）因特网控制报文协议。\r\n\r\n它是ipv4协议族中的一个子协议，用于IP主机、路由器之间很惨地控制消息。控制消息在网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息对染不传输用户数据，但是对于用户数据的传递起着重要的作用。\r\n\r\nICMP与ARP不同。ICMP靠IP协议来完成任务，所以ICMP报文中要封装IP头部。他与传输层协议（例如TCP与UDP）的目的不同，一般不用来在端系统之间传送数据，不被用户网络程序直接使用。\r\n\r\n![ICMP](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209446515.png)\r\n\r\nICMP报文的种类有两种：ICP差错报告报文和ICMP询问报文\r\n\r\n差错报文有4种：终点不可达、时间超过、参数问题、改变路由（重定向）\r\n\r\n询问报文有2种：回送请求和回答、时间戳请求和回答\r\n\r\n## 17、计算机网络各层都包含哪些协议\r\n\r\n| 五层模型概念 |     对应网络协议      |\r\n| :----------: | :-------------------: |\r\n|    应用层    | HTTP、HTTPS、FTP、DNS |\r\n|    传输层    |       TCP、UDP        |\r\n|    网络层    |  IP、ICMP、ARP、RARP  |\r\n|  数据链路层  |                       |\r\n|    物理层    |                       |\r\n\r\n\r\n\r\n## 18、keep-alive参数\r\n\r\nHTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。\r\n\r\nTCP的KeepAlive机制意图在于保活、心跳，检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。\r\n\r\n\r\n\r\n## 19、servlet中请求转发与请求重定向的区别    \r\n\r\n**请求转发：**\r\n\r\n请求转发，即request.getRequestDispatcher().forward()，是一种服务器的行为，客户端只有一次请求，服务器端转发后会将请求对象保存，地址栏中的URL地址不会改变，得到响应后服务器端再将响应发给客户端；\r\n\r\n**请求重定向：**\r\n\r\n请求重定向，即response.sendRedirect()，是一种客户端行文，从本质上讲等同于两次请求，前一次请求对象不会保存，地址栏的URL地址会改变。\r\n\r\n\r\n\r\n## 20、Socket编程\r\n\r\n**网络编程中两个主要的问题**\r\n\r\n一个是如何准确的定位网络上一台或多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。\r\n\r\n在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。而TCP层则提供面向应用的可靠（tcp）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。\r\n\r\n目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。\r\n\r\n**基于Socket的java网络编程**\r\n\r\n**1，什么是Socket**\r\n\r\n　　网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。\r\n\r\n**2，Socket通讯的过程**\r\n\r\nServer端Listen(监听)某个端口是否有连接请求，Client端向Server 端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息。一个连接就建立起来了。Server端和Client 端都可以通过Send，Write等方法与对方通信。\r\n\r\n对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：\r\n\r\n（1）创建Socket；\r\n\r\n（2）打开连接到Socket的输入/出流；\r\n\r\n（3）按照一定的协议对Socket进行读/写操作；\r\n\r\n（4）关闭Socket.（在实际应用中，并未使用到显示的close，虽然很多文章都推荐如此，不过在我的程序中，可能因为程序本身比较简单，要求不高，所以并未造成什么影响。）\r\n\r\n**3，创建Socket**\r\n\r\n创建Socket\r\n\r\njava在包java.net中提供了两个类Socket和ServerSocket，分别用来表示双向连接的客户端和服务端。这是两个封装得非常好的类，使用很方便。其构造方法如下：\r\n\r\n```Java\r\nSocket(InetAddress address, int port);\r\n\r\nSocket(InetAddress address, int port, boolean stream);\r\n\r\nSocket(String host, int prot);\r\n\r\nSocket(String host, int prot, boolean stream);\r\n\r\nSocket(SocketImpl impl)\r\n\r\nSocket(String host, int port, InetAddress localAddr, int localPort)\r\n\r\nSocket(InetAddress address, int port, InetAddress localAddr, int localPort)\r\n\r\nServerSocket(int port);\r\n\r\nServerSocket(int port, int backlog);\r\n\r\nServerSocket(int port, int backlog, InetAddress bindAddr)\r\n```\r\n\r\n其中address、host和port分别是双向连接中另一方的IP地址、主机名和端口号，stream指明socket是流socket还是数据报socket，localPort表示本地主机的端口号，localAddr和 bindAddr是本地机器的地址（ServerSocket的主机地址），impl是socket的父类，既可以用来创建serverSocket又可以用来创建Socket。count则表示服务端所能支持的最大连接数。\r\n\r\n```Java\r\nSocket client = new Socket(\"127.0.01.\", 80);\r\n\r\nServerSocket server = new ServerSocket(80);\r\n```\r\n\r\n注意，在选择端口时，必须小心。每一个端口提供一种特定的服务，只有给出正确的端口，才能获得相应的服务。0~1023的端口号为系统所保留，例如http服务的端口号为80,telnet服务的端口号为21,ftp服务的端口号为23, 所以我们在选择端口号时，最好选择一个大于1023的数以防止发生冲突。\r\n\r\n在创建socket时如果发生错误，将产生IOException，在程序中必须对之作出处理。所以在创建Socket或ServerSocket是必须捕获或抛出例外。\r\n\r\n**一个简单的案例**\r\n\r\n**Client端**\r\n\r\n客户端的请求过程稍微有点不一样：\r\n\r\n1. 构建Socket实例，通过指定的远程服务器地址和端口来建立连接。\r\n\r\n2. 通过Socket实例包含的InputStream和OutputStream来进行数据的读写。\r\n\r\n3. 操作结束后调用socket实例的close方法，关闭。\r\n\r\n```Java\r\npublic class TalkClient {\r\n    public static void main(String args[]) {\r\n        try {\r\n            Socket socket = new Socket(\"127.0.0.1\", 4700);\r\n            //向本机的4700端口发出客户请求\r\n            BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));\r\n            //由系统标准输入设备构造BufferedReader对象\r\n            PrintWriter os = new PrintWriter(socket.getOutputStream());\r\n            //由Socket对象得到输出流，并构造PrintWriter对象\r\n            BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n            //由Socket对象得到输入流，并构造相应的BufferedReader对象\r\n            String readline;\r\n            readline = sin.readLine(); //从系统标准输入读入一字符串\r\n            while (!readline.equals(\"bye\")) {\r\n                //若从标准输入读入的字符串为 \"bye\"则停止循环\r\n                os.println(readline);\r\n                //将从系统标准输入读入的字符串输出到Server\r\n                os.flush();\r\n                //刷新输出流，使Server马上收到该字符串\r\n                System.out.println(\"Client:\" + readline);\r\n                //在系统标准输出上打印读入的字符串\r\n                System.out.println(\"Server:\" + is.readLine());\r\n                //从Server读入一字符串，并打印到标准输出上\r\n                readline = sin.readLine(); //从系统标准输入读入一字符串\r\n            } //继续循环\r\n            os.close(); //关闭Socket输出流\r\n            is.close(); //关闭Socket输入流\r\n            socket.close(); //关闭Socket\r\n        } catch (Exception e) {\r\n            System.out.println(\"Error\" + e); //出错，则打印出错信息\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Server端**\r\n\r\nServer端所要做的事情主要是建立一个通信的端点，然后等待客户端发送的请求。典型的处理步骤如下：\r\n\r\n1. 构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。\r\n\r\n2. 重复如下几个步骤：\r\n\r\n   a. 调用socket的accept()方法来获得下面客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。\r\n\r\n   b.通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个stream来分别读和写数据。\r\n\r\n   c.结束的时候调用socket实例的close()方法关闭socket连接。\r\n\r\n```Java\r\npublic class TalkServer {\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = null;\r\n            try {\r\n                //创建一个ServerSocket在端口4700监听客户请求\r\n                server = new ServerSocket(4700);\r\n            } catch (Exception e) {\r\n                //出错，打印出错信息\r\n                System.out.println(\"can not listen to:\" + e);\r\n            }\r\n            Socket socket = null;\r\n            try {\r\n                //使用accept()阻塞等待客户请求，有客户\r\n                //请求到来则产生一个Socket对象，并继续执行\r\n                socket = server.accept();\r\n            } catch (Exception e) {\r\n                //出错，打印出错信息\r\n                System.out.println(\"Error.\" + e);\r\n            }\r\n            String line;\r\n            //由Socket对象得到输入流，并构造相应的BufferedReader对象\r\n            BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n            //由Socket对象得到输出流，并构造PrintWriter对象\r\n            PrintWriter os = new PrintWriter(socket.getOutputStream());\r\n            //由系统标准输入设备构造BufferedReader对象\r\n            BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));\r\n            //在标准输出上打印从客户端读入的字符串\r\n            System.out.println(\"Client:\" + is.readLine());\r\n            //从标准输入读入一字符串\r\n            line = sin.readLine();\r\n            //如果该字符串为 \"bye\"，则停止循环\r\n            while (!line.equals(\"bye\")) {\r\n                //向客户端输出该字符串\r\n                os.println(line);\r\n                //刷新输出流，使Client马上收到该字符串\r\n                os.flush();\r\n                //在系统标准输出上打印读入的字符串\r\n                System.out.println(\"Server:\" + line);\r\n                //从Client读入一字符串，并打印到标准输出上\r\n                System.out.println(\"Client:\" + is.readLine());\r\n                //从系统标准输入读入一字符串\r\n                line = sin.readLine();\r\n            } //继续循环\r\n            os.close(); //关闭Socket输出流\r\n            is.close(); //关闭Socket输入流\r\n            socket.close(); //关闭Socket\r\n            server.close(); //关闭ServerSocket\r\n        } catch (Exception e) {\r\n            //出错，打印出错信息\r\n            System.out.println(\"Error:\" + e);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 21、数字签名和数字证书\r\n\r\nhttp://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\r\n\r\n\r\n\r\n## 22、跨域问题\r\n\r\n**什么是跨域**\r\n\r\n前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。\r\n\r\n**为什么会发生跨域问题**\r\n\r\n要同时满足三个条件才会产生跨域问题，这也就是为什么会产生跨域的原因。\r\n\r\n- 1、浏览器限制，而不是服务端限制，可以查看Network，请求能够正确响应，response返回的值也是正确的\r\n- 2、请求地址的域名或端口和当前访问的域名或端口不一样\r\n- 3、发送的是XHR（XMLHttpRequest）请求，可以使用 a 标签（模拟xhr请求）和 img 标签（模拟json请求）做对比（控制台只报了一个跨域异常）\r\n\r\n例子：\r\n\r\n![跨域问题](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/v2-5fa29773fc875bf58e4513fdba402bf0_b.png)\r\n\r\n**同源策略**\r\n\r\n同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以xyz.com下的js脚本采用ajax读取abc.com里面的文件数据是会被拒绝的。\r\n\r\n同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。\r\n\r\n\r\n\r\n**跨域的方法**\r\n\r\nhttps://segmentfault.com/a/1190000015597029\r\n\r\n**1、JSONP**\r\n\r\n只要说到跨域，就必须聊到 JSONP，JSONP全称为：JSON with Padding，可用于解决主流浏览器的跨域数据访问的问题。\r\n\r\n>  原理：Web 页面上调用 js 文件不受浏览器同源策略的影响，比如script或者img等，所以通过 Script 便签可以进行跨域的请求：\r\n\r\n1. 首先前端先设置好回调函数，并将其作为 url 的参数。\r\n2. 服务端接收到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回\r\n3. 收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。\r\n\r\n优点：\r\n\r\n1. 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制\r\n2. 兼容性很好，在古老的浏览器也能很好的运行\r\n3. 不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。\r\n\r\n缺点：\r\n\r\n1. 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求（因为script加载资源就是get）。\r\n2. 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题\r\n\r\n\r\n\r\n**2、CORS**\r\n\r\nCORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。\r\n\r\nCORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\r\n\r\n因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\r\n\r\nCORS 的优缺点：\r\n\r\n1. 使用简单方便，更为安全\r\n2. 支持 POST 请求方式\r\n3. CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上\r\n\r\n\r\n\r\n**3、Server Proxy**\r\n\r\n服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。\r\n\r\n假设有这样的一个场景，你的页面需要获取 [CNode：Node.js专业中文社区](https://link.zhihu.com/?target=https%3A//cnodejs.org/api) 论坛上一些数据，如通过 [https://cnodejs.org/api/v1/topics](https://link.zhihu.com/?target=https%3A//cnodejs.org/api/v1)，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。\r\n\r\n\r\n\r\n## 23、子网掩码的作用\r\n\r\n**作用**\r\n\r\n在设置电脑IP时，会碰到两个重要的参数，一个是IP地址，一个是子网掩码。IP地址是互联网上每个子网或每个主机在网络上的唯一身份标签，那子网掩码是干什么用的呢？\r\n\r\n随着互联网的发展，越来越多的网络产生，有的网络多则几百台主机，少则区区几台，这样就浪费了大量的IP地址，所以要划分子网。为了有序地区分和管理不同的子网，就需要使用子网掩码。\r\n\r\n子网掩码是一种用来指明一个IP地址所标示的主机处于哪个子网中。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](https://baike.baidu.com/item/网络地址)和[主机地址](https://baike.baidu.com/item/主机地址)两部分。\r\n\r\n**子网掩码的用法**\r\n\r\n子网掩码是一个32位地址，对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。\r\n\r\n子网掩码通常有十进制和二级制两种表现形式，255.255.0.0用二进制表示则为1111111.11111111.00000000.00000000，其中，前面2个字节的16位“1”表示网络号，后面2个字节的16位“0”表示主机号。\r\n\r\n当配合IP地址172.20.0.4使用时，则表示该IP地址是B类地址，172.20是网络标识，0.4是主机标识。也即子网掩码AND IP地址的部分是网络标识，子网掩码取反后AND IP地址的部分即为主机标识。\r\n\r\n子网掩码有两个特殊地址，当子网掩码的**主机地址**全为0时，表示该网络地址，当子网掩码的**主机地址**全为1时，表示该网络的广播地址。\r\n\r\n**举例**\r\n\r\n例1、不同子网下的主机能否直接通信\r\n\r\n假设两个IP地址分别是172.20.0.18和172.20.1.16，子网掩码都是255.255.255.0。\r\n\r\n我们可以知道两者的网络标识分别是172.20.0和172.20.1，无法直接通信，也就无法PING通。要想能相互通信，需要将子网掩码改成255.255.0.0。\r\n\r\n例2、如何确定子网掩码\r\n\r\n1）将主机数目转化为二进制来表示，总位数是N；\r\n\r\n2）将掩码地址全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。\r\n\r\n如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有[主机](https://baike.baidu.com/item/主机)700台：\r\n\r\n1)700=1010111100，该[二进制](https://baike.baidu.com/item/二进制)为十位数，N = 10\r\n\r\n2)将子网掩码255.255.255.255从后向前的10位全部置0,即为： 11111111.11111111.11111100.00000000，也即255.255.252.0。\r\n\r\n255.255.252.0就是168.195.0.0的700台主机的子网掩码了。\r\n\r\n例3、如何理解172.20.1.0/26\r\n\r\n上文中的26代表主机ID的掩码地址长度，从前往后有26位，即子网掩码的地址是255.255.255.192。\r\n\r\n## 24、Socket\r\n\r\n**TCP/IP UDP是什么？**\r\n\r\nTCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。下面是他们三者的关系：\r\n![socket1](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/2019091910152326.jpg)\r\n\r\n可以看出TCP/IP协议族包括运输层、网络层、链路层。socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。\r\n![socket2](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20190919101544464.jpg)\r\n\r\n**socket与TCP/IP的对应关系**\r\n\r\nSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\r\n\r\n![socket3](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20190919101600352.jpg)\r\n\r\n原作者将socket通信类比为打电话这一生活场景。这里我把TCP服务器比作政府某一服务部门能，TCP客户端比作企业中某一部门电话，描述这一过程，恰好就像是socket通信，服务部门提供服务，企业部门申请服务。\r\n\r\n要实现通信，首先政府部门都必须申请一个电话（socket_fd），并向有关部门注册（我们的系统），提供地址（sockadrr）以及属于哪个部门的（port），录入系统后，就算是合约生效了（bind），于是乎，政府广而告之，这个服务热线就算开通了，在部门里面的人员所需要做的事情，就是等待企业家拨打热线（listen）。\r\n\r\n企业家拨打电话对地点和部门没有这么多的要求了，他并不需要绑定地址和部门，在任何一个可以拨打电话的地方(可能是同个部门，也可以同公司不同部门，甚至可能是竞争对手)，他只需要拿起一个已经注册的电话（socket_fd），拨打电话（connect）\r\n政府部门接通电话（accept）后，桥梁就打通了（服务者client_fd、顾客server_fd），可以进行听说了（read write）。企业家咨询完成（close）,政府到点下班关闭服务（close）\r\n\r\n\r\n\r\n## 25、正向代理和反向代理\r\n\r\nhttps://blog.csdn.net/liuhenghui5201/article/details/90720442\r\n\r\n**正向代理**\r\n\r\n所谓正向代理就是顺着请求的方向进行的代理，即代理服务器他是由你配置为你服务，去请求目标服务器地址。\r\n\r\n比如我们要去访问谷歌网站，我们直接访问不通，那么我们就可以找一个代理服务器为我们服务，我们通过代理服务器请求到谷歌网站。对于谷歌而言他只知道有一个服务器访问了自己，并不知道这件事你是访问不了他,找了一个代理服务器访问自己。\r\n\r\n在举一个通俗的例子。你需要钱，C正好有钱，但是你C不直接借给你。你和B关系比较好，B可以找C借到钱。你和B沟通后，由B来找C借到钱后在给你。\r\n\r\n上面的两个例子中的共同特点是 代理服务器和B都是你找到的，为你而服务的，代表你的利益。我们还可以让代理服务器给你代理到推特、Facebook等，他是代理的你。\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20190531180703829.jpg)\r\n\r\n**反向代理**\r\n\r\n所谓反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server。\r\n\r\n比如 我们访问百度网站，百度的代理服务器对外的域名为 https://www.baidu.com 。具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回。\r\n\r\n再举例：我们同样需要钱，但是我们又不知道谁有钱，所以我们找了一家网贷平台，你提交资料后，网贷平台直接将钱打给你。但是你不知道，也不用关注网贷平台的钱从哪里来。网贷平台内部他们可能从哪一个财主哪里融的钱。对你而言网贷平台和他们的金主是一起的。\r\n\r\n同样通过上面我们例子可以看到，此时的代理服务器和后面的目标主机是一个系统的（百度公司、网贷平台）。他们是对外提供服务的，所以称为反向代理，代理的是后的人。\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20190531180723798.jpg)\r\n\r\n\r\n\r\n## 26、URL的组成\r\n\r\n举例如下：\r\n\r\n```URL\r\nhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument\r\n```\r\n\r\n**协议(Protocol)**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-9c944bfa4685da9d.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`http://`为协议名,标明了请求需要使用的协议,通常使用的是`HTTP`协议或者安全协议 `HTTPS`.其他协议还有`mailto:`用户打开邮箱的客户端,和`ftp:`用来做文件的转换, `file`用来获取文件,`data`获取外部资源等\r\n\r\n**域名(Domain)**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-6068fb7f1ccfa077.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`www.example.com`为域名,标明了需要请求的服务器的地址.\r\n\r\n**端口(Port)**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-809dab17b26b8990.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`:80`是端口号,标明了获取服务器资源的入口\r\n 端口号用于区分服务的端口,一台拥有IP地址的服务器可以提供许多服务，比如`Web`服务、`FTP`服务、`SMTP`服务等.那么，服务器的资源通过“IP地址+端口号”来区分不同的服务.\r\n 如果把服务器比作房子,端口号可以看做是通向不同服务的门,\r\n\r\n**文件路径**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-20a92c8f792effab.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`/path/to/myfile.html`表示服务器上资源的路径,过去这样的路径标记的是服务器上文件的物理路径,但是现在,路径表示的只是一个抽象地址,并不指代任何物理地址.\r\n\r\n**参数(query)**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-5b3e3fd8f0094754.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`?key1=value1&key2=value2`是请求里提供的额外参数.这些参数是以键值对的形式,通过`&`符号分隔开来,服务器可以通过这些参数进行相应的个性化处理\r\n\r\n**片段(fragment)/锚**\r\n\r\n![img](https:////upload-images.jianshu.io/upload_images/2291019-a3812b2b18eb3164.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)\r\n\r\n`#SomewhereInTheDocument`是对资源的部分补充.`fragment`可以理解为资源内部的`书签`.用来想服务器指明展示的内容所在的`书签`的点.例如对于`HTML`文件来说,浏览器会滚动到特定的或者上次浏览过的位置.对于音频或者视频资源来说,浏览器又会跳转到对应的时间节点.\r\n\r\n**补充  :  相对路径和绝对路径**\r\n\r\n我们上面所说的都是`绝对路径`,但是`URL`也有`相对路径`的表现形式.\r\n `URL`所请求的资源依赖于请求所在的上下文,也就是当前环境,在浏览器的输入框内`URL`没有上下文,所以必须提供`绝对路径`.\r\n 但是当`URL`用于文件中时,例如`HTML`的页面,情况就大有不同了,因为浏览器已经拥有了文件的`URL`,所以可以自动填补文件内使用的`URL`丢失的部分,例如`协议`,`域名`,`端口`等,所以我们可以较为直观的区分`相对路径`和`绝对路径`.\r\n 如果`URL`以`/`开头,浏览器会从根服务器去获取资源,而不是从给定的文件夹中获取.\r\n 我们用一些例子来直观的理解下\r\n 完整的`URL`:\r\n\r\n```cpp\r\nhttps://developer.mozilla.org/en-US/docs/Learn\r\n```\r\n\r\n**隐藏协议**\r\n `//developer.mozilla.org/en-US/docs/Learn`\r\n 浏览器会使用文件主机的相同协议\r\n\r\n**隐藏域名**\r\n\r\n```undefined\r\n/en-US/docs/Learn\r\n```\r\n\r\n浏览器会使用文件主机的相同协议和同样的域名,注意,不能在未隐藏协议的前提下只隐藏域名\r\n\r\n## 27、NAT\r\n\r\n**NAT的产生背景**\r\n\r\n2011年2月3日中国农历新年， IANA对外宣布：IPv4地址空间最后5个地址块已经被分配给下属的5个地区委员会。2011年4月15日，亚太区委员会APNIC对外宣布，除了个别保留地址外，本区域所有的IPv4地址基本耗尽。一时之间，IPv4地址作为一种濒危资源身价陡增，各大网络公司出巨资收购剩余的空闲地址。其实，IPv4地址不足问题已不是新问题，早在20年以前，IPv4地址即将耗尽的问题就已经摆在Internet先驱们面前。这不禁让我们想去了解，是什么技术使这一危机延缓了尽20年。\r\n\r\n要找到问题的答案，让我们先来简略回顾一下IPv4协议。\r\n\r\nIPv4即网际网协议第4版——Internet Protocol Version 4的缩写。IPv4定义一个跨越异种网络互连的超级网，它为每个网际网的节点分配全球唯一IP地址。如果我们把Internet比作一个邮政系统，那么IP地址的作用就等同于包含城市、街区、门牌编号在内的完整地址。IPv4使用32bits整数表达一个地址，地址最大范围就是232 约为43亿。以IP创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量呈爆炸性增长。\r\n\r\n更为糟糕的是，为了路由和管理方便，43亿的地址空间被按照不同前缀长度划分为A,B,C,D类地址网络和保留地址。其中，A类网络地址127段，每段包括主机地址约1678万个。B类网络地址16384段，每段包括65536个主机地址。\r\nANA向超大型企业/组织分配A类网络地址，一次一段。向中型企业或教育机构分配B类网络地址，一次一段。这样一种分配策略使得IP地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪90年代初，网络专家们意识到，这样大手大脚下去，IPv4地址很快就要耗光了。于是，人们开始考虑IPv4的替代方案，同时采取一系列的措施来减缓IPv4地址的消耗。正是在这样一个背景之下，本期的主角闪亮登场，它就是网络地址转换——NAT。\r\n\r\nNAT是一项神奇的技术，说它神奇在于它的出现几乎使IPv4起死回生。在IPv4已经被认为行将结束历史使命之后近20年时间里，人们几乎忘了IPv4的地址空间即将耗尽这样一个事实——在新技术日新月异的时代，20年可算一段漫长的历史。更不用说，在NAT产生以后，网络终端的数量呈加速上升趋势，对IP地址的需求剧烈增加。此足见NAT技术之成功，影响之深远。\r\n\r\n**IP地址基础知识**\r\n\r\n同学你现在做两个操作\r\n\r\n- 打开你的命令行输入ipconfig查询你的Ip地址\r\n- 打开百度，输入Ip查询，查询你的ip地址\r\n\r\n**你是不是发现了一件很神奇的事情，这两个地址是不一样的。但是我们又经常说每个主机只有一个ip,这个ip是他的身份标识。这完全矛盾啊。这就引出了我们今天要讲的NAT技术**\r\n其实并不矛盾。这里我们要引入公网ip和私网ip这两个概念，关于这个问题的解读。大家可以参看我的博文。[为什么百度查到的ip和ipconfig查到的不一样](http://blog.csdn.net/gui951753/article/details/79210535)\r\n\r\n**NAT技术的工作原理和特点**\r\n\r\nNAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？\r\n\r\nRFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。\r\n\r\n对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。\r\n\r\n**NAT的转换示意图如下所示**\r\n![NAT](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180317120704396)\r\n**我们一般使用私网ip作为局域网内部的主机标识，使用公网ip作为互联网上通信的标识**\r\n\r\n在整个NAT的转换中，最关键的流程有以下几点\r\n\r\n- 网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关\r\n- **网络访问只能先由私网侧发起，公网无法主动访问私网主机；**\r\n- NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换；\r\n- NAT网关的存在对通信双方是保持透明的；\r\n- NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。\r\n\r\n#### 静态NAT\r\n\r\n如果一个内部主机唯一占用一个公网IP，这种方式被称为一对一模型。此种方式下，转换上层协议就是不必要的，因为一个公网IP就能唯一对应一个内部主机。显然，这种方式对节约公网IP没有太大意义，主要是为了实现一些特殊的组网需求。比如用户希望隐藏内部主机的真实IP，或者实现两个IP地址重叠网络的通信。\r\n\r\n![这里写图片描述](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180317121254424)\r\n\r\n#### 动态NAT\r\n\r\n它能够将未注册的IP地址映射到注册IP地址池中的一个地址。不像使用静态NAT那样，你无需静态地配置路由器，使其将每个内部地址映射到一个外部地址，但必须有足够的公有因特网IP地址，让连接到因特网的主机都能够同时发送和接收分组\r\n\r\n![这里写图片描述](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180317121852115)\r\n\r\n#### NAT重载（经常应用到实际中）\r\n\r\n这是最常用的NAT类型。NAT重载也是动态NAT，它利用源端口将多个私网ip地址映射到一个公网ip地址(多对一)。那么，它的独特之处何在呢?它也被称为端口地址特换(PAT)。通过使用PAT(NAT重载)，只需使用一个公网ip地址，就可将数千名用户连接到因特网。其核心之处就在于利用端口号实现公网和私网的转换。\r\n\r\n面对私网内部数量庞大的主机，如果NAT只进行IP地址的简单替换，就会产生一个问题：当有多个内部主机去访问同一个服务器时，从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。这种方式也被称为端口转换PAT、NAPT或IP伪装，但更多时候直接被称为NAT，因为它是最典型的一种应用模式。\r\n![这里写图片描述](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20180317145204964)\r\n\r\n**举个例子，客户端172.18.250.6和百度服务器202.108.22.5通信，172.18.250.6发送数据时，先转换为219.155.6.240:1723（任意>1024的随机端口），然后再利用这个身份发送数据给百度服务器，然后百度服务器回应数据并发送给219.155.6.240:1723，NAT网关检查自己的关联表，意识到这是自己地私网中172.18.250.6的数据包，然后把这个数据发送给客户端**\r\n\r\n**也就是说，我们利用端口号的唯一性实现了公网ip转换为私网ip的这一步。PAT（NAT重载）能够使用传输层端口号来标识主机，因此，从理论上说，最多可让大约65000台主机共用一个公有IP地址**\r\n\r\n#### NAT技术的优缺点\r\n\r\n**优点**\r\n\r\n- 节省合法的公有ip地址\r\n\r\n- 地址重叠时，提供 解决办法\r\n\r\n- 网络发生变化时，避免重新编址（这个问题具有亲身体会，原本所在的实习单位搬迁，我们搬到了新的住处，网络环境发生了一些变化，但是由于nat技术的特点，我们局域网的地址并没有发生改变，我们依然使用着最初的编址方案）\r\n\r\n  **NAT对我们来说最大的贡献就是帮助我们节省了大量的ip资源**\r\n\r\n**缺点**\r\n\r\n**在介绍NAT的诸多缺点之前，我们先简单介绍下什么是IP的端到端通信：**\r\n\r\n> IP协议的一个重要贡献是把世界变得平等。在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。人们熟知的服务器和客户机实际是在应用协议层上的角色区分，而在网络层和传输层没有差异。一个具有IP地址的主机既可以是客户机，也可以是服务器，大部分情况下，既是客户机，也是服务器。端到端对等看起来是很平常的事情，而意义并不寻常。但在以往的技术中，很多协议体系下的网络限定了终端的能力。正是IP的这个开放性，使得TCP/IP协议族可以提供丰富的功能，为应用实现提供了广阔平台。因为所有的IP主机都可以服务器的形式出现，所以通讯设计可以更加灵活。使用UNIX/LINUX的系统充分利用了这个特性，使得任何一个主机都可以建立自己的HTTP、SMTP、POP3、DNS、DHCP等服务。与此同时，很多应用也是把客户端和服务器的角色组合起来完成功能。例如在VoIP应用中，用户端向注册服务器登录自己的IP地址和端口信息过程中，主机是客户端；而在呼叫到达时，呼叫处理服务器向用户端发送呼叫请求时，用户端实际工作在服务器模式下。在语音媒体流信道建立过程后，通讯双向发送语音数据，发送端是客户模式，接收端是服务器模式。而在P2P的应用中，一个用户的主机既为下载的客户，同时也向其他客户提供数据，是一种C/S混合的模型。上层应用之所以能这样设计，是因为IP协议栈定义了这样的能力。试想一下，如果IP提供的能力不对等，那么每个通信会话都只能是单方向发起的，这会极大限制通信的能力。细心的读者会发现，前面介绍NAT的一个特性正是这样一种限制。没错，NAT最大的弊端正在于此——破坏了IP端到端通信的能力。\r\n\r\n**NAT的弊端**\r\n\r\n首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。\r\n\r\n其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。\r\n总之，缺点大概如下：\r\n\r\n- 无法进行端到端的ip跟踪（破坏了端对端通信的平等性）\r\n- 很多应用层协议无法识别（比如ftp协议 ）\r\n\r\n\r\n\r\n## 28、HTTP 2.0 头部压缩算法\r\n\r\nhttps://segmentfault.com/a/1190000017011816\r\n\r\n**问题背景**\r\n\r\nHTTP1.x的header中的字段很多时候都是重复的，例如`method:get`、`status:200`等等，随着网页增长到需要数十到数百个请求，这些请求中的冗余标头字段不必要地消耗带宽，从而显著增加了延迟，因此，Hpack技术应时而生。\r\n\r\n**Hpack思想简介**\r\n\r\n首先介绍下**压缩**的概念（比较简单，熟悉的可以跳过）：\r\n\r\n1. 通信的双方各拥有一本字典，记录着某些字符对应的文本内容，例如x代表危险，y代表撤退，z代表进攻等；\r\n2. 消息发送方根据字典生成消息文本比如'x，y'\r\n3. 接收方接收到消息后，根据字典还原内容：“危险，撤退”\r\n\r\n这个例子已经简单介绍了压缩的好处：**可以在传输的过程，简化消息内容，从而降低消息的大小**\r\n\r\n官方文档里的对Hpack的主要思想说明：\r\n\r\n> 1. 将header里的字段列表视为可包括重复对的name-value键值对的有序集合，分别使用8位字节表示name和value\r\n> 2. 当字段被编码/解码时，对应的字典会不断扩充\r\n> 3. 在编码形式中，header字段可以直接表示，也可以使用header field tables 中对应的引用。因此，可以使用引用和文字值的混合来header字段列表。\r\n> 4. 文字值要么直接编码，要么使用静态huffman代码\r\n> 5. 编码器负责决定在标题字段表中插入哪些标题字段作为新条目。解码器执行对编码器规定的报头字段表的修改，重建处理中的报头字段列表\r\n\r\n**过程简述**\r\n\r\n简单描述一下Hpack算法的过程：\r\n\r\n- 消息发送端和消息接受端共同维护一份静态表和一份动态表（这两个合起来充当**字典**的角色），\r\n- 每次请求时，发送方根据字典的内容以及一些特定指定，编码压缩消息头部，\r\n- 接收方根据字典进行解码，并且根据指令来判断是否需要更新动态表\r\n\r\n\r\n\r\n## 29、Session与Token\r\n\r\n**为什么要有session的出现？**\r\n\r\n答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。\r\n\r\n**session生成方式？**\r\n\r\n答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；\r\n还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器；\r\n\r\n简单来讲，用户访问的时候说他自己是张三，他骗你怎么办？ 那就在服务器端保存张三的信息，给他一个id，让他下次用id访问。\r\n\r\n**为什么会有token的出现？**\r\n\r\n答：首先，session的存储是需要空间的，其次，session的传递一般都是通过cookie来传递的，或者url重写的方式；而token在服务器是可以不需要存储用户的信息的，而token的传递方式也不限于cookie传递，当然，token也是可以保存起来的；\r\n\r\n**token的生成方式？**\r\n\r\n答：浏览器第一次访问服务器，根据传过来的唯一标识userId，服务端会通过一些算法，如常用的HMAC-SHA256算法，然后加一个密钥，生成一个token，然后通过BASE64编码一下之后将这个token发送给客户端；客户端将token保存起来，下次请求时，带着token，服务器收到请求后，然后会用相同的算法和密钥去验证token，如果通过，执行业务操作，不通过，返回不通过信息；\r\n\r\n**token和session的区别？**\r\n\r\ntoken和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；\r\n\r\nsession服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；\r\n其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。\r\n\r\n虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法 /非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。 \r\n\r\n而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？ \r\n\r\n> 方案 A ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。 \r\n> 方案 B ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。 \r\n> 就这么个差别。\r\n\r\n**Token组成**\r\n\r\n- uid: 用户唯一身份标识\r\n- time: 当前时间的时间戳\r\n- sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接\r\n- 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库\r\n\r\n**Token存放**\r\n\r\ntoken在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中\r\n\r\n**Token认证流程**\r\n\r\ntoken 的认证流程与cookie很相似\r\n\r\n- 用户登录，成功后服务器返回Token给客户端。\r\n- 客户端收到数据后保存在客户端\r\n- 客户端再次访问服务器，将token放入headers中\r\n- 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码\r\n\r\n**Token可以抵抗csrf，cookie+session不行**\r\n\r\n假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为`http://www.bank.com/api/transfer`，body为`count=1000&to=Tom`。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。\r\n\r\n**分布式情况下的session和token**\r\n\r\n我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。\r\n\r\n- 负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种[解决session负载均衡](https://link.zhihu.com/?target=http%3A//blog.51cto.com/zhibeiwang/1965018)的方法。\r\n\r\n而token是无状态的，token字符串里就保存了所有的用户信息\r\n\r\n- 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做[JWT(Json Web Token)](https://link.zhihu.com/?target=https%3A//huanqiang.wang/2017/12/28/JWT%20%E4%BB%8B%E7%BB%8D/)\r\n\r\n**总结**\r\n\r\n- session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie\r\n- cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。\r\n- token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。\r\n- jwt只是一个跨域认证的方案",
        "timemini": ""
    },
    {
        "index": 28,
        "title": "计网笔记（二）",
        "essay": "## 5、DNS\r\n\r\n域名系统DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址，这个过程叫做DNS域名解析。\r\n\r\nhttps://zhuanlan.zhihu.com/p/79350395\r\n\r\n![因特网的域名空间](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20140506153156531)\r\n\r\nDNS域名解析流程图\r\n\r\n![DNS域名解析流程图](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209288074.png)\r\n\r\n如图所示，大致就是:浏览器输入地址，然后浏览器这个进程去调操作系统某个库里的gethostbyname函数(例如，Linux GNU glibc标准库的gethostbyname函数)，然后呢这个函数通过网卡给DNS服务器发UDP请求，接收结果，然后将结果给返回给浏览器。\r\n\r\n这张图其实已经讲明白大致的流程，但是细节上可能有些差异。 例如\t\r\n\r\n- (1)我们在用chrome浏览器的时候，其实会先去浏览器的dns缓存里头查询，dns缓存中没有，再去调用gethostbyname函数\r\n- (2)gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，如果没找到再去DNS服务器上查\r\n\r\n此时涉及两个知识点\r\n\r\n**1、说说UDP协议在哪里使用，TCP协议在哪里使用?**    \r\n\r\nTCP协议是基于连接的可靠协议，有流量控制和差错控制，也正因为有可靠性的保证和控制手段，所以传输效率比UDP低；    UDP协议是基于无连接的不可靠协议，没有控制手段，仅仅是将数据发送给对方，因此效率比TCP要高。    基于上述特性，不难得到结论，TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；    而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景。 \r\n\r\n**2、DNS在域名解析上用UDP还是TCP?**    \r\n\r\n域名解析的时候使用的是UDP\r\n\r\n> 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\r\n\r\n需要补充说明一下，DNS中也有一个地方用到了TCP协议，那就是区域传输\r\n\r\n> 1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\r\n>\r\n> 2.TCP是一种可靠连接，保证了数据的准确性。\r\n\r\n\r\n\r\nDNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 这种情况下，使用TCP协议。\r\n\r\n讲到这里，面试官有可能继续追问\r\n\r\n**1、讲讲域名解析为什么要用UDP?**    \r\n\r\n因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。    但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。 \r\n\r\n**2、讲讲区域复制为什么要用TCP?**   \r\n\r\n 因为TCP协议可靠性好啊！你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？    万一同步的数据大于512字节，你怎么办？    \r\n\r\n**DNS域名解析的原理**\r\n\r\n先介绍Linux的dig命令，以显示域名解析的过程。为了方便说明，我们先来dig一下天猫的过程\r\n\r\ndig www.tmall.com\r\n\r\n结果如下图所示\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209293790.png)\r\n\r\n第一段代表请求参数如下图所示\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209295806.png)\r\n\r\n这段为查询内容。DNS的查询参数一般有三个\r\n\r\n1. 域名：服务器、邮件服务器（@后面的部分）的名称\r\n2. Class：在设置DNS方案时，互联网之外的网络也考虑到了，而Class就是用来识别网络的，不过现在只有互联网，所以它的值永远都是代表互联网的IN\r\n3. 记录类型：表示域名对应何种类型的记录。类型为A，表示域名对应的IP地址。类型为MX时，表示域名对应的是邮件服务器。类型为PTR，表示根据IP地址反查域名。类型为CNAME，表示查询域名相关别名\r\n\r\n但是为什么输入的是tmall.com，返回的确实www.tmall.com.呢？也就是：**DNS是怎么做域名解析的**\r\n\r\nwww.tmall.com对应的真正域名为www.tmall.com.  末尾的.称为根域名，因为每个域名都有根域名，所以我们通常省略 根域名的下一级叫做“顶级域名”，比如“.com、 .net” 再下一级叫做“次级域名”，比如www.tmall.com里面的.tmall，这一级域名是用户可以注册的； 再下一级是主机名（host），比如www.tmall.com里面的www，又称为\"三级域名\"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。\r\n\r\n那么解析的流程就是分级查询\r\n\r\n(1)先在本机的DNS里头查，如果有就直接返回了。本机DNS类似下图\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209300586.png)\r\n\r\n(2)本机DNS里头发现没有，就去根服务器里查。根服务器发现这个域名是属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS 服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”\r\n\r\n(3)本机的DNS接到又会向com域的DNS服务器发送查询消息。com 域中也没有www.tmall.com这个域名的信息，和刚才一样，com域服务器会返回它下面的tmall.com域的DNS服务器的IP地址。\r\n\r\n以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器\r\n\r\n来看第二段内容，也就是响应体的部分！ 如下所示\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209302689.png)\r\n\r\n很明显，第一行就是说www.tmall.com有一个别名是www.tmall.com.danuoyi.tbcache.com。后面几行就是这www.tmall.com.danuoyi.tbcache.com地址的真实IP。\r\n\r\n**DNS过程**\r\n\r\n1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的IP地址，如果有，解析结束\r\n2. 如果浏览器缓存中没有，浏览器会检查操作系统缓存中有没有对应的已经解析过的结果（一般会存在C盘中的一个hosts的文件中）\r\n3. 如果至此还没有命中域名，才会真正的请求本地域名服务器来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。\r\n4. 如果本地域名服务任然没有命中，就直接去访问Root Server根域名服务器请求解析\r\n5. 根域名服务器返回给本地域名服务器一个所查询域的主域名服务器——顶级域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址\r\n6. 此时本地域名服务器再向上进一步请求gTLD顶级域名服务器\r\n7. 接受请求的gTLD顶级域名服务器查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器\r\n8. Name Server根据映射关系表找到目标ip，返回给本地域名服务器\r\n9. 本地域名服务器缓存这个域名和对应的ip\r\n10. 本地域名服务器把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束\r\n\r\n**DNS负载均衡**\r\n\r\n DNS（Domain Name System）是因特网的一项服务，它作为域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。人们在通过浏览器访问网站时只需要记住网站的域名即可，而不需要记住那些不太容易理解的IP地址。在DNS系统中有一个比较重要的的资源类型叫做主机记录也称为A记录，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。如果你有一个自己的域名，那么要想别人能访问到你的网站，你需要到特定的DNS解析服务商的服务器上填写A记录，过一段时间后，别人就能通过你的域名访问你的网站了。DNS除了能解析域名之外还具有负载均衡的功能，下面是利用DNS工作原理处理负载均衡的工作原理图：\r\n\r\n![**DNS负载均衡**](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20140721145326171)\r\n\r\n由上图可以看出，在DNS服务器中应该配置了多个A记录，如：\r\n\r\n-    www.apusapp.com IN A 114.100.20.201;\r\n-    www.apusapp.com IN A 114.100.20.202;\r\n-    www.apusapp.com IN A 114.100.20.203;\r\n\r\n因此，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。上图中，用户请求www.apusapp.com，DNS根据A记录和负载均衡算法计算得到一个IP地址114.100.20.203，并返回给浏览器，浏览器根据该IP地址，访问真实的物理服务器114.100.20.203。所有这些操作对用户来说都是透明的，用户可能只知道www.apusapp.com这个域名。\r\n\r\n**DNS域名解析负载均衡有如下优点：**\r\n\r\n> 1. 将负载均衡的工作交给DNS，省去了网站管理维护负载均衡服务器的麻烦。\r\n>\r\n> 2. 技术实现比较灵活、方便，简单易行，成本低，使用于大多数TCP/IP应用。\r\n>\r\n> 3. 对于部署在服务器上的应用来说不需要进行任何的代码修改即可实现不同机器上的应用访问。\r\n> 4. 服务器可以位于互联网的任意位置。\r\n>\r\n> 5. 同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样就可以加速用户访问，改善性能。\r\n\r\n  **同时，DNS域名解析也存在如下缺点：**\r\n\r\n> 1. 目前的DNS是多级解析的，每一级DNS都可能缓存A记录，当某台服务器下线之后，即使修改了A记录，要使其生效也需要较长的时间，这段时间，DNS任然会将域名解析到已下线的服务器上，最终导致用户访问失败。\r\n>\r\n> 2. 不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。\r\n>\r\n> 3. 可能会造成额外的网络问题。为了使本DNS服务器和其他DNS服务器及时交互，保证DNS数据及时更新，使地址能随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。\r\n\r\n事实上，大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供服务的物理服务器，而是同样提供负载均衡服务器的内部服务器，这组内部负载均衡服务器再进行负载均衡，请请求发到真实的服务器上，最终完成请求。\r\n\r\n## 6、HTTP的过程/浏览器输入一个url之后的过程\r\n\r\n1. 根据域名，进行DNS域名解析\r\n2. 拿到解析的IP地址，建立TCP连接\r\n3. 向IP地址发送HTTP请求\r\n4. 服务器处理请求\r\n5. 返回响应结果\r\n6. 关闭TCP连接\r\n7. 浏览器解析HTML\r\n8. 浏览器布局渲染\r\n\r\n\r\n\r\n## 7、POST与GET的区别\r\n\r\n最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。\r\n\r\n基本的区别\r\n\r\n- GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n- GET产生的URL地址可以被Bookmark，而POST不可以。\r\n- GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n- GET请求只能进行url编码，而POST支持多种编码方式。\r\n- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n- GET请求在URL中传送的参数是有长度限制的，而POST没有。\r\n- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n- GET参数通过URL传递，POST放在Request body中。\r\n- GET操作具有幂等性，POST操作不具备幂等性（但是put具有幂等性）\r\n\r\n> **HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。**比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。\r\n>\r\n> **HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。**比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。\r\n\r\n## 8、都有哪些常见的请求头\r\n\r\n**http请求是指从客户端到服务器端的请求消息。包括：消息首行中，对资源的请求方法、资源的标识符及使用的协议。** \r\n\r\n**http请求中的常用头（请求头）的含义：**\r\n\r\nAccept：告诉服务器，客户端支持的数据类型。\r\n\r\nAccept-Charset：告诉服务器，客户端采用的编码。\r\n\r\nAccept-Encoding：告诉服务器，客户机支持的数据压缩格式。\r\n\r\nAccept-Language：告诉服务器，客户机的语言环境。\r\n\r\nHost：客户机通过这个头告诉服务器，想访问的主机名。\r\n\r\nIf-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间。\r\n\r\nReferer:客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）\r\n\r\nUser-Agent:客户机通过这个头告诉服务器，客户机的软件环境。\r\n\r\nCookie：客户机通过这个头告诉服务器，可以向服务器带数据。\r\n\r\nCookie是临时文件的意思，保存你浏览网页的痕迹，使得再次上同一页面的时候提高网速，判断你是否登录过这个网站，有些可以帮你自动登录的。\r\n\r\nCookie就是服务器暂存放在你的电脑里的资料（.txt格式的文本文件），通过在HTTP传输中的状态好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookie资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。\r\n\r\nConnection：客户机通过这个头告诉服务器，请求完后是关闭还是保持链接。\r\n\r\nDate：客户机通过这个头告诉服务器，客户机当前请求时间。\r\n\r\n**http请求中常用的响应头的含义：**\r\n\r\nLocation:这个头配合302状态码使用，告诉用户端找谁。\r\n\r\nServer:服务器通过这个头，告诉浏览器服务器的类型\r\n\r\nContent-Encoding:服务器通过这个头，告诉浏览器数据采用的压缩格式。\r\n\r\nContent-Length:服务器通过这个头，告诉浏览器回送数据的长度。\r\n\r\nContent-Language：服务器通过这个头，告诉服务器的语言环境。\r\n\r\nContent-Type:服务器通过这个头，回送数据的类型\r\n\r\nLast-Modified:服务器通过这个头，告诉浏览器当前资源的缓存时间。\r\n\r\nRefresh:服务器通过这个头，告诉浏览器隔多长时间刷新一次。\r\n\r\nContent-Disposition:服务器通过这个头，告诉浏览器以下载的方式打开数据。\r\n\r\nTransfer-Encoding:服务器通过这个头，告诉浏览器数据的传送格式。\r\n\r\nETag:与缓存相关的头。\r\n\r\nExpires:服务器通过这个头，告诉浏览器把回送的数据缓存多长时间。-1或0不缓存。\r\n\r\nCache-Control和Pragma：服务器通过这个头，也可以控制浏览器不缓存数据。\r\n\r\nConnection:服务器通过这个头，响应完是保持链接还是关闭链接。\r\n\r\nDate:告诉客户机，返回响应的时间。\r\n\r\n## 9、CDN\r\n\r\nhttps://baijiahao.baidu.com/s?id=1633945802472340217&wfr=spider&for=pc\r\n\r\n![CDN](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209317922.png)\r\n\r\n**CDN实现原理**\r\n\r\n在描述CDN的实现原理，让我们先看传统的未加缓存服务的访问过程，以便了解CDN缓存访问方式与未加缓存访问方式的差别：\r\n\r\n用户提交域名→浏览器对域名进行解析→得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复\r\n\r\n由上可见，用户访问未使用CDN缓存网站的过程为:\r\n\r\n- 用户向浏览器提供要访问的域名；\r\n- 浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址；\r\n- 浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；\r\n- 浏览器根据域名主机返回的数据显示网页的内容。\r\n\r\n通过以上四个步骤，浏览器完成从用户处接收用户要访问的域名到从域名服务主机处获取数据的整个过程。\r\n\r\nCDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，下面让我们看看访问使用CDN缓存后的网站的过程：\r\n\r\n![cdn过程](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209332464.png)\r\n\r\n通过上图，我们可以了解到，使用了CDN缓存后的网站的访问过程变为：\r\n\r\n1)、用户向浏览器提供要访问的域名；\r\n\r\n2)、浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。\r\n\r\n3)、此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求；\r\n\r\n4)、缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；\r\n\r\n5)、缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，另一方面把获取的数据返回给客户端，完成数据服务过程；\r\n\r\n6)、客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。\r\n\r\nCDN一般包含分发服务系统、负载均衡系统和管理系统\r\n\r\n**分发服务系统**\r\n\r\n其基本的工作单元就是各个cache服务器。负责直接响应用户请求，将内容快速分发到用户；同时该负责内容更新，保证和源站内容的同步。\r\n\r\n根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。 \r\n\r\n在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个 Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由 哪个 Cache 设备来响应用户的请求。\r\n\r\n**负载均衡系统**\r\n\r\n负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问 地址。 \r\n\r\n使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。 GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS 解析或者应用层重定向（Http 3XX 重定向）的方式实现。 \r\n\r\nSLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调 度（Nginx）和链路负载调度等。\r\n\r\n**管理系统**\r\n\r\n分为运营管理和网络管理子系统。 \r\n\r\n网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资 源的可视化的集中管理，通常用 web 方式实现。 \r\n\r\n运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、 交付工作。包括用户管理、产品管理、计费管理、统计分析等。\r\n\r\n**CDN网络具体实现过程**\r\n\r\n通过以上的分析我们可以得到，为了实现既要对普通用户透明(即加入缓存以后用户客户端无需进行任何设置，直接使用被加速网站原有的域名即可访问，又要在为指定的网站提供加速服务的同时降低对ICP的影响，只要修改整个访问过程中的域名解析部分，以实现透明的加速服务，下面是CDN网络实现的具体操作过程。\r\n\r\n1)、作为ICP，只需要把域名解释权交给CDN运营商，其他方面不需要进行任何的修改；操作时，ICP修改自己域名的解析记录，一般用cname方式指向CDN网络Cache服务器的地址。\r\n\r\n2)、作为CDN运营商，首先需要为ICP的域名提供公开的解析，为了实现sortlist，一般是把ICP的域名解释结果指向一个CNAME记录；\r\n\r\n3)、当需要进行sortlist时，CDN运营商可以利用DNS对CNAME指向的域名解析过程进行特殊处理，使DNS服务器在接收到客户端请求时可以根据客户端的IP地址，返回相同域名的不同IP地址；\r\n\r\n4)、由于从cname获得的IP地址，并且带有hostname信息，请求到达Cache之后，Cache必须知道源服务器的IP地址，所以在CDN运营商内部维护一个内部DNS服务器，用于解释用户所访问的域名的真实IP地址；\r\n\r\n5)、在维护内部DNS服务器时，还需要维护一台授权服务器，控制哪些域名可以进行缓存，而哪些又不进行缓存，以免发生开放代理的情况。\r\n\r\n**商用CDN系统**\r\n\r\n分为运营管理和网络管理子系统。 \r\n\r\n网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资 源的可视化的集中管理，通常用 web 方式实现。 \r\n\r\n运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、 交付工作。包括用户管理、产品管理、计费管理、统计分析等。\r\n\r\n\r\n\r\n## 10、TCP与UDP\r\n\r\n### TCP基础\r\n\r\n当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。\r\n\r\nTCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。\r\n\r\n**TCP协议的特点**\r\n\r\n- 面向连接\r\n\r\n  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\r\n\r\n- 仅支持单播传输\r\n\r\n  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\r\n\r\n- 面向字节流\r\n\r\n  TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\r\n\r\n- 可靠传输\r\n\r\n  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\r\n\r\n- 提供拥塞控制\r\n\r\n  当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞\r\n\r\n- TCP提供全双工通信\r\n\r\n  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）\r\n\r\n### TCP的结构\r\n\r\n![TCP的结构](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1263745-20180727095152232-1351502657.png)\r\n\r\n![img](https://images2018.cnblogs.com/blog/1263745/201807/1263745-20180727095159404-1092802231.png)\r\n\r\nTCP的分用功能是通过端口号实现的\r\n\r\n序号占4个字节，所以范围是[0,2^32-1]，共2的32次方个序号，需要增加到头后便返回0\r\n\r\n确认号是期望收到对方下一个报文段的第一个数据字节的序号\r\n\r\n若确认号=N，则表明，到序号N-1为止的所有数据都已正确收到\r\n\r\n    URG—为1表示高优先级数据包，紧急指针字段有效。\r\n    ACK—为1表示确认号字段有效\r\n    PSH—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。\r\n    RST—为1表示出现严重差错。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。\r\n    SYN—为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步\r\n    FIN—为1表示发送方没有数据要传输了，要求释放连接。\r\n\r\n### UDP基础\r\n\r\nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\r\n\r\n它有以下几个特点：\r\n\r\n**1. 面向无连接**\r\n\r\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\r\n\r\n具体来说就是：\r\n\r\n- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\r\n- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\r\n\r\n**2. 有单播，多播，广播的功能**\r\n\r\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\r\n\r\n**3. UDP是面向报文的**\r\n\r\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\r\n\r\n**4. 不可靠性**\r\n\r\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\r\n\r\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\r\n\r\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\r\n\r\n**5. 头部开销小，传输数据报文时是很高效的。**\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/2019-03-21-03.png)\r\n\r\nUDP 头部包含了以下几个数据：\r\n\r\n- 两个十六位的端口号，分别为源端口（可选字段）和目标端口\r\n- 整个数据报文的长度\r\n- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误\r\n\r\n因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的\r\n\r\n### UDP结构\r\n\r\n![UDP结构](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/6-1911111249535K.gif)\r\n\r\n### TCP与UDP的区别与可靠性\r\n\r\nTCP是面向连接的；UDP是无连接的，即发送数据之前不需要建立连接\r\n\r\nTCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付\r\n\r\nUDP具有较好的实时性，工作效率比TCP高，适用于对告诉传输和实时性有较高的通信或广播通信\r\n\r\n每一条TCP连接只能是点对点的；UDP支持一对一，一对多，多对一和多对多的交互通信\r\n\r\nTCP对资源要求较多，UDP对系统资源要求较少\r\n\r\nTCP的首部开销为最少20字节，最大60字节，而UDP首部开销仅8字节\r\n\r\n\r\n\r\n###  如何实现UDP的可靠传输\r\n\r\n自定义通讯协议，在应用层定义一些可靠的协议，比如检测包的顺序，重复包等问题，如果没有收到对方的ACK，重新发包\r\n\r\nUDP没有Delievery Garuantee，也没有顺序保证，所以如果你要求你的数据发送与接受既要高效，又要保证有序，收包确认等，你就需要在UDP协议上构建自己的协议。比如RTCP，RTP协议就是在UPD协议之上专门为H.323协议簇上的IP电话设计的一种介于传输层和应用层之间的协议。\r\n\r\nUDP构建可靠数据传输\r\n\r\n简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制，等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输，不过这好像也是一个难题！\r\n\r\n目前有如下开源程序利用UDP实现了可靠的数据传输。分别为RUDP、RTP、UDT\r\n\r\n### 发送方发送频率过高倒置丢包，TCP是如何解决的\r\n\r\nTCP是基于不可靠的网络来实现可靠的传输，肯定也会存在掉包的情况，如果通信中发现缺少数据或者丢包，那么最大的可能在于程序发送的过程或者接受的过程出现问题\r\n\r\n例如服务端要给客户端发送大量数据，send频率很高，那么就很有可能在send环节出现错误（1.程序处理逻辑错误，2.多线程同步错误，3.缓冲区溢出等），如果没有对send发送失败做处理，那么客户端收到的数据比理论要收到的数据少，就会造成丢失数据，丢包现象\r\n\r\n常用的解决方法有：拆包、加包头、发送组合包\r\n\r\n**TCP粘包和拆包问题：**\r\n\r\nTCP是一个“流”协议，一个完整的包可能被TCP拆分成多个包发送，也有可能把小的封装成大的发送。\r\n\r\n假设客户端分别发送数据包D1和D2给服务端，由于**服务端一次性读取到的字节数是不确定**的，所以可能存在以下4种情况。\r\n\r\n1.服务端分2次读取到了两个独立的包，分别是D1,D2,没有粘包和拆包；\r\n\r\n2.**服务端一次性接收了两个包，D1和D2粘在一起了，被成为TCP粘包**;\r\n\r\n3.服务端分2次读取到了两个数据包，第一次读取到了完整的D1和D2包的部分内容,第二次读取到了D2包的剩余内容，这被称为拆包；\r\n\r\n4.如果此时服务端TCP接收滑动窗口非常小,而数据包D1和D2都很大，很有可能发送第五种可能，即服务端多次才能把D1和D2接收完全，期间多次发生拆包情况。\r\n\r\n接收滑动窗口：所谓滑动窗口协议，自己理解有两点：\r\n\r\n1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；\r\n\r\n2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”\r\n\r\n**粘包问题的解决策略：**\r\n\r\n 由于底层的TCP无法理解上层的业务逻辑，所以在底层是无法确保数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：\r\n\r\n- 消息定长，例如每个报文的大小为固定长度200字节,如果不够，空位补空格\r\n- 在包尾增加回车换行符进行分割，例如FTP协议\r\n- 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路是消息头的第一个字段用int来表示消息的总长度\r\n- 更复杂的应用层协议\r\n\r\n### TCP粘包问题\r\n\r\n注意：只有TCP有粘包现象，UDP永远不会粘包，因为TCP是基于数据流的协议，而UDP是基于数据报的协议\r\n\r\n![TCP粘包问题](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1036857-20161210123107304-1582863963.png)\r\n\r\n发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。\r\n\r\n例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束\r\n\r\n**所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。**\r\n\r\n此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据negal优化[算法](http://lib.csdn.net/base/datastructure)把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。\r\n\r\n> negal优化[算法](http://lib.csdn.net/base/datastructure):会将数据量小的，且时间间隔较短的数据一次性发给对方\r\n\r\n1. TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。\r\n2. UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 **即面向消息的通信是有消息保护边界的。**\r\n3. **tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略**\r\n\r\nudp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y>x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠\r\n\r\ntcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。\r\n\r\n**两种情况下会发生粘包**\r\n\r\n- 发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包），也就是由于Nagle算法的原因导致。\r\n- 接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 。TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。\r\n\r\n**什么时候需要处理粘包现象**\r\n\r\n1. 如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象\r\n2. 如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了\r\n\r\n**拆包的发生情况**\r\n\r\n当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。\r\n\r\n> ***补充问题一：为何tcp是可靠传输，udp是不可靠传输***\r\n>\r\n> tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的\r\n>\r\n> 而udp发送数据，对端是不会返回确认信息的，因此不可靠\r\n>\r\n> ***补充问题二：send(字节流)和recv(1024)及sendall***\r\n>\r\n> recv里指定的1024意思是从缓存里一次拿出1024个字节的数据\r\n>\r\n> send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失\r\n\r\n\r\n\r\n### TCP为什么是可靠地\r\n\r\nTCP通过**校验和、超时重传、确认应答和序列号、拥塞控制实现可靠传输**。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。\r\n\r\n**校验和：**\r\n\r\n发送的数据包的二进制相加然后取反，**目的是检测数据在传输过程中的任何变化**。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 \r\n\r\n**确认应答+序列号（累计确认+seq）：**\r\n\r\n接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）\r\n\r\nTCP给发送的**每一个包进行编号**，接收方**对数据包进行排序**，把有序数据传送给应用层。 \r\n\r\n**超时重传：**\r\n\r\n当TCP**发出一个段后，它启动一个定时器**，**等待目的端确认收到这个报文段**。**如果不能及时收到一个确认，将重发这个报文段**。 \r\n\r\n**流量控制：**\r\n\r\n**TCP连接的每一方都有固定大小的缓冲空间**，TCP的**接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。\r\n\r\n**接收方有即时窗口（滑动窗口），随ACK报文发送**\r\n\r\n**拥塞控制：**\r\n\r\n当网络拥塞时，减少数据的发送。\r\n\r\n**发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小**\r\n\r\n**慢启动、拥塞避免、快速发送、快速恢复**\r\n\r\n\r\n\r\n**TCP的可靠传输是通过确认和超时重传的机制来实现的，而确认和超时重传的具体的实现是通过以字节为单位的滑动窗口机制来完成。**\r\n\r\n### 滑动窗口机制：\r\n\r\n在TCP协议中窗口机制分为两种：固定的窗口大小、滑动窗口\r\n\r\n固定窗口存在的问题：如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。如果窗口过大，我们假设发送方一次发送100个数据，但接收方只能处理50个数据，这样每次都只对这50个数据进行确认。发送方下一次还是发送100个数据，但接受方还是只能处理50个数据。这样就避免了不必要的数据来拥塞我们的链路。\r\n\r\n滑动窗口通俗来讲就是一种流量控制技术。\r\n\r\n它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来\r\n\r\n滑动窗口实现了TCP流控制。首先明确滑动窗口的范畴：TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个发送窗口和一个接收窗口。各自的接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的发送窗口则要求取决于对端通告的接收窗口，要求相同。\r\n\r\n滑动窗口解决的是流量控制的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。\r\n\r\n**滑动窗口原理：**\r\n\r\n![**滑动窗口原理](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1629488-20190622120313249-1589098511.png)\r\n\r\n在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是11格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。\r\n\r\n![正常情况](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1629488-20190622120342786-1303756640.png)\r\n\r\n可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。\r\n\r\n**丢包情况**\r\n\r\n有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。\r\n\r\n![丢包](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1629488-20190622120408388-1447718459.png)\r\n\r\n发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。\r\n\r\n这时候我们有个解决方法：**超时重传**\r\n这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。\r\n\r\n![超时重发](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/1629488-20190622120426493-2120202258.png)\r\n\r\n\r\n\r\n### TCP拥塞控制\r\n\r\n提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是拥塞控制。\r\n\r\n拥塞控制包括四部分：**慢启动**、**拥塞避免**、**快速重传**、**快速恢复**\r\n\r\n发送端向网络一次连续写入的数据量，我们称为SWND（Send Window，发送窗口）.但是发送端最终以TCP报文段来发送数据，所以SWND的大小限制了能连续发送的TCP报文段数量。这些TCP报文段的最大长度（仅数据部分）称为SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。\r\n\r\n发送端需要合理的选择SWND的大小，如果SWND太小，会引起明显的网络延迟；反之，如果SWND太大，则容易导致网络拥塞。所以还需要引入一个称为拥塞窗口（Congestion Window,CWND）的状态变量\r\n\r\n（1）**慢启动**\r\n\r\n发送方维持一个拥塞窗口CWND的状态变量。它的大小取决于网络的拥塞程度，并且在动态的变化，发送方会让自己的发送窗口等于这个拥塞窗口。\r\n\r\n发送方控制拥塞窗口的原则是：\r\n\r\n（1）只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。\r\n\r\n（2）但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\r\n\r\n慢启动算法：因为不清楚网络状况，所以需要进行试探，将发送窗口逐渐增大，也就是逐渐增大拥塞窗口的数值。在刚开始发送的时候，先把拥塞窗口CWND设置为最大报文段MSS，每收到一个对新报文段的确认后，就把拥塞窗口最多增加一个MSS数值。这种逐步增大的方法可以使分组注入到网络的速率更加合理。【指数增长】\r\n\r\n为了防止拥塞窗口过大引起网络拥塞，我们需要设置一个慢开始门限ssthreth状态变量，当cwnd < ssthreth时，使用慢开始算法；当cwnd > ssthrerth时，使用拥塞控制算法；如果两者相等，两个都可以使用。\r\n\r\n慢启动的“慢”并不是指CWND增长速率慢而是说在TCP开始发送报文时，先设置CWND=1，使发送端开始时只发送一个报文段进行探测。\r\n\r\n（2）**拥塞避免**\r\n\r\n就是让拥塞窗口缓慢增大，即每经过一个往返时间RTT就使cwnd+1，这种线性增长的速率慢很多。\r\n\r\n只要发送方判断出网络拥塞，不论是在慢开始还是拥塞控制阶段，都要把慢开始门限值设置为出现拥塞时发送端窗口大小的一半，但不能小于2。然后把cwnd重新置为1，执行慢开始算法。\r\n\r\n门限值减半，cwnd重置为1，做目的是减少发送到网络中的分组数，使得发生拥塞的路由器能够有时间能把队列中积压的分组处理掉。\r\n\r\n发送端判断网络拥塞的依据：\r\n\r\n①传送超时，即TCP重传定时器溢出\r\n\r\n②收到重复的确认报文\r\n\r\n（3）**快重传**\r\n\r\n快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。发送方只要一连收到3个同样的确认报文就应当立即重传数据报，不必等待报文段的重传计时器到期。\r\n\r\n当**发送端连续收到三个重复的ack时**，表示该数据段已经丢失，需要重发\r\n\r\n由于TCP包是封装在IP包内，IP包在传输时乱序，意味着TCP包到达接收端也是乱序的，乱序的话也会造成接收端发送冗余ACK。那发送冗余ACK是由于乱序造成的还是包丢失造成的，这里便需要好好权衡一番\r\n\r\n\r\n\r\n（4）**快恢复**\r\n\r\ni.当发送方连续收到三个重复确认时，执行“乘法减小”算法，慢启动门限减半，为了预防网络发生阻塞\r\n\r\nii.由于发送方现在认为网络很可能没有发生阻塞，因此现在不执行慢启动算法，而是把cwnd值设置为慢启动门限减半后的值，然后开始执行拥塞避免算法，拥塞窗口cwnd值线性增大。\r\n\r\n![全过程](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/20190731184935595.png)\r\n\r\n![img](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209396435.png)\r\n\r\n### TCP流量控制\r\n\r\n如果发送端发送数据太快，接收端来不及接收，可能会丢失数据。所以流量控制是让发送端不要发送太快，要让接收端来得及接收\r\n\r\n流量控制是通过大小可变的滑动窗口实现的。\r\n\r\n发送端窗口大小不能超过接收端窗口大小的值。TCP窗口单位是字节。\r\n\r\n为什么要设置窗口，因为如果TCP发完一次数据等待接收端确认再发下一条数据太慢了。\r\n\r\n![TCP流量控制](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/clipboard-1606209401583.png)\r\n\r\n由图中可知，TCP三次流量控制分别是，第一次窗口大小由400减到300，第二次减到100，第三次减到0。\r\n\r\nTCP连接的一方如果收到**零窗口**通知，就会启动坚持计时器。若坚持计时器的时间到期，就会发送一个零窗口控测报文段，收到报文段的一方就重新设置坚持计时器。\r\n\r\n### TCP长连接和短连接的区别\r\n\r\n**什么是长连接和短连接？**\r\n\r\n- 长连接\r\n\r\n  也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接\r\n\r\n- 短连接\r\n\r\n  短连接，顾名思义，与长连接的区别就是，客户端收到服务端的响应后，**立刻发送FIN消息**，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。\r\n\r\n**什么时候用长连接，短连接？** \r\n长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 \r\n\r\n而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。 \r\n\r\n### 全连接队列、半连接队列\r\n\r\n当服务端调用listen函数监听端口的时候，内核会为每个监听的socket创建两个队列：\r\n\r\n- **半连接队列(syn queue**)：客户端发送`SYN`包，服务端收到后回复`SYN+ACK`后，服务端进入`SYN_RCVD`状态，这个时候的socket会放到半连接队列。\r\n- **全连接队列(accept queue)**：当服务端收到客户端的ACK后，socket会从半连接队列移出到全连接队列。当调用accpet函数的时候，会从全连接队列的头部返回可用socket给用户进程。\r\n\r\n![全连接队列、半连接队列](C:/Users/86158/Desktop/掘金笔记/计算机网络.assets/v2-5f42955a0b0017d9707d730c94a2e519_720w.jpg)\r\n\r\n**半连接队列**\r\n\r\n半连接队列的大小由`/proc/sys/net/ipv4/tcp_max_syn_backlog`控制，Linux的默认是1024。\r\n\r\n当服务端发送`SYN_ACK`后将会开启一个定时器，如果超时没有收到客户端的`ACK`，将会重发`SYN_ACK`包。重传的次数由`/proc/sys/net/ipv4/tcp_synack_retries`控制，默认是5次。\r\n\r\n**全连接队列**\r\n\r\n全连接队列的大小通过`/proc/sys/net/core/somaxconn`指定，在使用listen函数时，内核会根据传入的`backlog`参数与系统参数somaxconn，取二者的较小值。\r\n\r\n**流程简述如下**：\r\n\r\n1. 客户端发送SYN付服务端进行第一次报文握手，***\\*此时服务端将此请求信息放在半连接队列中\\****并回复SYN+ACK给客户端。\r\n\r\n> 此处就是SYN Flood（后续关注，此篇记录）攻击的点，攻击方要做的就是不停的建立连接，但是确不给出ACK确认，导致半连接队列满了，其他请求无法进入。\r\n\r\n2. 客户端收到SYN+ACK，随机发出ACK确认给服务端；\r\n\r\n  ***\\*全队列未满\\****：从半连接队列拿出此消息放入全队列中。\r\n\r\n  ***\\*全队列已满\\****：处理方式和tcp_abort_on_overflow（cat /proc/sys/net/ipv4/tcp_abort_on_overflow）有关：\r\n\r\n​           tcp_abort_on_overflow=0；表示丢弃该ACK；\r\n\r\n​           tcp_abort_on_overflow=1；表示发送一个RST给客户端，直接废弃掉这个握手过程。\r\n\r\n3. 服务端accept处理此请求，从全队列中将此请求信息拿出。\r\n\r\n**listen函数**：\r\n\r\n```text\r\nint listen(int sockfd, int backlog)\r\n```\r\n\r\nNginx和Redis默认的backlog值等于511，Linux默认的backlog 为 128，Java默认的backlog等于50\r\n\r\n默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传`SYN+ACK`，也可以修改这种行为，这个值由`/proc/sys/net/ipv4/tcp_abort_on_overflow`决定。\r\n\r\n- tcp_abort_on_overflow为0表示三次握手最后一步全连接队列满以后服务端会丢掉客户端发过来的ACK，服务端随后会进行重传`SYN+ACK`。\r\n- tcp_abort_on_overflow为1表示全连接队列满以后服务端发送RST给客户端，直接释放资源。\r\n\r\n### TCP与HTTP的关系，如何基于TCP实现HTTP\r\n\r\nTCP是传输层协议，HTTP是应用层协议，HTTP是建立在TCP协议之上的一种应用。简单地说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。HTTP是用来收发数据的，即实际应用的。\r\n\r\n第一：从传输层，我们和服务器端建立TCP连接，首先需要通过三次握手建立连接，简单地说就是：请求，确认，连接\r\n\r\n第二：从实际上的数据应用来说http，在前面客户端与服务器建立TCP连接之后，就需要用HTTP来传送数据了。\r\n\r\n**TCP是底层通讯协议，定义的是数据传输和连接方式的规范**\r\n\r\n**HTTP是应用层协议，定义的是传输数据的内容的规范**\r\n\r\nHTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP   \r\n\r\nHTTP支持的是www服务 \r\n\r\n而TCP/IP是协议 \r\n\r\n它是Internet国际互联网络的基础。TCP/IP是网络中使用的基本的通信协议。 \r\n\r\nTCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整\r\n\r\n传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。\r\n\r\n### TCP与UDP的伪首部\r\n\r\npseudo header的作用： protection against misrouted segments，翻译一下就是**避免协议栈接收到不“真正“属于自己的错误数据报**。\r\n\r\n首先我们得了解一下pseudo header在协议栈中是如何使用的，在发送每一个TCP/UDP数据报的时候会填充pseudo header结构体，然后再和TCP头一起参与到检验码的计算中，在接收端会对收到的数据报进行校验码的验证，具体的参考：[伪头部](javascript:void())。\r\n\r\n> 伪首部并非TCP&[UDP](https://baike.baidu.com/item/UDP/571511)[数据报](https://baike.baidu.com/item/数据报/2194617)中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算[校验和](https://baike.baidu.com/item/校验和)。这样的校验和，既校验了TCP&UDP用户数据的源[端口号](https://baike.baidu.com/item/端口号)和目的端口号以及TCP&UDP用户数据报的数据部分，又检验了[IP数据报](https://baike.baidu.com/item/IP数据报/1581132)的源[IP地址](https://baike.baidu.com/item/IP地址/150859)和目的地址。伪报头保证TCP&UDP[数据单元](https://baike.baidu.com/item/数据单元/1415766)到达正确的目的地址。因此，伪报头中包含IP地址并且作为计算校验和需要考虑的一部分。最终目的端根据伪报头和数据单元计算校验和以验证通信数据在传输过程中没有改变而且到达了正确的目的地址。\r\n\r\n乍一看这个解释觉得挺好理解的，但是稍微费点脑细胞一想，好像这个解释不太对啊！按照协议栈的处理数据报流程肯定是要先经过IP层的处理过滤掉不属于自己的IP数据报后才接着往上层处理的，怎么到了上层（TCP、UDP）还需要校验数据报是否属于自己呢？\r\n\r\nInternet中的数据报会在传输过程中经过多跳（hop）才会到达最终的目的地址，在中间的任何一跳都可能会存在软件/硬件的错误，导致本来应该到达X的数据报到达了Y（修改了数据报中的dst address和IP层的checksum），这样的数据报可以顺利的逃过IP层的校验到达上层TCP/UDP。这个时候pseudo header就发挥它的作用了，通过计算数据报的校验码就能发现这是一个错误的数据报，它并是“真正“的属于我。\r\n\r\n我能说我这个人比较喜欢瞎想吗？我怎么觉得上面的这个解释好像还是有点不太好理解了，既然我能修改IP层的数据那么我同样可以修改TCP/UDP层的数据啊，这样我把TCP/UDP中的校验码checksum重新计算修改成“正确“的值，这样这个数据报不就可以逃过IP层、TCP层的校验了吗？\r\n\r\n是的，这样修改过的数据报是完全“正确“的，目的协议栈会认为这个数据报是合法的。也就是说pseudo header只能防“君子“不能防“小人“，pseudo header主要是为了修正中间网络设备的错误路由，因为中间路由设备一般都只会操作IP层不会操作TCP/UDP层，所以也就不会错误的修改TCP/UDP的checksum了。",
        "timemini": ""
    },
    {
        "index": 29,
        "title": "让你的JavaScript更上一层楼",
        "essay": "\r\n# 基础\r\n\r\n## 数据类型\r\n\r\n1. 分类\r\n    1. 基本类型\r\n        * `string` :  任意字符串\r\n        * `number`： 任意数字\r\n        * `boolean`： true / false\r\n        * `undefined` : undefined\r\n        * `null` : null\r\n    2. 对象类型\r\n        * `Object` : 任意对象\r\n        * `function` ： 一种特别的对象（可以执行）\r\n        * `Array` ： 一种特别的对象（数值下标，内部数据是有序的）\r\n2. 判断\r\n    * `typeof`\r\n        * 可以判断： undefined / number / string / boolean\r\n    * `instanceof` : 判断对象的具体类型\r\n    * `===` \r\n        * 可以判断： undefined, null\r\n\r\n==案例==： undefined 是一个值。 'undefined' 是一个字符串，表示undefined这个数据类型。\r\n\r\n```javascript\r\nvar a;\r\nconsole.log(a,typeof a, typeof a === 'undefined', a === undefined)\r\n// undefined  'undefined'  true  true\r\n```\r\n\r\n==Question==:\r\n\r\n1. undefined 与 null 的区别？\r\n    * undefined 代表定义未赋值\r\n    * null 代表定义并赋值了,只是值为null\r\n2. 什么时候给变量赋值为null呢？\r\n    * 初始赋值，表明将要赋值为对象\r\n    * 结束前，让对象成为垃圾对象（被垃圾回收器回收）\r\n3. 严格区别变量类型与数据类型？\r\n    * 数据的类型\r\n        * 基本类型\r\n        * 对象类型\r\n    * 变量的类型（变量内存值的类型）\r\n        * 基本类型：保存就是基本类型的数据\r\n        * 引用类型：保存的地址值\r\n\r\n### 数据 变量 内存\r\n\r\n==Question==:\r\n\r\n1. 什么是数据？\r\n\r\n    * 存储在内存中代表特定信息的东西，本质上是0101...\r\n    * 数据的特点： 可传递，可运算\r\n    * 内存中所有操作的目标 ： 数据\r\n        * 算术运算\r\n        * 逻辑运算\r\n        * 赋值运算\r\n        * 运行函数\r\n\r\n2. 什么是内存？\r\n   \r\n    * 内存条通电后产生的用来可存储数据的空间（临时的） \r\n    * 内存分类\r\n        * 栈 ：全局变量/局部变量\r\n        * 堆 ： 对象\r\n    \r\n3. 什么是变量？\r\n    * 可以变化的量，由变量名和变量值组成\r\n    * 每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据\r\n    \r\n4. 内存，数据，变量三者之间的关系？\r\n\r\n    * 内存用来存储数据的临时空间\r\n\r\n5. `var a = xxx`, a 内存中保存的是什么？\r\n\r\n    * xxx是基本数据，保存的就是这个数据\r\n    * xxx是对象，保存的是对象的地址值\r\n    * xxx是一个变量，保存的xxx的内存内容（可能是基本数据，也可能是地址值 ）\r\n\r\n6. ```html\r\n    var a = {age: 12}\r\n    function fn2(obj){\r\n    \tobj = {age: 15}\r\n    }\r\n    fn2(a)\r\n    console.log(a.age)  // 12\r\n    ```\r\n\r\n7. 引用变量赋值问题\r\n\r\n    * 2个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据\r\n    * 2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象\r\n\r\n8. 在JS调用函数时传递变量参数时，是值传递还是引用传递？\r\n\r\n    * 理解1：都是值（基本/地址值）传递\r\n    * 理解2： 可能是值传递，也可能是引用传递（地址值）\r\n\r\n9. JS引擎如何管理内存？\r\n\r\n    1. 内存生命周期\r\n        * 分配小内存空间，得到它的使用权\r\n        * 存储数据，可以反复进行操作\r\n        * 释放小内存空间\r\n    2. 释放内存\r\n        * 局部变量：函数执行完自动释放\r\n        * 对象：成为垃圾对象 ==> 垃圾回收器回收\r\n\r\n## 对象\r\n\r\n### 什么是对象？\r\n\r\n* 多个数据的封装体\r\n* 用来保存多个数据的容器\r\n* 一个对象代表现实中的一个事物\r\n\r\n### 为什么要用对象？\r\n\r\n* 统一管理多个数据\r\n\r\n### 对象的组成\r\n\r\n* 属性： 属性名（字符串）和属性值（任意值）组成\r\n* 方法：一种特别的属性（属性值是函数  ）\r\n\r\n### 如何访问对象内部数据\r\n\r\n* . 属性名： 编码简单，有时不能用\r\n* `['属性名']` : 编码麻烦，能通用\r\n\r\n### 什么时候必须使用['属性名']的方式？\r\n\r\n1. 属性名包含特殊字符：  -  空格\r\n\r\n    ```html\r\n    var p = {}\r\n    p.content-type = 'text/json' // 不能用\r\n    p['content-type'] = 'text/json'\r\n    ```\r\n\r\n2. 属性名不确定\r\n\r\n    ```html\r\n    var proName = 'myAge'\r\n    var value = 18\r\n    p.propName = value  //不能用\r\n    p[propName] = value\r\n    ```\r\n\r\n\r\n\r\n## 函数\r\n\r\n### 什么是函数？\r\n\r\n* 实现特定功能的n条语句的封装体\r\n* 只有函数时可以执行的，其他类型的数据都不可以执行\r\n\r\n### 为什么要用函数\r\n\r\n* 提高代码复用\r\n* 便于阅读交流\r\n\r\n### 如何定义函数\r\n\r\n* 函数声明\r\n\r\n    ```html\r\n    function fn1 () {\r\n    \tconsole.log('fn1()')\r\n    }\r\n    ```\r\n\r\n* 表达式\r\n\r\n    * ```html\r\n        var fn2 = function () {\r\n        \tconsole.log('fn1()')\r\n        }\r\n        ```\r\n\r\n### 如何调用函数\r\n\r\n* `test()` 直接调用\r\n* `obj.test()` 通过对象调用\r\n* `new test() `:  new调用\r\n* `test.call/apply(obj)` ： 临时让test成为obj的方法进行调用\r\n\r\n### 回调函数\r\n\r\n#### 什么函数才是回调函数？\r\n\r\n1. 你定义的\r\n2. 你没有调用\r\n3. 但最终它执行了\r\n\r\n#### 常见的回调函数？\r\n\r\n* `dom`事件回调函数\r\n* 定时器回调函数\r\n* ajax请求回调函数\r\n* 生命周期回调函数 \r\n\r\n## IIFE 立即执行函数\r\n\r\n1. 理解\r\n    * 全称：Immediately-Invoked Function Expression\r\n2. 作用\r\n    * 隐藏实现\r\n    * 不会污染外部命名空间 \r\n\r\n## 函数中的this\r\n\r\n### this是什么\r\n\r\n* 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是`window`\r\n\r\n* 所有函数内部都有一个变量`this` \r\n* 它的值是调用函数的当前对象\r\n\r\n### 如何确定this的值\r\n\r\n* test() : window\r\n* p.test() : p\r\n* new test() : 新创建的对象\r\n* p.call(obj) : obj \r\n\r\n\r\n\r\n# 函数高级\r\n\r\n## 原型与原型链\r\n\r\n1. 函数的prototype属性\r\n    * 每个函数都有一个prototype属性，它默认指向一个Object空对象（即原型对象）\r\n    * 原型对象中有一个属性constructor，它指向函数对象\r\n2. 给原型对象添加属性（一般都是方法）\r\n    * 作用：函数的所有实例对象自动拥有原型中的属性（方法）\r\n\r\n### 显式原型与隐式原型\r\n\r\n1. 每个函数function都有一个prototype，即显式原型（属性）\r\n2. 每个实例对象都有一个`__proto__`，可成为隐式原型（属性）、\r\n3. 对象的隐式原型的值为其对应构造函数的显式原型的值\r\n4. 内存结构\r\n5. 总结：\r\n    1. 函数的prototype属性，在定义函数时自动添加的，默认值是一个空Object对象\r\n    2. 对象的`__proto__`属性：在创建对象时自动添加的，默认值为构造函数的prototype属性值\r\n\r\n![image-20220527223950329](http://cdn.yangdw.cn/img/image-20220527223950329.png)\r\n\r\n",
        "timemini": ""
    }
]